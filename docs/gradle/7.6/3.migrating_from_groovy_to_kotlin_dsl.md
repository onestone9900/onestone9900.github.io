---
layout: default
title: 그루비에서 코틀린으로 빌드 로직 마이그레이션(Migrating build logic from Groovy to Kotlin)
parent: 7.6
grand_parent: Gradle
nav_order: 4
---

***
<B>목차</B>
- 마이그레이션을 시작하기 전(Before you start migrating)
- 그루비 스크립트 준비(Prepare your Groovy scripts)
- 스크립트 파일명 지정(Script file naming)
- 플러그인 적용(Applying plugins)
- 플러그인 구성(Configuring plugins)
- 구성 회피(Configuration avoidance)
- 태스크 구성(Configuring tasks)
- 태스크 생성(Creating tasks)
- 구성 및 의존성(Configurations and dependencies)
- 마이그레이션 전략(Migration strategies)
- 상호 호환성(Interoperability)
***


# 그루비에서 코틀린으로 빌드 로직 마이그레이션(Migrating build logic from Groovy to Kotlin)
이 장에서는 그루비 기반 그레이들 빌드 스크립트를 코틀린으로 변환하는 과정을 안내한다.

그루비의 최신 코틀린 DSL은 지원되는 IDE(콘텐츠 지원, 리팩터링, 문서 등)에서 쾌적한 편집 환경을 제공한다.

***
또한 [그레이들 코틀린 DSL 입문서](https://onestone9900.github.io/docs/gradle/7.6/2.gradle_kotlin_dsl_primer/)를 읽어 그레이들 코틀린 DSL의 특수성, 제한사항, 사용법을 알아보자.

사용자 매뉴얼의 나머지 부분에는 그루비 DSL과 코틀린 DSL을 모두 보여주는 빌드 스크립트 발췌문이 포함되어 있다. 이곳은 이를 수행하는 방법과 각 DSL에 대해 무엇을 찾을 수 있는 가장 좋은 장소다. [플러그인 사용](https://docs.gradle.org/7.6/userguide/plugins.html#plugins)부터 [의존성 해결 동작 커스텀](https://docs.gradle.org/7.6/userguide/dependency_constraints.html#dependency-constraints)까지 모든 그레이들 기능을 다룬다.
***


## 마이그레이션을 시작하기 전(Before you start migrating)
읽어 보자: 마이그레이션하기 전에 다음과 같은 중요한 정보를 이해하는 것이 도움이 된다.

- 가장 먼저 최신 버전의 그레이들, 적용된 플러그인, IDE를 사용하는 것이 좋다.
- 코틀린 DSL은 인텔리j IDEA 및 안드로이드 스튜디오에서 완벽하게 지원된다. 이클립스 또는 넷빈즈와 같은 다른 IDE는 아직 그레이들 코틀린 DSL 파일을 편집하는 데 유용한 도구를 제공하지 않지만 코틀리 DSL 기반 빌드 임포트 및 태스크는 평소와 같이 작동한다.
- 인텔리J IDEA에서는 코틀린 DSL 스크립트용 콘텐츠 지원 및 리팩토링 도구를 얻으려면 [그레이들 모델에서 프로젝트를 임포트](https://onestone9900.github.io/docs/kotlin/Tools/Build%20Tools/Gradle/2.%20get_started_with_gradle_and_kotlin_JVM/) 한다.
- 코틀린 DSL이 더 느린 상황이 있다. 예를 들어 클린 체크아웃이나 임시 CI 에이전트에서 처음 사용하는 경우 [속도가 더 느린 것](https://github.com/gradle/gradle/issues/15886)으로 알려져 있다. `buildSrc` 디렉터리의 내용이 변경되어 빌드 스크립트 캐싱이 무효화되는 시나리오에도 동일하게 적용된다. 구성 시간이 느린 빌드는 IDE 응답성에 영향을 미칠 수 있다. [그레이들 성능](https://docs.gradle.org/7.6/userguide/performance.html#performance_gradle)에 대한 문서를 확인하자.
- 자바 8 이상으로 그레이들을 실행해야 한다. 자바 7은 지원되지 않는다.
- 임베디드 코틀린 컴파일러는 x86-64 아키텍처의 리눅스, 맥OS, 윈도우, Cygwin, FreeBSD 및 솔라리스에서 작동하는 것으로 알려져 있다.
- 코틀린 문법과 기본 언어 기능에 대한 지식은 매우 도움이 된다. [코틀린 레퍼런스 문서](https://kotlinlang.org/docs/home.html)와 [코틀린 Koans](https://kotlinlang.org/docs/tutorials/koans.html)가 도움이 될 것이다.
- `plugins {}` 블록을 사용하여 그레이들 플러그인을 선언하면 편집 환경이 크게 향상되므로 적극 권장된다. 코틀린으로 변환하기 전에 그루비 빌드 스크립트에 이를 채택하는 것을 고려해 보자.
- 코틀린 DSL은 `model {}` 요소를 지원하지 않는다. 이는 [중단된 그레이들 소프트웨어 모델](https://blog.gradle.org/state-and-future-of-the-gradle-software-model?_gl=1*6akbw1*_ga*MTA5NjA5NTMyOC4xNjgxMjIxMTIx*_ga_7W7NC6YNPT*MTY5NjMzODg2MS41MS4xLjE2OTYzMzk2MzUuMjAuMC4w)의 일부다.
- 인큐베이팅 구성 온디맨드 기능(incubating configuration on demand feature)을 활성화하는 것은 진단하기 매우 어려운 문제로 이어질 수 있으므로 권장되지 않는다.

[그레이들 코틀린 DSL 입문서(Gradle Kotlin DSL Primer)](https://onestone9900.github.io/docs/gradle/7.6/2.gradle_kotlin_dsl_primer/)에서 자세히 알아보자.

이슈가 발생하거나 버그가 의심되는 경우, [`gradle/gradle` 이슈 트래커](https://github.com/gradle/gradle/issues/)를 활용하자.

한꺼번에 마이그레이션할 필요는 없다! 그루비 및 코틀린 기반 빌드 스크립트는 둘 다 두 언어의 다른 스크립트를 적용할 수 있다. [코틀린 DSL 샘플](https://github.com/gradle/kotlin-dsl-samples/tree/master/samples)에서 다루지 않은 그레이들 기능에 대한 영감을 얻을 수 있다.


## 그루비 스크립트 준비(Prepare your Groovy scripts)
코틀린과 그루비의 몇 가지 간단한 언어 차이로 인해 스크립트 변환이 지루해질 수 있다.
- 그루비 문자열은 작은따옴표 'string' 또는 큰따옴표 "string"으로 묶을 수 있지만 코틀린에서는 큰따옴표 "string"만 사용된다.
- 그루비에서는 함수를 호출할 때 괄호를 생략할 수 있지만 코틀린에서는 항상 괄호가 필요하다.
- 그레이들 그루비 DSL에서는 프로퍼티스를 할당할 때 = 할당 연산자(assignment operator)를 생략할 수 있지만 코틀린에서는 항상 할당 연산자가 필요하다.

첫 번째 마이그레이션 단계로, 다음과 같이 그루비 빌드 스크립트를 준비하는 것이 좋다.
- 큰따옴표(double quotes)를 사용하여 따옴표를 통합하고,
- 함수 호출(invocation) 및 프로퍼티 할당(assignment)을 명확하게 한다(각각 괄호와 할당 연산자 사용).

전자는 '를 검색하고 "로 바꾸면 쉽게 수행할 수 있다. 예를 들어,

`build.gradle`
```groovy
group 'com.acme'

dependencies {
    implementation 'com.acme:example:1.0'
}
```

이 된다.

`build.gradle`
```groovy
group "com.acme"

dependencies {
    implementation "com.acme:example:1.0"
}
```
그루비 스크립트에서 함수 호출과 프로퍼티 할당을 구별하는 것이 쉽지 않을 수 있으므로 후자는 좀 더 복잡하다. 좋은 전략은 먼저 모든 모호한 명령문 프로퍼티 할당을 수행한 다음 실패한 명령문을 함수 호출로 전환하여 빌드를 수정하는 것이다.

예를들어,

`build.gradle`
```groovy
group "com.acme"

dependencies {
    implementation "com.acme:example:1.0"
}
```

becomes:

`build.gradle`
```groovy
group = "com.acme" //............................... 1.

dependencies {
    implementation("com.acme:example:1.0") //....... 2.
}
```

1. 프로퍼티 할당
2. 함수 호출

그루비를 유지하면서 코틀린 문법에 가까워 졌기 때문에 스크립트 이름을 바꿔 그레이들 코틀린 DSL 스크립트로 전환하기가 더 쉬워졌다.


## 스크립트 파일명 지정(Script file naming)
***
그루비 DSL 스크립트 파일은 .gradle 파일명 확장자를 사용한다.
코틀린 DSL 스크립트 파일은 .gradle.kts 파일 이름 확장자를 사용한다.
***

코틀리 DSL을 사용하려면 파일명을 build.gradle 대신 build.gradle.kts로 지정하면 된다.

세팅 파일인 settings.gradle의 이름을 settings.gradle.kts로 바꿀 수도 있다.

다중 프로젝트 빌드에서는 그루비 DSL(build.gradle 포함)을 사용하는 일부 모듈과 코틀린 DSL(build.gradle.kts 포함)을 사용하는 다른 모듈을 가질 수 있다.

또한, 더 나은 IDE 지원을 위해 다음 컨벤션을 적용하자.
- `*.settings.gradle.kts` 패턴에 따라 설정에 적용되는 스크립트명을 지정,
- `*.init.gradle.kts` 패턴에 따라 init 스크립트명을 지정한다.


## 플러그인 적용(Applying plugins)
그루비 DSL과 마찬가지로 그레이들 플러그인을 적용하는 방법에는 두 가지가 있다.
- 선언적으로, `plugins {}` 블록을 사용하여,
- 필수적으로, 레거시 `apply(..)` 함수를 사용한다.

다음은 선언적 `plugins {}` 블록을 사용하는 예제다.

`build.gradle`
```groovy
plugins {
    id 'java'
    id 'jacoco'
    id 'maven-publish'
    id 'org.springframework.boot' version '2.4.1'
}
```

`build.gradle.kts`
```kotlin
plugins {
    java
    jacoco
    `maven-publish`
    id("org.springframework.boot") version "2.4.1"
}
```

코틀린 DSL은 위에 표시된 `java`, `jacoco` 또는 `maven-publish` 선언과 같이 모든 그레이들 코어 플러그인에 대한 프로퍼티 확장을 제공한다.

그루비 DSL과 동일한 방식으로 서드파티 플러그인을 적용할 수 있다. 큰따옴표와 괄호는 제외한다. 해당 스타일로 핵심 플러그인을 적용할 수도 있다. 그러나 정적으로 타입이 지정된 접근자는 타입이 안전하고 IDE에서 자동 완성되므로 권장된다.

명령형(imperative) `apply` 구문을 사용할 수도 있지만, 코어가 아닌(non-core) 플러그인은 빌드 스크립트의 클래스패스에 포함되어야 한다.

`build.gradle`
```groovy
buildscript {
    repositories {
        gradlePluginPortal()
    }
    dependencies {
        classpath('org.springframework.boot:spring-boot-gradle-plugin:2.4.1')
    }
}

apply plugin: 'java'
apply plugin: 'jacoco'
apply plugin: 'org.springframework.boot'
```

`build.gradle.kts`
```kotlin
buildscript {
    repositories {
        gradlePluginPortal()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:2.4.1")
    }
}

apply(plugin = "java")
apply(plugin = "jacoco")
apply(plugin = "org.springframework.boot")
```

***
<B>apply() 함수보다 plugins {} 블록을 사용하는 것이 좋다.</B>

`plugins {}` 블록의 선언적 특성을 통해 코틀린 DSL은 적용된 플러그인이 제공하는 확장, 구성 및 기타 기능에 대해 타입 안전 접근자를 제공할 수 있다. 이를 통해 IDE가 플러그인 모델의 세부정보를 쉽게 발견하고 구성하기 쉽다.

자세한 내용은 그레이들 [사용자 매뉴얼의 `plugins {}` 블록 문서](https://docs.gradle.org/7.6/userguide/plugins.html#sec:plugins_block)를 참고하자.
***


## 플러그인 구성(Configuring plugins)
많은 플러그인에는 이를 구성할 수 있는 확장(extension) 기능이 함께 제공된다. 선언적 `plugins {}` 블록을 사용하여 해당 플러그인을 적용하면 코틀린 확장 기능을 사용하여 그루비와 동일한 방식으로 확장을 구성할 수 있다. 다음 샘플은 이것이 `jacoco` 플러그인에서 어떻게 작동하는지 보여준다.

`build.gradle`
```groovy
plugins {
    id 'jacoco'
}

jacoco {
    toolVersion = '0.8.1'
}
```

`build.gradle.kts`
```kotlin
plugins {
    jacoco
}

jacoco {
    toolVersion = "0.8.1"
}
```

대조적으로, 명령형 `apply()` 함수를 사용하여 플러그인을 적용하는 경우 해당 플러그인을 구성하려면 `configure<T>()` 함수를 사용해야 한다. 다음 샘플은 `configure<T>()` 함수에서 플러그인의 확장 클래스인 `CheckstyleExtension`을 명시적으로 선언하여 `Checkstyle` 플러그인에서 이것이 어떻게 작동하는지 보여준다.

`build.gradle`
```groovy
apply plugin: "checkstyle"

checkstyle {
    maxErrors = 10
}
```

`build.gradle.kts`
```kotlin
apply(plugin = "checkstyle")

configure<CheckstyleExtension> {
    maxErrors = 10
}
```

다시 한 번, `plugins {}` 블록을 통해 플러그인을 선언적으로 적용하는 것이 좋다.

***
<B>어떤 플러그인이 제공하는 확장 기능을 사용할 수 있는지 알아보기</B>

IDE는 플러그인이 제공하는 구성 요소를 알고 있으므로 IDE에 제안할 때 해당 요소를 포함하도록 한다. 이는 빌드 스크립트의 최상위 레벨(대부분의 플러그인 확장이 프로젝트(Project) 객체에 추가됨)과 확장의 구성(configuration) 블록 내에서 모두 발생한다.

또한 `:kotlinDslAccessorsReport` 태스크를 실행하여 적용된 모든 플러그인이 제공하는 확장에 대해 알아볼 수도 있다. 해당 확장 접근에 사용할 수 있는 코틀린 코드를 나타나게 접근자 메서드명과 타입을 제공한다.
***

구성하려는 플러그인이 메서드 시그니처에서 `groovy.lang.Closure`를 사용하거나 다른 동적 그루비 의미 체계를 사용하는 경우 코틀린 DSL 빌드 스크립트에서 해당 플러그인을 구성하려면 더 많은 작업이 필요하다. 코틀린 코드에서 크루비 코드를 호출하는 방법이나 그루비 스크립트에서 플러그인 구성을 유지하는 방법에 대한 자세한 내용은 [그레이들 코틀린 DSL 문서의 상호 운용성 장](https://docs.gradle.org/7.6/userguide/kotlin_dsl.html#sec:interoperability)을 참고하자.

플러그인은 직접 구성할 수 있는 태스크에도 기여한다. 이 주제는 아래 태스크 구성에서 다룬다.

***
<B>빌드 스크립트를 선언적으로 유지하기</B>

그레이들 코틀린 DSL의 이점을 최대한 활용하려면 빌드 스크립트를 선언적으로 유지하려고 노력해야 한다. 여기서 기억해야 할 가장 중요한 점은 타입 안전 접근자를 얻으려면 빌드 스크립트 본문보다 먼저 플러그인을 적용해야 한다는 것이다.

그레이들 사용자 매뉴얼에서 그레이들 코틀린 DSL을 사용하여 플러그인을 구성하는 방법을 읽어보는 것이 좋다.

예를 들어, 대부분의 안드로이드 빌드와 같이 빌드가 멀티 프로젝트 빌드인 경우 멀티 프로젝트 빌드에 대한 후속 장도 읽어보자.

마지막으로, 안드로이드 그레이들 플러그인과 같이 올바른 메타데이터로 게시되지 않은 플러그인과 함께 `plugins {}` 블록을 사용하는 전략이 있다.
***


## 구성 회피(Configuration avoidance)
그레이들 4.9에는 빌드 스크립트 및 플러그인에서 태스크를 생성하고 구성하기 위한 새로운 API가 도입됐다. 이 새로운 API가 결국 기존 API를 대체하려는 의도다.

{: .note}
기존 그레이들 태스크 API와 새로운 그레이들 태스크 API의 주요 차이점 중 하나는 그레이들이 `Task` 인스턴스를 생성하고 구성 코드를 실행하는 데 시간을 소비하는지 여부다. 새로운 API를 사용하면 그레이들은 빌드에서 실행되지 않는 태스크 구성을 지연하거나 완전히 피할 수 있다. 예를 들어 코드를 컴파일할 때 그레이들은 테스트를 실행하는 태스크를 구성할 필요가 없다.

자세한 내용은 구성 시간을 줄이기 위해 [그레이들 API 발전(Evolving the Gradle API to reduce configuration time)](https://blog.gradle.org/preview-avoiding-task-configuration-time?_gl=1*v4crvm*_ga*MTA5NjA5NTMyOC4xNjgxMjIxMTIx*_ga_7W7NC6YNPT*MTY5NjQ2ODQwMi41My4wLjE2OTY0Njg0MDIuNjAuMC4w) 블로그 게시물과 사용자 매뉴얼의 [태스크 구성 회피](https://docs.gradle.org/7.6/userguide/task_configuration_avoidance.html#task_configuration_avoidance) 장을 참고하자.

그레이들 코틀린 DSL은 타입 안전 모델 접근자가 새로운 API를 활용하도록 하고 DSL 구성을 제공하여 이를 더 쉽게 사용할 수 있도록 함으로써 구성 회피를 적용한다. 전체 그레이들 API는 계속 사용할 수 있다.
