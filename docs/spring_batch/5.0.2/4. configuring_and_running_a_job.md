---
layout: default
title: 4. Configuring and Running a Job
parent: 5.0.2
grand_parent: SpringBatch
nav_order: 4
---


# 4. Configuring and Running a Job
도메인 섹션에서는, 다음 다이어그램을 가이드로 사용하여, 전체 아키텍처 설계를 논의했다.

![](https://docs.spring.io/spring-batch/docs/current/reference/html/images/spring-batch-reference-model.png)
이미지 7. 배치 개념(Stereotypes)

`잡(Job)` 객체는 스텝(Step)를 위한 단순한 컨테이너처럼 보일 수 있지만 많은 구성 옵션을 알고 있어야 한다. 또한, `잡`을 실행하는 방법과 해당 실행 중에 해당 메타데이터를 저장하는 방법에 대한 많은 옵션을 고려해야 한다. 이 챕터에서는 `잡`의 다양한 구성 옵션 및 런타임 문제에 대해 설명한다.


## 4.1. Configuring a Job
잡 인터페이스에는 여러 구현이 있다. 그러나, 이러한 구현은 제공된 빌더(자바 구성) 또는 XML 네임스페이스(XML 기반 구성) 뒤에서 추상화된다. 다음 예는 자바 및 XML 구성을 모두 보여준다:

`자바 구성`
```
  @Bean
  public Job footballJob(JobRepository jobRepository) {
    return new JobBuilder("footballJob", jobRepository)
                      .start(playerLoad())
                      .next(gameLoad())
                      .next(playerSummarization())
                      .build();
  }
```

`XML 구성`
```
  <job id="footballJob">
    <step id="playerload" parent="s1" next="gameLoad"/>
    <step id="gameLoad" parent="s2" next="playerSummarization"/>
    <step id="playerSummarization" parent="s3"/>
  </job>
```

앞의 예제는 상위(parent) 빈 정의를 사용하여 스텝을 생성한다. 특정 스텝의 세부 정보를 인라인으로 선언할 때의 추가 옵션은 스텝 구성 섹션을 참조하자. XML 네임스페이스는 기본값인 `잡리포지터리(jobRepository)`의 `id`로 리포지터리를 참조한다. 그러나, 이 기본값을 명시적으로 재정의할 수 있다:

```
  <job id="footballJob" job-repository="specialRepository">
    <step id="playerload"          parent="s1" next="gameLoad"/>
    <step id="gameLoad"            parent="s3" next="playerSummarization"/>
    <step id="playerSummarization" parent="s3"/>
  </job>
```

스텝 외에도, 잡 구성에는 병렬화(`<split>`), 선언적 흐름 제어(`<decision>`) 및 흐름 정의의 외부화(`<flow/>`)에 도움이 되는 다른 요소가 포함될 수 있다.


### 4.1.1. Restartability
배치 잡 실행 시 한 가지 중요한 문제는 `잡`의 재시작 동작과 관련이 있다. 특정 `잡인스턴스(JobInstance)`에 대한 `잡익스큐션(JobExecution)`이 이미 존재하는 경우 `잡` 시작은 "재시작"으로 간주한다. 이상적으로, 모든 잡이 중단된 위치에서 시작할 수 있어야 하지만 이것이 불가능한 시나리오가 있다. 이 시나리오에서 새로운 `잡인스턴스`가 생성되었는지 확인하는 것은 전적으로 개발자의 몫이다. 그러나, 스프링 배치에서 약간의 도움을 제공한다. `잡`을 재시작하면 항상 새로운 잡인스턴스의 일부로 실행해야 하는 경우, restartable 프로퍼티를 `false`로 설정할 수 있다. 

다음 예는 XML에서 `restartable` 필드를 `false`로 설정하는 방법을 보여준다: 

`XML 구성`
```
  <job id="footballJob" restartable="false">
    ...
  </job>
```

다음 예는 자바에서 `restartable` 필드를 `false`로 설정하는 방법을 보여준다:

`자바 구성`
```
  @Bean
  public Job footballJob(JobRepository jobRepository) {
      return new JobBuilder("footballJob", jobRepository)
                       .preventRestart()
                       ...
                       .build();
  }
```

다르게 표현하면, `restartable`을 `false`로 설정하면 "이 `잡`은 재시작을 지원하지 않는다"를 의미한다. 재시작할 수 없는 `잡`을 재시작하면 `잡리스타트익셉션(JobRestartException)`이 발생한다. 다음 Junit 코드는 예외를 발생시킨다:

```
  Job job = new SimpleJob();
  job.setRestartable(false);
  JobParameters jobParameters = new JobParameters();
  JobExecution firstExecution = jobRepository.createJobExecution(job, jobParameters);
  jobRepository.saveOrUpdate(firstExecution);
  try {
      jobRepository.createJobExecution(job, jobParameters);
      fail();
  }
  catch (JobRestartException e) {
    // 예외발생
  }
```

재시작할 수 없는 잡에 대한 잡익셉션(JobExecution)을 발생시키려는 첫 번째 시도는 문제가 발생하지 않는다. 그러나, 두 번째 시도에서는 잡리스타트익셉션(JobRestartException)이 발생한다.


### 4.1.2. Intercepting Job Execution
`잡`을 실행하는 동안, 사용자 지정 코드 실행을 위해 다양한 생명주기 이벤트에 대한 알림을 받는 것이 유용할 수 있다. `심플잡(SimpleJob)`은 적절한 위치에서 `잡리스너(JobListener)`를 호출하여 이를 가능하게 한다:

```
  public interface JobExecutionListener {
      void beforeJob(JobExecution jobExecution);
      void afterJob(JobExecution jobExecution);
  }
```

잡에 리스너(listener)를 설정하여 `잡리스너`를 `심플잡`에 추가할 수 있다. 다음 예는 XML 잡 정의에 리스너를 추가하는 방법을 보여준다:

`XML 구성`
```
  <job id="footballJob">
      <step id="playerload" parent="s1" next="gameLoad"/>
      <step id="gameLoad" parent="s2" next="playerSummarization"/>
      <step id="playerSummarization" parent="s3"/>
      <listeners>
          <listener ref="sampleListener"/>
      </listeners>
  </job>
```

다음 예는 자바 잡 정의에 리스너 메서드를 추가하는 방법을 보여준다:

`Java Configuration`
```
  @Bean
  public Job footballJob(JobRepository jobRepository) {
      return new JobBuilder("footballJob", jobRepository)
                       .listener(sampleListener())
                       ...
                       .build();
  }
```

`afterJob` 메소드는 `잡`의 성공 여부에 관계없이 호출된다. 성공 또는 실패를 결정해야 하는 경우, `잡익스큐션(JobExecution)`에서 해당 정보를 얻을 수 있다:

```
  public void afterJob(JobExecution jobExecution){
    if (jobExecution.getStatus() == BatchStatus.COMPLETED ) {
        //잡 성공
    } else if (jobExecution.getStatus() == BatchStatus.FAILED) {
      //잡 실패
    } 
  }
```

이 인터페이스에 해당하는 주석은 다음과 같다:
- `@BeforeJob`
- `@AfterJob`


### 4.1.3. Inheriting from a Parent Job
자바는 더 나은 재사용 기능을 제공하므로, 이 절에 내용은 XML 기반 구성에서만 사용된다.

유사하지만 동일하지 않은 구성을 가진 잡 그룹의 경우, 구체적인 `잡` 인스턴스가 프로퍼티를 상속할 수 있도록 "상위" `잡`을 정의하는 것이 도움이 될 수 있다. 자바의 클래스 상속과 유사하게, "하위" `잡`은 상위 잡의 요소, 애트리튜트와 결합할 수 있다.

다음 예에서 `baseJob`은 리스너 목록만 정의하는 추상적인 `잡` 정의이다. 다음 예는 `잡(job1)`은 `baseJob`에서 리스너 목록을 상속하고 이를 자체 리스너 목록과 병합하여 2개의 리스너와 1개의 `스텝(step1)`으로 `잡`을 생성한다:

```
  <job id="baseJob" abstract="true">
    <listeners>
      <listener ref="listenerOne"/>
    <listeners>
  </job>
  <job id="job1" parent="baseJob">
    <step id="step1" parent="standaloneStep"/>
    <listeners merge="true">
      <listener ref="listenerTwo"/>
    <listeners>
  </job>
```

자세한 내용은 상위 스텝에서 상속 섹션을 참조하자.


### 4.1.4. JobParametersValidator
XML 네임스페이스에서 선언되거나 `앱스트랙트잡(AbstractJob)`의 하위 클래스(subclass)를 사용하는 잡은 선택적으로 런타임 시 잡 파라미터에 대한 유효성 검사(validator)를 선언할 수 있다. 예를 들어, 모든 필수 파라미터로 잡이 시작되었음을 확인해야 하는 경우 유용하다. 간단한 필수 파라미터와 선택적 파라미터의 조합을 제한하는 데 사용할 수 있는 `디폴트잡파라미터밸리데이터(DefaultJobParametersValidator)`가 있다. 더 복잡한 제약 조건의 경우, 인터페이스(interface)를 직접 구현할 수도 있다.

유효성 검사의 구성은 다음과 같이 자바 빌더를 통해 지원된다:

```
  @Bean
  public Job job1(JobRepository jobRepository) {
      return new JobBuilder("job1", jobRepository)
                       .validator(parametersValidator())
                       ...
                       .build();
  }
```

XML 네임스페이스 지원은 `잡파라미터밸리테이터(JobParametersValidator)` 구성에도 사용할 수 있다:

```
  <job id="job1" parent="baseJob3">
      <step id="step1" parent="standaloneStep"/>
      <validator ref="parametersValidator"/>
  </job>
```

밸리데이터를 참조(reference, 위에 표시된 대로)하거나 빈 네임스페이스의 중첩된 빈 정의로 지정할 수 있다.

## 4.2. Java Configuration
스프링 3은 XML 대신 자바로 애플리케이션을 구성하는 기능을 가지고 있다. 스프링 배치 2.2.0부터 동일한 자바 구성을 사용하여 배치 잡을 구성할 수 있다. 자바 기반 구성에는 `@EnableBatchProcessing` 어노테이션과 두 개의 빌더의 세 가지 컴포넌트가 있다.

`@EnableBatchProcessing` 어노테이션은 스프링 제품군의 다른 `@Enable*` 어노테이션과 유사하게 작동한다. 이 경우, `@EnableBatchProcessing`은 배치 잡을 빌드하기 위한 기본 구성을 제공한다. 이 기본 구성 내에서, `스텝스코프(StepScope)` 및 `잡스코프(JobScope)`의 인스턴스가 생성되고, 자동 연결(autowired)될 수 있는 여러 빈이 생성된다:

- `잡리포지터리(JobRepository)`: `jobRepository`라는 이름의 빈(bean)
- `잡런쳐(JobLauncher)`: `jobLauncher`라는 이름의 빈
- `잡레지스트리(JobRegistry)`: `jobRegistry`라는 이름의 빈
- `잡익스플로러(JobExplorer)`: `jobExplorer`라는 이름의 빈
- `잡오퍼레이터(JobOperator)`: `jobOperator`라는 이름의 빈

기본 구현(implementation)은 앞의 목록에 언급된 빈을 제공하며 `데이터소스(DataSource)` 및 `플랫폼트랜젝션매니저(PlatformTransactionManager)`가 컨텍스트 내에서 빈으로 제공되어야 한다. 데이터 소스 및 트랜잭션 매니저는 `잡리포지터리(JobRepository)` 및 `잡익스플로러(JobExplorer)` 인스턴스에서 사용된다. 기본적으로, `데이터소스(DataSource)`와 `트랜젝션매니저(transactionManager)`가 사용된다. `@EnableBatchProcessing` 어노테이션의 애트리뷰트을 사용하여 이러한 빈을 커스텀할 수 있다. 다음 예는 사용자 정의 데이터 소스 및 트랜잭션 매니져를 제공하는 방법을 보여준다:

```
  @Configuration
  @EnableBatchProcessing(dataSourceRef = "batchDataSource", transactionManagerRef = "batchTransactionManager")
  public class MyJobConfiguration {
    @Bean
    public DataSource batchDataSource() {
      return new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.HSQL)
              .addScript("/org/springframework/batch/core/schema-hsqldb.sql")
              .generateUniqueName(true)
              .build();
    } 

    @Bean
    public JdbcTransactionManager batchTransactionManager(DataSource dataSource) {
      return new JdbcTransactionManager(dataSource);
    }

    public Job job(JobRepository jobRepository) {
      return new JobBuilder("myJob", jobRepository)
              //필요에 따라 잡의 흐름 정의
              .build();
    }
  }
```

{: .important}
>하나의 구성 클래스에만 `@EnableBatchProcessing` 어노테이션이 있어야 한다. 클래스에 주석을 달면, 앞에서 설명한 모든 구성을 갖게 된다.

v5.0부터, `디폴트배치컨피그레이션(DefaultBatchConfiguration)` 클래스를 통해 기본 인프라스트럭처 빈을 구성하는 방식의 대안이 제공된다. 이 클래스는 `@EnableBatchProcessing`에서 제공하는 동일한 빈을 제공하며 배치 잡을 구성하기 위한 기본 클래스로 사용할 수 있다. 다음 스니펫은 사용 방법에 대한 일반적인 예시다:

```
  @Configuration
  class MyJobConfiguration extends DefaultBatchConfiguration {
    @Bean
    public Job job(JobRepository jobRepository) {
      return new JobBuilder("job", jobRepository)
              //필요에 따라 잡의 흐름 정의
              .build();
    } 
  }
```

데이터 소스 및 트랜잭션 매니저는 애플리케이션 컨텍스트(application context)에서 확인되고 잡 레지스트리 및 잡 익스플로러에 설정된다. 필요한 setter를 재정의하여 인프라스트럭처 빈의 구성을 커스텀할 수 있다. 다음 예는 인스턴스에 대한 문자 인코딩을 커스텀하는 방법을 보여준다:

```
  @Configuration
  class MyJobConfiguration extends DefaultBatchConfiguration {
    @Bean
    public Job job(JobRepository jobRepository) {
      return new JobBuilder("job", jobRepository)
              //필요에 따라 잡의 흐름 정의
              .build();
    }

    @Override
    protected Charset getCharset() {
      return StandardCharsets.ISO_8859_1;
    } 
  }
```

{: .important}
>`@EnableBatchProcessing`은 `디폴트배치컨피그레이션(DefaultBatchConfiguration)`과 함께 사용하면 안 된다. `@EnableBatchProcessing`을 통해 스프링 배치를 구성하는 선언적(declarative) 방법을 사용하거나, `디폴트배치컨피그레이션(DefaultBatchConfiguration)`을 상속하는 프로그래밍 방식을 사용해야 하지만 동시에 두 가지 방법을 모두 사용할 수는 없다.


## 4.3. Configuring a JobRepository
`@EnableBatchProcessing`을 사용하면 `잡리포지터리(JobRepository)`가 제공된다. 이 절에서는 직접 구성하는 방법에 대해 설명한다.

앞에서 설명한 것처럼, `잡리포지터리(JobRepository)`는 `잡익스큐션(JobExecution)` 및 `스텝익스큐션(StepExecution)`과 같은 스프링배치 내에서 지속되는 다양한 도메인 객체의 기본 CRUD 작업에 사용된다. 그리고, 그것은 `잡런처(JobLauncher)`, `잡` 및 `스텝`과 같은, 많은 주요 프레임워크 기능에 필요하다.

배치 네임스페이스는 `잡리포지터리(JobRepository)` 구현체는 구현의 세부 정보와 협력 객체를 추상화한다. 그러나, 다음 예와 같이 몇 가지 구성 옵션을 사용할 수 있다:

`XML 구성`
```
  <job-repository id="jobRepository"
      data-source="dataSource"
      transaction-manager="transactionManager"
      isolation-level-for-create="SERIALIZABLE"
      table-prefix="BATCH_"
      max-varchar-length="1000"/>
```

`id` 외에는, 이전에 나열된 구성 옵션이 필요하지 않다. 설정하지 않으면 이전에 표시된 기본값이 사용된다. `max-varchar-length`는 기본값으로 샘플 스키마 스크립트에서 긴 VARCHAR 열의 길이인 2500으로 설정된다. 

`데이터소스(dataSource)` 및 `트랜젝션매니저(transactionManager)` 외에는 이전에 나열된 구성 옵션이 필요하지 않다. 설정하지 않으면, 이전에 표시된 기본값이 사용된다. 최대 `varchar` 길이는 기본적으로 샘플 스키마 스크립트에 있는 긴 VARCHAR 열의 길이인 `2500`이다.


### 4.3.1. Transaction Configuration for the JobRepository
네임스페이스 또는 제공된 `팩토리빈(FactoryBean)`을 사용하면, 잡리포지터리에 트랜잭션 어드바이스(transactional advice)가 자동으로 생성된다. 이것은 실패 후 재시작이 필요한 상태를 포함하여, 배치 메타데이터가 올바르게 유지되도록 하기 위한 것이다. 리포지터리 메서드가 트랜잭션이 아닌 경우 프레임워크의 동작이 잘 정의되지 않는다. `create*` 메서드 애트리뷰트의 격리 수준(isolation level)은 잡이 시작될 때, 두 프로세스가 동시에 동일한 잡을 시작하려고 시도하는 경우, 하나만 성공하도록 별도로 지정된다. 해당 방법의 기본 격리 수준은 `SERIALIZABLE`이며 매우 공격적이다. `READ_COMMITTED`는 일반적으로 똑같이 잘 작동한다. 두 프로세스가 충돌할 가능성이 없으면 `READ_UNCOMMITTED`가 좋다. 그러나 `create*` 메소드에 대한 호출은 매우 짧기 때문에 `SERIALIZED`는 데이터베이스 플랫폼이 지원하는 한 문제를 일으킬 가능성이 없다. 그러나 이 설정을 재정의(override)할 수 있다.

다음 예에서는 XML에서 격리 수준을 재정의하는 방법을 보여준다:

`XML 구성`
```
  <job-repository id="jobRepository" 
                  isolation-level-for-create="REPEATABLE_READ" />
```

다음 예에서는 자바에서 격리 수준을 재정의하는 방법을 보여준다:

`자바 구성`
```
  @Configuration
  @EnableBatchProcessing(isolationLevelForCreate = "ISOLATION_REPEATABLE_READ")
  public class MyJobConfiguration {
     // 잡 정의
  }
```

네임스페이스를 사용하지 않는 경우, AOP를 사용하여 리포지터리의 트랜잭션 동작도 구성해야 한다. 다음 예는 XML에서 리포지터리의 트랜잭션 동작을 구성하는 방법을 보여준다:

`XML 구성`
```
<aop:config>
      <aop:advisor
             pointcut="execution(* org.springframework.batch.core..*Repository+.*(..))
      <advice-ref="txAdvice" />
  </aop:config>
  <tx:advice id="txAdvice" transaction-manager="transactionManager">
      <tx:attributes>
          <tx:method name="*" />
      </tx:attributes>
  </tx:advice>
```

변경 사항이 거의 없이 앞의 프래그먼트를 거의 그대로 사용할 수 있다. 또한 적절한 네임스페이스를 선언하고, spring-tx 및 spring-aop(또는 스프링 전체)가 클래스 패스에 있는지 확인하자. 

다음 예는 자바에서 리포지터리의 트랜잭션 동작을 구성하는 방법을 보여준다:

`자바 구성`
```
  @Bean
  public TransactionProxyFactoryBean baseProxy() {
      TransactionProxyFactoryBean transactionProxyFactoryBean = new TransactionProxyFactoryBean();
      Properties transactionAttributes = new Properties();
      transactionAttributes.setProperty("*", "PROPAGATION_REQUIRED");
      transactionProxyFactoryBean.setTransactionAttributes(transactionAttributes);
      transactionProxyFactoryBean.setTarget(jobRepository());
      transactionProxyFactoryBean.setTransactionManager(transactionManager());
      return transactionProxyFactoryBean;
  }
```


### 4.3.2. Changing the Table Prefix
`잡리포지터리(JobRepository)`의 수정 가능한 다른 프로퍼티는 메타 데이터 테이블의 테이블 접두사이다. 기본적으로, 모두 `BATCH_.BATCH_JOB_EXECUTION`으로 시작되고 `BATCH_STEP_EXECUTION`는 두 가지 예가 있다. 그러나, 이 접두사를 수정해야 하는 이유가 있다. 스키마명을 테이블명 앞에 추가해야 하거나 동일한 스키마 내에서 둘 이상의 메타데이터 테이블 세트가 필요한 경우, 테이블 접두사를 변경해야 한다.

다음 예는 XML에서 테이블 접두사를 변경하는 방법을 보여준다:

`XML 구성`
```
  <job-repository id="jobRepository"
                  table-prefix="SYSTEM.TEST_" />
```

다음 예는 자바에서 테이블 접두사를 변경하는 방법을 보여준다:

`자바 구성`
```
  @Configuration
  @EnableBatchProcessing(tablePrefix = "SYSTEM.TEST_")
  public class MyJobConfiguration {
     // 잡 정의
  }
```

앞의 변경 사항을 감안할 때, 메타데이터 테이블에 대한 모든 쿼리는 `SYSTEM.TEST_.BATCH_JOB_EXECUTION` 접두사가 붙고 `SYSTEM.TEST_JOB_EXECUTION`이라고 한다.

{: .important}
>테이블 접두사만 구성할 수 있다. 테이블 및 열 이름은 변경이 불가능하다.


### 4.3.3. Non-standard Database Types in a Repository
지원되는 목록에 없는 데이터베이스 플랫폼을 사용하는 경우, SQL 변수가 비슷한 경우, 지원되는 타입 중 하나를 사용할 수 있다. 이렇게 하려면, 네임스페이스로 바로 가는 것 대신 `잡리포지터리팩토리빈(JobRepositoryFactoryBean)`을 사용하고 데이터베이스 타입이 가장 일치하는 것으로 설정할 수 있다.

다음 예제는 `잡리포지터리팩토리빈(JobRepositoryFactoryBean)`을 사용하여 XML에서 가장 일치하는 데이터베이스 타입으로 설정하는 방법을 보여준다:

`XML 구성`
```
  <bean id="jobRepository" class="org...JobRepositoryFactoryBean">
    <property name="databaseType" value="db2"/>
    <property name="dataSource" ref="dataSource"/>
  </bean>
```

다음 예제는 `잡리포지터리팩토리빈(JobRepositoryFactoryBean)`을 사용하여 자바에서 가장 일치하는 데이터베이스 타입으로 설정하는 방법을 보여준다:

`자바 구성`
```
@Bean
  public JobRepository jobRepository() throws Exception {
      JobRepositoryFactoryBean factory = new JobRepositoryFactoryBean();
      factory.setDataSource(dataSource);
      factory.setDatabaseType("db2");
      factory.setTransactionManager(transactionManager);
      return factory.getObject();
}
```

데이터베이스 타입이 지정되지 않은 경우,`잡리포지터리팩토리빈(JobRepositoryFactoryBean)`은 `데이터소스(DataSource)`에서 데이터베이스 타입을 자동 감지하려고 시도한다. 플랫폼 간 주요 차이점은 기본 키를 증가시키는 전략에 의해 설명되므로 `인크리먼터팩토리(incrementerFactory)`(스프링 프레임워크의 표준 구현 중 하나를 사용하여)도 재정의(override)해야 하는 경우가 많다.

그래도 작동하지 않거나 RDBMS를 사용하지 않는 경우, 유일한 옵션은 `심플잡리포지터리(SimpleJobRepository)`가 의존하는 다양한 Dao 인터페이스를 구현하여 일반적인 스프링 방식으로 수동 연결하는 것일 수 있다.


## 4.4. Configuring a JobLauncher
`@EnableBatchProcessing`을 사용하면, `잡리포지터리(JobRegistry)`가 제공된다. 이 장에서는 직접 구성하는 방법에 대해 설명한다.

`잡런처(JobLauncher)` 인터페이스(interface)의 가장 기본적인 구현(implementation)은 `태스크익스큐터잡런처(TaskExecutorJobLauncher)`이다. 유일한 필수 의존성은 `잡리포지터리(JobRegistry)`(실행하는 데 필요함)이다.

다음 예는 XML의 `태스크익스큐터잡런처(TaskExecutorJobLauncher)`를 보여준다:

`XML 구성`
```
  <bean id="jobLauncher"
        class="org.springframework.batch.core.launch.support.TaskExecutorJobLauncher">
      <property name="jobRepository" ref="jobRepository" />
  </bean>
```

다음 예제는 자바의 `태스크익스큐터잡런처(TaskExecutorJobLauncher)`를 보여준다:

`자바 구성`
```
  @Bean
  public JobLauncher jobLauncher() throws Exception {
      TaskExecutorJobLauncher jobLauncher = new TaskExecutorJobLauncher();
      jobLauncher.setJobRepository(jobRepository);
      jobLauncher.afterPropertiesSet();
      return jobLauncher;
  } ...
```

`잡익스큐션(JobExecution)`이 확보되면, 다음 이미지와 같이 `잡`의 실행 메소드로 전달되어, 궁극적으로 `잡익스큐션(JobExecution)`을 호출자(caller)에게 반환한다:
![잡 런처 순서](https://docs.spring.io/spring-batch/docs/current/reference/html/images/job-launcher-sequence-sync.png)
이미지 8. 잡 런처(Job Launcher) 시퀀스 다이어그램

시퀀스 다이어그램은 간단하며 스케줄러에서 시작할 때 잘 작동한다. 그러나, HTTP 요청을 시작하려고 할 때 문제가 발생한다. 이 시나리오에서는 `태스크익스큐터잡런처(TaskExecutorJobLauncher)`가 호출자에게 즉시 반환되도록 실행을 비동기적으로 수행해야 한다. 느린 실행 프로세스(예: 배치 잡)에 필요한 시간 동안 HTTP 요청을 열린 상태로 유지하는 것은 좋지 않기 때문이다. 다음 이미지는 예제 시퀀스 다이어그램를 보여준다:

![비동기 작업 실행 순서](https://docs.spring.io/spring-batch/docs/current/reference/html/images/job-launcher-sequence-sync.png)
이미지 9. 비동기 잡 실행 시퀀스 다이어그램

`태스크익스큐터(TaskExecutor)`를 구성하여 이 시나리오가 잘 작동하도록 `태스크익스큐터잡런처(TaskExecutorJobLauncher)`를 구성할 수 있다. 다음 XML 예제는 즉시 반환하도록 `태스크익스큐터잡런처(TaskExecutorJobLauncher)`를 구성한다:

`XML 구성`
```
  <bean id="jobLauncher"
        class="org.springframework.batch.core.launch.support.TaskExecutorJobLauncher">
    <property name="jobRepository" ref="jobRepository" />
    <property name="taskExecutor">
      <bean class="org.springframework.core.task.SimpleAsyncTaskExecutor" />
    </property>
  </bean>
```

다음 자바 예제는 즉시 반환(return)하도록 `태스크잡익스큐터잡런처(TaskExecutorJobLauncher)`를 구성한다:

`자바 구성`
```
  @Bean
  public JobLauncher jobLauncher() {
    TaskExecutorJobLauncher jobLauncher = new TaskExecutorJobLauncher();
    jobLauncher.setJobRepository(jobRepository());
    jobLauncher.setTaskExecutor(new SimpleAsyncTaskExecutor());
    jobLauncher.afterPropertiesSet();
    return jobLauncher;
  }
```

스프링 `태스크익스큐터(TaskExecutor)` 인터페이스의 모든 구현을 사용하여 잡이 비동기적으로 실행되는 방식을 제어할 수 있다.


## 4.5. Running a Job
최소한, 배치 잡을 시작하려면 시작할 잡과 잡런처(JobLauncher) 두 가지가 필요하다. 둘 다 동일한 컨텍스트(context) 또는 다른 컨텍스트 내에 포함될 수 있다. 예를 들어 커맨드에서 잡을 시작하면, 각 잡에 대해 새 JVM이 인스턴스화된다. 따라서, 모든 잡에는 자체 잡런처(JobLauncher)가 있다. 그러나, HttpRequest 범위 에 있는 웹 컨테이너 내에서 실행하는 경우 잡을 시작하기 위해 여러 요청이 호출하는 하나의 `잡런처(JobLauncher)`(비동기 잡 시작을 위해 구성)가 있다.