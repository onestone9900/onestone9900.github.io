---
layout: default
title:  Appendix B - Meta-Data Schema
parent: 5.0.2
grand_parent: SpringBatch
nav_order: 19
---


# Appendix B: Meta-Data Schema


## B.1. Overview
스프링 배치 메타데이터 테이블은 자바에서 이를 나타내는 도메인 객체와 밀접하다. 예를 들어 `잡인스턴스(JobInstance)`, `잡익스큐션(JobExecution)`, `잡파라미터(JobParameters)` 및 `스텝익스큐션(StepExecution)`은 각각 `BATCH_JOB_INSTANCE`, `BATCH_JOB_EXECUTION`, `BATCH_JOB_EXECUTION_PARAMS` 및 `BATCH_STEP_EXECUTION`에 매핑된다. `익스큐션컨텍스트(ExecutionContext)`는 `BATCH_JOB_EXECUTION_CONTEXT` 및 `BATCH_STEP_EXECUTION_CONTEXT`에 매핑된다.

`잡리포지터리(JobRepository)`는 각 자바 객체를 올바른 테이블에 저장하는 일을 담당한다. 이 부록에서는 메타데이터 테이블을 생성할 때 내린 여러 설계 결정과 함께 메타데이터 테이블을 자세히 설명한다. 이 부록 뒷부분에 설명된 다양한 테이블 생성 명령문(creation statements)을 볼 때 일반적으로 사용되는 데이터 타입이라는 점을 유의하자. 스프링 배치는 예제로 많은 스키마를 제공한다. 개별 데이터베이스 공급업체가 데이터를 처리하는 방식이 있기 때문에 다양한 데이터 타입이 있다. 다음 이미지는 6개 테이블의 ERD 모델과 테이블 간의 관계를 보여준다:

![Spring Batch Meta-Data ERD](https://docs.spring.io/spring-batch/docs/current/reference/html/images/meta-data-erd.png)
이미지 35. 스프링 배치 메타데이터 ERD


### B.1.1. Example DDL Scripts
스프링 배치 코어 JAR 파일에는 여러 데이터베이스 플랫폼에 대한 관계형 테이블을 생성하는 예제 스크립트가 포함되어 있다(이는, 잡 리포지터리 팩토리 빈 또는 동등한 네임스페이스에 의해 오토와이어드됨). 이런 스크립트는 그대로 사용하거나 원하는 대로 추가 인덱스(index) 및 제약 조건(constraint)을 사용하여 수정할 수 있다. 파일 이름은 `Schema-*.sql` 형식이다. 여기서 `*`는 대상 데이터베이스 플랫폼의 짧은 이름이다. 스크립트는 `org.springframework.batch.core` 패키지에 있다.


### B.1.2. Migration DDL Scripts
스프링 배치 버전을 업그레이드할 때 실행해야 하는 마이그레이션 DDL 스크립트를 제공한다. 이 스크립트는 `org/springframework/batch/core/migration` 아래의 코어 Jar 파일에서 찾을 수 있다. 마이그레이션 스크립트는 도입된 버전 번호에 해당하는 폴더로 구성된다:
• `2.2`: `2.2` 이전 버전에서 버전 `2.2`로 마이그레이션하는 데 필요한 스크립트가 포함되어 있다.
• `4.1`: `4.1` 이전 버전에서 `4.1` 버전으로 마이그레이션하는 데 필요한 스크립트가 포함되어 있다.


### B.1.3. Version
이 부록에서 설명하는 대부분의 데이터베이스 테이블에는 버전 컬럼이 포함되어 있다. 이 컬럼은 중요하다. 스프링 배치는 데이터베이스 업데이트를 처리할 때 낙관적 잠금 전략을 사용하기 때문이다. 이는 레코드가 "접촉"(업데이트)될 때마다 버전 컬럼의 값이 1씩 증가한다는 의미이다. 리포지터리가 값을 저장하기 위해 돌아갈 때, 버전 번호가 변경된 경우 동시 접근(concurrent)에 오류가 있음을 나타내는 `옵티미스틱락킹페일러익셉션(OptimisticLockingFailureException)`이 발생한다. 서로 다른 배치 잡이 서로 다른 시스템에서 실행되더라도, 모두 동일한 데이터베이스 테이블을 사용하므로 이것은 확인이 필요하다.


### B.1.4. Identity
`BATCH_JOB_INSTANCE`, `BATCH_JOB_EXECUTION` 및 `BATCH_STEP_EXECUTION`에는 각각 `_ID`로 끝나는 컬럼이 포함되어 있다. 이러한 필드는 해당 테이블의 프라이머리 키 역할을 한다. 그러나 데이터베이스의 생성 키는 아니다. 별도의 시퀀스로 생성된다. 이는 도메인 객체를 데이터베이스에 삽입한 후, 자바에서 고유하게 식별할 수 있도록 해당 객체에 제공된 키를 실제 객체에 설정해야 하기 때문에 필요하다. 최신 데이터베이스 드라이버(JDBC 3.0 이상)는 데이터베이스 생성 키를 사용하여 이 기능을 지원한다. 그러나, 해당 기능을 필요로하는 대신 시퀀스가 ​​사용된다. 스키마에는 다음 명령문의 일부 형태가 포함되어 있다:

```sql
    CREATE SEQUENCE BATCH_STEP_EXECUTION_SEQ;
    CREATE SEQUENCE BATCH_JOB_EXECUTION_SEQ;
    CREATE SEQUENCE BATCH_JOB_SEQ;
```

많은 데이터베이스 공급업체는 시퀀스를 지원하지 않는다. 이러한 경우 MySQL에 처럼 다음 명령문 같은 해결 방법이 있다:

```sql
    CREATE TABLE BATCH_STEP_EXECUTION_SEQ (ID BIGINT NOT NULL) type=InnoDB;
    INSERT INTO BATCH_STEP_EXECUTION_SEQ values(0);
    CREATE TABLE BATCH_JOB_EXECUTION_SEQ (ID BIGINT NOT NULL) type=InnoDB;
    INSERT INTO BATCH_JOB_EXECUTION_SEQ values(0);
    CREATE TABLE BATCH_JOB_SEQ (ID BIGINT NOT NULL) type=InnoDB;
    INSERT INTO BATCH_JOB_SEQ values(0);
```

위 경우에는, 각 시퀀스 대신 테이블이 사용된다. 스프링 코어 클래스인 `MySQL맥스벨류인크리먼터(MySQLMaxValueIncrementer)`는 비슷한 기능을 제공하기 위해, 이 시퀀스에서 하나의 컬럼을 증가시킨다.


## B.2. The `BATCH_JOB_INSTANCE` Table
`BATCH_JOB_INSTANCE` 테이블은 `잡인스턴스(JobInstance)`와 관련된 모든 정보를 보유하고 전체 계층 구조의 최상위이다. 이를 생성하는 데 다음 일반 DDL 문이 사용된다:

```sql
    CREATE TABLE BATCH_JOB_INSTANCE  (
        JOB_INSTANCE_ID BIGINT  PRIMARY KEY ,
        VERSION BIGINT,
        JOB_NAME VARCHAR(100) NOT NULL ,
        JOB_KEY VARCHAR(32) NOT NULL
    );
```

다음 리스트는 테이블의 각 컬럼을 설명한다:
• `JOB_INSTANCE_ID`: 인스턴스를 식별하는 고유 ID이다. 프라이머리 키다. 이 컬럼의 값은 `잡인스턴스(JobInstance)`에서 `getId` 메소드를 호출하여 얻을 수 있어야 한다.
• `VERSION`: [버전]()을 보자.
• `JOB_NAME`: 잡(Job) 객체에서 얻은 잡명이다. 인스턴스를 식별하는 데 필요하므로 not null이어야 한다.
• `JOB_KEY`: 동일 잡의 개별 인스턴스를 서로 고유하게 식별하는 잡파라미터(JobParametes)의 직렬화이다 (동일한 작업 이름을 가진 `잡인스턴스(JobInstances)`는 `잡파라미터(JobParameters)`가 달라야 하므로 `JOB_KEY` 값도 달라야 한다.)
 
