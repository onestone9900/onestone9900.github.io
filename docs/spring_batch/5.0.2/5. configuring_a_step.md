---
layout: default
title: 5. Configuring a Step
parent: 5.0.2
grand_parent: SpringBatch
nav_order: 4
---


# 5. Configuring a Step
[도메인 장](https://onestone9900.github.io/docs/spring_batch/5.0.2/3.%20domain_language_of_batch/#3-the-domain-language-of-batch)에서 설명한 것처럼, `스텝(Step)`은 배치 잡의 독립적이고 순차적인 단계를 캡슐화하며 실제 배치 처리를 정의하고 제어하는 ​​데 필요한 모든 정보를 가지고 있는 도메인 객체이다. 주어진 스텝의 내용은 `잡`을 작성하는 개발자의 재량에 따르기 때문에 이것은 애매한 설명이 된다. `스텝`은 개발자의 노력에 따라 간단하거나 복잡할 수 있다. 간단한 `스텝`은 파일에서 데이터베이스로 데이터를 로드할 수 있으며, 코드가 거의 또는 전혀(사용된 구현에 따라 다름) 필요하지 않다. 복잡한 `스텝`은 다음 이미지와 같이, 처리의 일부로 복잡한 비즈니스 규칙이 있을 수 있다:

![스텝](https://docs.spring.io/spring-batch/docs/current/reference/html/images/step.png)

이미지 13. 스텝(Step)


## 5.1. Chunk-oriented Processing
일반적으로 스프링 배치는 구현체에서 "청크 지향" 스타일을 사용한다. 데이터를 한 번에 읽어 트랜잭션 경계 내에서 '청크' 단위를 생성하는 것을 청크 지향 처리라 말한다. 읽은 항목 수가 커밋 인터벌(commit interval)과 같으면, 전체 청크가 `아아템라이터(ItemWriter)`에 의해 기록된 다음 트랜잭션이 커밋된다. 다음 이미지는 해당 프로세스를 보여준다:

![청크 지향 처리](https://docs.spring.io/spring-batch/docs/current/reference/html/images/chunk-oriented-processing.png)

이미지 14. 청크 지향 처리

다음 의사 코드는 동일한 개념을 단순화된 형태로 보여준다:
```
  List items = new Arraylist();
  for(int i = 0; i < commitInterval; i++){
      Object item = itemReader.read();
      if (item != null) {
          items.add(item);
      }
  }
  itemWriter.write(items);
```

항목을 `아이템라이터(ItemWriter)`에 전달하기 전에 항목을 처리하기 위해 옵셔널로 `아이템프로세서(ItemProcessor)`를 사용하여 청크 지향 스텝를 구성할 수도 있다. 다음 이미지는 스텝에 `아이템프로세서(ItemProcessor)`를 등록한 경우의 프로세스를 보여준다:

![](https://docs.spring.io/spring-batch/docs/current/reference/html/images/chunk-oriented-processing-with-item-processor.png)

이미지 15. 아이템프로세서(ItemProcessor)와 청크 지향 처리

다음 의사 코드는 단순한 형식으로 구현되는 방법을 보여준다:

```
  List items = new Arraylist();
  for(int i = 0; i < commitInterval; i++){
      Object item = itemReader.read();
      if (item != null) {
          items.add(item);
      }
  }
  List processedItems = new Arraylist();
  for(Object item: items){
      Object processedItem = itemProcessor.process(item);
      if (processedItem != null) {
          processedItems.add(processedItem);
      }
  }
  itemWriter.write(processedItems);
```

아이템 프로세서(item processor) 및 해당 사용 사례에 대한 자세한 내용은, 아이템 처리(processing) 절을 참고하자.


### 5.1.1. Configuring a Step
상대적으로 스텝의 필수 의존성은 적지만, 잠재적으로 많은 협력자을 포함할 수도 있는 매우 복잡한 클래스이다.

쉬운 구성을 위해, 다음 예제와 같이, 스프링 배치 XML 네임스페이스를 사용할 수 있다:

`XML 구성`
```
  <job id="sampleJob" job-repository="jobRepository">
    <step id="step1">
      <tasklet transaction-manager="transactionManager">
        <chunk reader="itemReader" writer="itemWriter" commit-interval="10"/>
      </tasklet>
    </step>
  </job>

```

자바 구성을 사용하는 경우, 다음 예제와 같이, 스프링 배치 빌더를 사용할 수 있다:

`자바 구성`
```
  /**
   * 잡리포지터리(JobRepository)는 일반적으로 오토와이어드(autowired)되며 명시적으로 구성할 필요는 없다.
   */
  @Bean
  public Job sampleJob(JobRepository jobRepository, Step sampleStep) {
    return new JobBuilder("sampleJob", jobRepository)
            .start(sampleStep)
            .build();
  }

  /**
   * 트랜젝션매니저(TransactionManager)는 일반적으로 자동 연결되며 명시적으로 구성할 필요는 없다.
   */
  @Bean
  public Step sampleStep(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      return new StepBuilder("sampleStep", jobRepository)
                .<String, String>chunk(10, transactionManager)
                .reader(itemReader())
                .writer(itemWriter())
                .build();
  }
```

항목 지향 스텝(item-oriented step)를 만드는 데 필요한 유일한 의존성은 다음과 같다:

- `리더(reader)`: 처리할 항목을 제공하는 `아이템리더(ItemReader)`.
- `라이터(writer)`: `아이템리더(ItemReader)`가 제공한 항목을 처리하는 `아이템라이터(ItemWriter)`. 
- `트랜젝션-매니저(transaction-manager)` (XML)/`트랜젝션매니저(transactionManager)` (자바): 처리 중에 트랜잭션을 시작하고 커밋하는 스프링의 `플랫폼트랜젝션매니저(PlatformTransactionManager)`.
- `잡-리포지터리(job-repository)` (XML)/`리포지터리(repository)` (Java): 처리 중(커밋 직전) `스텝익스큐션(StepExecution)` 및 `익스큐션컨텍스트(ExecutionContext)`를 주기적으로 저장하는 `잡리포지터리(JobRepository)`. XML에서, 인라인 <step/>(<job/> 내에 정의된 것)의 경우, <job/> 엘리먼트의 애트리뷰트이다. 독립형(standalone) 스텝의 경우 <tasklet/>의 애트리뷰트로 정의된다.
- `커밋-인터벌(commit-interval)` (XML)/`청크(chunk)` (Java): 트랜잭션 커밋 전에 처리할 아이템의 수이다.

`잡-리포지터리(job-repository)`(XML)/`리포지터리(repository)`(Java)의 기본값은 `잡리포지터리(jobRepository)`이고 `트랜젝션-매니저(transaction-manager)`(XML)/`트랜젝션매니저(transactionManager)`(Java)의 기본값은 `트랜젝션매니저(transactionManager)`이다. 또한, `아이템프로세서(ItemProcessor)`는 아이템이 `리더(reader)`에서 `라이터(writer)`로 직접 전달될 수 있으므로, 선택 사항이다.


### 5.1.2. Inheriting from a Parent Step
`스텝` 그룹이 유사한 구성을 공유하는 경우, 구체적인 스텝이 프로퍼티를 상속할 수 있는 "상위" `스텝`을 정의하는 것이 도움이 될 수 있다. 자바의 클래스 상속과 유사하게, "하위" `스텝`은 해당 엘리먼트와 애트리뷰트를 상위 `스텝`과 결합한다. 하위 `스텝`은 또한 상위 스텝의 모든 것을 재정의(override)한다.

다음 예에서, `스텝`, `콘크리트스텝1(concreteStep1)`은 `페어런트스텝(parentStep)`에서 상속한다. `아이템리더(itemReader)`, `아이템프로세서(itemProcessor)`, `아이템라이터(itemWriter)`, `startLimit=5` 및 `allowStartIfComplete=true`로 인스턴스화된다. 또한, `커밋인터벌(commitInterval)`은 다음 예제와 같이 `콘크리트스텝1(concreteStep1)` 스텝에 의해 재정의(override)되므로 5이다:

```
  <step id="parentStep">
    <tasklet allow-start-if-complete="true">
      <chunk reader="itemReader" writer="itemWriter" commit-interval="10"/>
    </tasklet>
  </step>

  <step id="concreteStep1" parent="parentStep">
    <tasklet start-limit="5">
      <chunk processor="itemProcessor" commit-interval="5"/>
    </tasklet>
  </step>
```

`id` 애트리뷰트는은 잡 엘리먼트 내의 스텝에서 계속 필요하다. 이것은 두 가지 이유 때문이다:
- id는 `스텝익스큐션(StepExecution)`을 유지할 때 스텝 이름으로 사용된다. 동일한 독립 실행형(standalone) 스텝이 잡에서 두 번 이상 참조되면, 오류가 발생한다.
- 잡 플로우를 만들 때, 이 장의 뒷부분에서 설명하는 대로, 다음 애트리뷰트는 독립 실행형 스텝이 아니라, 플로우에서 스텝을 참조해야 한다.

#### Abstract `Step`
경우에 따라, 완전하게 구성되지 않은 상위 `스텝`을 정의해야 할 수도 있다. 예를 들어 `리더(reader)`, `라이터(writer)` 및 `tasklet` 애트리뷰트가 스텝 구성에서 제외되면 초기화에 실패한다. 이러한 애트리뷰트가 하나 이상 없는 상위 스텝을 정의해야 하는 경우, `앱스트랙트(Abstract)` 애트리뷰트를 사용해야 한다. `앱스트랙트 스텝`은 상속(extend)만 가능하며 인스턴스화(instantiated)되지 않는다.

다음 예제에서, `스텝`(`abstractParentStep`)는 앱스트랙트(abstract)로 선언되지 않은 경우 인스턴스화되지 않는다.
`스텝`, `콘트리트스텝2`(`concreteStep2`)는 `아이템리더(itemReader)`, `아이템라이터(itemWriter)` 그리고 `commit-interval=10`를 가진다.

```
  <step id="abstractParentStep" abstract="true">
    <tasklet>
      <chunk commit-interval="10"/>
    </tasklet>
  </step>

  <step id="concreteStep2" parent="abstractParentStep">
    <tasklet>
      <chunk reader="itemReader" writer="itemWriter"/>
    </tasklet>
  </step>
```

#### Merging Lists
`스텝`에서 구성 가능한 일부 엘리먼트는 `<listeners/>` 엘리먼트 같이 리스트이다. 상위 스텝과 하위 `스텝` 모두 `<listeners/>` 엘리먼트를 선언하면 하위 스텝의 리스트가 상위 스텝의 리스트를 재정의한다. 하위 스텝에 상위 스텝의 리스트에 리스너를 추가할 수 있도록 모든 리스트 엘리먼트에는 `머지(merge)` 애트리뷰트가 있다. 엘리먼트에 `merge="true"`를 지정하면, 하위 리스트가 재정의하는 대신 상위 리스트와 결합된다.

다음 예에서 "concreteStep3" `스텝`은 `listenerOne` 및 `listenerTwo`라는 두 개의 리스너로 생성된다:

```
  <step id="listenersParentStep" abstract="true">
    <listeners>
      <listener ref="listenerOne"/>
    <listeners>
  </step>

  <step id="concreteStep3" parent="listenersParentStep">
    <tasklet>
      <chunk reader="itemReader" writer="itemWriter" commit-interval="5"/>
    </tasklet>
    <listeners merge="true">
      <listener ref="listenerTwo"/>
    <listeners>
  </step>
```


### 5.1.3. The Commit Interval
앞에서 언급했듯이, 스텝은 아이템을 읽고 쓰고, 제공된 `플랫폼스랜젝션매니저(PlatformTransactionManager)`를 사용하여 주기적으로 커밋한다. `커밋 인터벌(commit interval)`이 1이면, 각각의 아이템을 작성한 후 커밋한다. 트랜잭션을 시작하고 커밋하는 데는 비용이 많이 들기 때문에, 이는 대부분 상황에서 이상적이지 않다. 이상적으로, 각 트랜잭션에서 가능한 한 많은 항목을 처리하는 것이 바람직하며, 이는 처리 중인 데이터 타입과 스텝이 상호 작용하는 리소스에 따라 완전히 달라진다. 이러한 이유로, 커밋 내에서 처리되는 아이템 수를 적절히 구성해야 한다.

다음 예는 XML에 정의된 것처럼 `tasklet`의 `커밋 인터벌` 값이 10인 `스텝`을 보여준다:

`XML 구성`
```
  <job id="sampleJob">
    <step id="step1">
      <tasklet>
        <chunk reader="itemReader" writer="itemWriter" commit-interval="10"/>
      </tasklet>
    </step>
  </job>
```

다음 예는 `tasklet`이 자바에서 정의된 대로 `커밋 인터벌` 값이 10인 `스텝`를 보여준다:

`자바 구성`
```
  @Bean
  public Job sampleJob(JobRepository jobRepository) {
      return new JobBuilder("sampleJob", jobRepository)
                .start(step1())
                .build();
  }

  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      return new StepBuilder("step1", jobRepository)
                  .<String, String>chunk(10, transactionManager)
                  .reader(itemReader())
                  .writer(itemWriter())
                  .build();
  }
```

앞의 예에서는, 각 트랜잭션 내에서 10개의 아이템이 처리된다. 처리 초기에, 트랜잭션이 시작된다. 또한 `아이템리더(ItemReader)`에서 `read`가 호출될 때마다 카운터가 증가한다. 10에 도달하면, 집계된 아이템 리스트가 `아이템라이터(ItemWriter)`로 전달되고 트랜잭션이 커밋된다.