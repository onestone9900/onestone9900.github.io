---
layout: default
title: 5. Configuring a Step
parent: 5.0.2
grand_parent: SpringBatch
nav_order: 4
---


# 5. Configuring a Step
[도메인 장](https://onestone9900.github.io/docs/spring_batch/5.0.2/3.%20domain_language_of_batch/#3-the-domain-language-of-batch)에서 설명한 것처럼, `스텝(Step)`은 배치 잡의 독립적이고 순차적인 단계를 캡슐화하며 실제 배치 처리를 정의하고 제어하는 ​​데 필요한 모든 정보를 가지고 있는 도메인 객체이다. 주어진 스텝의 내용은 `잡`을 작성하는 개발자의 재량에 따르기 때문에 이것은 애매한 설명이 된다. `스텝`은 개발자의 노력에 따라 간단하거나 복잡할 수 있다. 간단한 `스텝`은 파일에서 데이터베이스로 데이터를 로드할 수 있으며, 코드가 거의 또는 전혀(사용된 구현에 따라 다름) 필요하지 않다. 복잡한 `스텝`은 다음 이미지와 같이, 처리의 일부로 복잡한 비즈니스 규칙이 있을 수 있다:

![스텝](https://docs.spring.io/spring-batch/docs/current/reference/html/images/step.png)

이미지 13. 스텝(Step)


## 5.1. Chunk-oriented Processing
일반적으로 스프링 배치는 구현체에서 "청크 지향" 스타일을 사용한다. 데이터를 한 번에 읽어 트랜잭션 경계 내에서 '청크' 단위를 생성하는 것을 청크 지향 처리라 말한다. 읽은 항목 수가 커밋 인터벌(commit interval)과 같으면, 전체 청크가 `아아템라이터(ItemWriter)`에 의해 기록된 다음 트랜잭션이 커밋된다. 다음 이미지는 해당 프로세스를 보여준다:

![청크 지향 처리](https://docs.spring.io/spring-batch/docs/current/reference/html/images/chunk-oriented-processing.png)

이미지 14. 청크 지향 처리

다음 의사 코드는 동일한 개념을 단순화된 형태로 보여준다:
```
  List items = new Arraylist();
  for(int i = 0; i < commitInterval; i++){
      Object item = itemReader.read();
      if (item != null) {
          items.add(item);
      }
  }
  itemWriter.write(items);
```

항목을 `아이템라이터(ItemWriter)`에 전달하기 전에 항목을 처리하기 위해 옵셔널로 `아이템프로세서(ItemProcessor)`를 사용하여 청크 지향 스텝를 구성할 수도 있다. 다음 이미지는 스텝에 `아이템프로세서(ItemProcessor)`를 등록한 경우의 프로세스를 보여준다:

![](https://docs.spring.io/spring-batch/docs/current/reference/html/images/chunk-oriented-processing-with-item-processor.png)

이미지 15. 아이템프로세서(ItemProcessor)와 청크 지향 처리

다음 의사 코드는 단순한 형식으로 구현되는 방법을 보여준다:

```
  List items = new Arraylist();
  for(int i = 0; i < commitInterval; i++){
      Object item = itemReader.read();
      if (item != null) {
          items.add(item);
      }
  }
  List processedItems = new Arraylist();
  for(Object item: items){
      Object processedItem = itemProcessor.process(item);
      if (processedItem != null) {
          processedItems.add(processedItem);
      }
  }
  itemWriter.write(processedItems);
```

아이템 프로세서(item processor) 및 해당 사용 사례에 대한 자세한 내용은, 아이템 처리(processing) 절을 참고하자.


### 5.1.1. Configuring a Step
상대적으로 스텝의 필수 의존성은 적지만, 잠재적으로 많은 협력자을 포함할 수도 있는 매우 복잡한 클래스이다.

쉬운 구성을 위해, 다음 예제와 같이, 스프링 배치 XML 네임스페이스를 사용할 수 있다:

`XML 구성`
```
  <job id="sampleJob" job-repository="jobRepository">
    <step id="step1">
      <tasklet transaction-manager="transactionManager">
        <chunk reader="itemReader" writer="itemWriter" commit-interval="10"/>
      </tasklet>
    </step>
  </job>

```

자바 구성을 사용하는 경우, 다음 예제와 같이, 스프링 배치 빌더를 사용할 수 있다:

`자바 구성`
```
  /**
   * 잡리포지터리(JobRepository)는 일반적으로 오토와이어드(autowired)되며 명시적으로 구성할 필요는 없다.
   */
  @Bean
  public Job sampleJob(JobRepository jobRepository, Step sampleStep) {
    return new JobBuilder("sampleJob", jobRepository)
            .start(sampleStep)
            .build();
  }

  /**
   * 트랜젝션매니저(TransactionManager)는 일반적으로 자동 연결되며 명시적으로 구성할 필요는 없다.
   */
  @Bean
  public Step sampleStep(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      return new StepBuilder("sampleStep", jobRepository)
                .<String, String>chunk(10, transactionManager)
                .reader(itemReader())
                .writer(itemWriter())
                .build();
  }
```

항목 지향 스텝(item-oriented step)를 만드는 데 필요한 유일한 의존성은 다음과 같다:

- `리더(reader)`: 처리할 항목을 제공하는 `아이템리더(ItemReader)`.
- `라이터(writer)`: `아이템리더(ItemReader)`가 제공한 항목을 처리하는 `아이템라이터(ItemWriter)`. 
- `트랜젝션-매니저(transaction-manager)` (XML)/`트랜젝션매니저(transactionManager)` (자바): 처리 중에 트랜잭션을 시작하고 커밋하는 스프링의 `플랫폼트랜젝션매니저(PlatformTransactionManager)`.
- `잡-리포지터리(job-repository)` (XML)/`리포지터리(repository)` (Java): 처리 중(커밋 직전) `스텝익스큐션(StepExecution)` 및 `익스큐션컨텍스트(ExecutionContext)`를 주기적으로 저장하는 `잡리포지터리(JobRepository)`. XML에서, 인라인 <step/>(<job/> 내에 정의된 것)의 경우, <job/> 엘리먼트의 애트리뷰트이다. 독립형(standalone) 스텝의 경우 <tasklet/>의 애트리뷰트로 정의된다.
- `커밋-인터벌(commit-interval)` (XML)/`청크(chunk)` (Java): 트랜잭션 커밋 전에 처리할 아이템의 수이다.

`잡-리포지터리(job-repository)`(XML)/`리포지터리(repository)`(Java)의 기본값은 `잡리포지터리(jobRepository)`이고 `트랜젝션-매니저(transaction-manager)`(XML)/`트랜젝션매니저(transactionManager)`(Java)의 기본값은 `트랜젝션매니저(transactionManager)`이다. 또한, `아이템프로세서(ItemProcessor)`는 아이템이 `리더(reader)`에서 `라이터(writer)`로 직접 전달될 수 있으므로, 선택 사항이다.


### 5.1.2. Inheriting from a Parent Step
`스텝` 그룹이 유사한 구성을 공유하는 경우, 구체적인 스텝이 프로퍼티를 상속할 수 있는 "상위" `스텝`을 정의하는 것이 도움이 될 수 있다. 자바의 클래스 상속과 유사하게, "하위" `스텝`은 해당 엘리먼트와 애트리뷰트를 상위 `스텝`과 결합한다. 하위 `스텝`은 또한 상위 스텝의 모든 것을 재정의(override)한다.

다음 예에서, `스텝`, `콘크리트스텝1(concreteStep1)`은 `페어런트스텝(parentStep)`에서 상속한다. `아이템리더(itemReader)`, `아이템프로세서(itemProcessor)`, `아이템라이터(itemWriter)`, `startLimit=5` 및 `allowStartIfComplete=true`로 인스턴스화된다. 또한, `커밋인터벌(commitInterval)`은 다음 예제와 같이 `콘크리트스텝1(concreteStep1)` 스텝에 의해 재정의(override)되므로 5이다:

```
  <step id="parentStep">
    <tasklet allow-start-if-complete="true">
      <chunk reader="itemReader" writer="itemWriter" commit-interval="10"/>
    </tasklet>
  </step>

  <step id="concreteStep1" parent="parentStep">
    <tasklet start-limit="5">
      <chunk processor="itemProcessor" commit-interval="5"/>
    </tasklet>
  </step>
```

`id` 애트리뷰트는은 잡 엘리먼트 내의 스텝에서 계속 필요하다. 이것은 두 가지 이유 때문이다:
- id는 `스텝익스큐션(StepExecution)`을 유지할 때 스텝 이름으로 사용된다. 동일한 독립 실행형(standalone) 스텝이 잡에서 두 번 이상 참조되면, 오류가 발생한다.
- 잡 플로우를 만들 때, 이 장의 뒷부분에서 설명하는 대로, 다음 애트리뷰트는 독립 실행형 스텝이 아니라, 플로우에서 스텝을 참조해야 한다.

#### Abstract `Step`
경우에 따라, 완전하게 구성되지 않은 상위 `스텝`을 정의해야 할 수도 있다. 예를 들어 `리더(reader)`, `라이터(writer)` 및 `tasklet` 애트리뷰트가 스텝 구성에서 제외되면 초기화에 실패한다. 이러한 애트리뷰트가 하나 이상 없는 상위 스텝을 정의해야 하는 경우, `앱스트랙트(Abstract)` 애트리뷰트를 사용해야 한다. `앱스트랙트 스텝`은 상속(extend)만 가능하며 인스턴스화(instantiated)되지 않는다.

다음 예제에서, `스텝`(`abstractParentStep`)는 앱스트랙트(abstract)로 선언되지 않은 경우 인스턴스화되지 않는다.
`스텝`, `콘트리트스텝2`(`concreteStep2`)는 `아이템리더(itemReader)`, `아이템라이터(itemWriter)` 그리고 `commit-interval=10`를 가진다.

```
  <step id="abstractParentStep" abstract="true">
    <tasklet>
      <chunk commit-interval="10"/>
    </tasklet>
  </step>

  <step id="concreteStep2" parent="abstractParentStep">
    <tasklet>
      <chunk reader="itemReader" writer="itemWriter"/>
    </tasklet>
  </step>
```

#### Merging Lists
`스텝`에서 구성 가능한 일부 엘리먼트는 `<listeners/>` 엘리먼트 같이 리스트이다. 상위 스텝과 하위 `스텝` 모두 `<listeners/>` 엘리먼트를 선언하면 하위 스텝의 리스트가 상위 스텝의 리스트를 재정의한다. 하위 스텝에 상위 스텝의 리스트에 리스너를 추가할 수 있도록 모든 리스트 엘리먼트에는 `머지(merge)` 애트리뷰트가 있다. 엘리먼트에 `merge="true"`를 지정하면, 하위 리스트가 재정의하는 대신 상위 리스트와 결합된다.

다음 예에서 "concreteStep3" `스텝`은 `listenerOne` 및 `listenerTwo`라는 두 개의 리스너로 생성된다:

```
  <step id="listenersParentStep" abstract="true">
    <listeners>
      <listener ref="listenerOne"/>
    <listeners>
  </step>

  <step id="concreteStep3" parent="listenersParentStep">
    <tasklet>
      <chunk reader="itemReader" writer="itemWriter" commit-interval="5"/>
    </tasklet>
    <listeners merge="true">
      <listener ref="listenerTwo"/>
    <listeners>
  </step>
```


### 5.1.3. The Commit Interval
앞에서 언급했듯이, 스텝은 아이템을 읽고 쓰고, 제공된 `플랫폼스랜젝션매니저(PlatformTransactionManager)`를 사용하여 주기적으로 커밋한다. `커밋 인터벌(commit interval)`이 1이면, 각각의 아이템을 작성한 후 커밋한다. 트랜잭션을 시작하고 커밋하는 데는 비용이 많이 들기 때문에, 이는 대부분 상황에서 이상적이지 않다. 이상적으로, 각 트랜잭션에서 가능한 한 많은 항목을 처리하는 것이 바람직하며, 이는 처리 중인 데이터 타입과 스텝이 상호 작용하는 리소스에 따라 완전히 달라진다. 이러한 이유로, 커밋 내에서 처리되는 아이템 수를 적절히 구성해야 한다.

다음 예는 XML에 정의된 것처럼 `tasklet`의 `커밋 인터벌` 값이 10인 `스텝`을 보여준다:

`XML 구성`
```
  <job id="sampleJob">
    <step id="step1">
      <tasklet>
        <chunk reader="itemReader" writer="itemWriter" commit-interval="10"/>
      </tasklet>
    </step>
  </job>
```

다음 예는 `tasklet`이 자바에서 정의된 대로 `커밋 인터벌` 값이 10인 `스텝`를 보여준다:

`자바 구성`
```
  @Bean
  public Job sampleJob(JobRepository jobRepository) {
      return new JobBuilder("sampleJob", jobRepository)
                .start(step1())
                .build();
  }

  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      return new StepBuilder("step1", jobRepository)
                  .<String, String>chunk(10, transactionManager)
                  .reader(itemReader())
                  .writer(itemWriter())
                  .build();
  }
```

앞의 예에서는, 각 트랜잭션 내에서 10개의 아이템이 처리된다. 처리 초기에, 트랜잭션이 시작된다. 또한 `아이템리더(ItemReader)`에서 `read`가 호출될 때마다 카운터가 증가한다. 10에 도달하면, 집계된 아이템 리스트가 `아이템라이터(ItemWriter)`로 전달되고 트랜잭션이 커밋된다.

### 5.1.4. Configuring a Step for Restart
["잡 구성 및 실행"](https://onestone9900.github.io/docs/spring_batch/5.0.2/4.%20configuring_and_running_a_job/#4-configuring-and-running-a-job) 장에서, 잡 재시작에 대해 설명했다. 재시작은 스텝에 많은 영향을 미치므로, 일부 특정 구성이 필요할 수 있다.


#### Setting a Start Limit
스텝이 시작될 수 있는 횟수를 제어하려는 많은 시나리오가 있다. 예를 들어, 재실행하기 전에 수동으로 일부 리소스를 수정해야 하는 일부 `스텝` 때문에 한 번만 실행되도록 구성해야 할 수 있다. `스텝`마다 요구 사항이 다를 수 있으므로, `스텝` 레벨에서 구성할 수 있다. 한 번만 실행할 수 있는 `스텝`은 무한히 실행할 수 있는 `스텝`과 동일한 `잡`의 일부로 존재할 수 있다.


다음 코드 조각은 XML에서 시작 제한 구성의 예를 보여준다:

`XML 구성`
```
  <step id="step1">
    <tasklet start-limit="1">
      <chunk reader="itemReader" writer="itemWriter" commit-interval="10"/>
    </tasklet>
  </step>
```

다음 코드 조각은 자바의 시작 제한 구성 예를 보여준다:

`자바 구성`
```
  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      return new StepBuilder("step1", jobRepository)
                  .<String, String>chunk(10, transactionManager)
                  .reader(itemReader())
                  .writer(itemWriter())
                  .startLimit(1)
                  .build();
  }
```

이전 예제의 스텝은 한 번만 실행할 수 있다. 재실행하려고 하면 `스타트리미트익시드익셉션(StartLimitExceededException)`이 발생한다. 시작 제한의 기본값은 `Integer.MAX_VALUE`이다.

#### Restarting a Completed `Step`
재시작 가능한 잡의 경우, 처음 성공 여부에 관계없이, 항상 실행해야 하는 하나 이상의 스텝이 있을 수 있다. 유효성 검사 스텝 또는 처리 전에 리소스를 정리하는 `스텝`를 예로 들 수 있다. 다시 시작된 잡의 정상적인 처리 중에 상태가 COMPLETED(이미 성공적으로 완료되었음을 의미)인 모든 스텝은 건너뛴다. `allow-start-if-complete`를 `true`로 설정하면 스텝이 항상 실행되도록 이를 재정의한다.

다음 코드 조각은 XML에서 재시작 가능한 잡을 정의하는 방법을 보여준다:

`XML 구성`
```
  <step id="step1">
    <tasklet allow-start-if-complete="true">
      <chunk reader="itemReader" writer="itemWriter" commit-interval="10"/>
    </tasklet>
  </step>
```

다음 코드 조각은 자바에서 재시작 가능한 잡을 정의하는 방법을 보여준다:

`자바 구성`
```
  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      return new StepBuilder("step1", jobRepository)
                  .<String, String>chunk(10, transactionManager)
                  .reader(itemReader())
                  .writer(itemWriter())
                  .allowStartIfComplete(true)
                  .build();
  }
```

#### Step Restart Configuration Example
다음 XML 예제는 재시작할 수 있는 스텝를 갖도록 잡을 구성하는 방법을 보여준다:

`XML 구성`
```
  <job id="footballJob" restartable="true">
    <step id="playerload" next="gameLoad">
      <tasklet>
        <chunk reader="playerFileItemReader" writer="playerWriter" commit-interval="10" />
      </tasklet>
    </step>
    <step id="gameLoad" next="playerSummarization">
      <tasklet allow-start-if-complete="true">
        <chunk reader="gameFileItemReader" writer="gameWriter" commit-interval="10"/>
      </tasklet>
    </step>
    <step id="playerSummarization">
      <tasklet start-limit="2">
        <chunk reader="playerSummarizationSource" writer="summaryWriter" commit-interval="10"/>
      </tasklet>
    </step>
  </job>
```

다음 자바 예제는 재시작할 수 있는 스텝를 갖도록 잡을 구성하는 방법을 보여준다:

`자바 구성`
```
  @Bean
  public Job footballJob(JobRepository jobRepository) {
    return new JobBuilder("footballJob", jobRepository)
              .start(playerLoad())
              .next(gameLoad())
              .next(playerSummarization())
              .build();
  }

  @Bean
  public Step playerLoad(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
    return new StepBuilder("playerLoad", jobRepository)
            .<String, String>chunk(10, transactionManager)
            .reader(playerFileItemReader())
            .writer(playerWriter())
            .build();
  }
  
  @Bean
  public Step gameLoad(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
    return new StepBuilder("gameLoad", jobRepository)
            .allowStartIfComplete(true)
            .<String, String>chunk(10, transactionManager)
            .reader(gameFileItemReader())
            .writer(gameWriter())
            .build();
  }

  @Bean
  public Step playerSummarization(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      return new StepBuilder("playerSummarization", jobRepository)
              .startLimit(2)
              .<String, String>chunk(10, transactionManager)
              .reader(playerSummarizationSource())
              .writer(summaryWriter())
              .build();
  }
```
 
앞의 예제는 축구 경기에 대한 정보를 로드하고 요약하는 잡에 대한 것이다. 여기에는 `playerLoad`, `gameLoad` 및 `playerSummarization`의 세가지 스텝이 포함된다. `playerLoad` 스텝은 플랫 파일에서 플레이어 정보를 로드하는 반면, `gameLoad` 스텝은 게임에 대해 동일한 작업을 수행한다. 마지막 단계인 `playerSummarization`은 제공된 게임을 기반으로 각 플레이어에 대한 통계를 요약한다. 파일은 `playerLoad`에 의해 한 번만 로드되어야 하지만 `gameLoad`는 특정 디렉터리 내에서 발견된 모든 게임파일을 로드할 수 있으며, 데이터베이스에 성공적으로 로드된 후에 삭제할 수 있다고 가정한다. 결과적으로 `playerLoad` 스텝에는 추가 구성이 포함되지 않는다. 완료되어도 여러 번 시작할 수 있다. 그러나, `gameLoad` 스텝은 마지막 실행 이후 파일이 추가되면 매번 실행해야 한다. `allow-start-if-complete`가 항상 시작되도록 `true`로 설정되어 있다. (요약 스텝에서 새 게임을 제대로 찾을 수 있도록 게임이 로드되는 데이터베이스 테이블에 프로세스 표시기(indicator)가 있다고 가정한다.) 잡에서 가장 중요한 요약 스텝은, 시작 제한을 2로 설정한다. 이는 스텝이 계속해서 실패하면, 잡 익스큐션(job execution)을 제어하는 ​​운영자에게 새로운 종료 코드가 반환되고, 수동 개입이 발생할 때까지 재시작할 수 없기 때문에 유용하다.

{: .important}
>이 잡은 이 문서에 대한 예제이며 샘플 프로젝트에 있는 `footballJob`과 동일하지 않다.

실행 1:
1. `playerLoad`가 성공적으로 실행되고 완료되어, PLAYERS 테이블에 400명의 플레이어를 추가한다.
2. `gameLoad`는 게임 데이터에 해당하는 11개 파일을 실행 및 처리하고, 해당 콘텐츠를 GAMES 테이블에 로드한다.
3. `playerSummarization`이 처리를 시작하고 5분 후 실패한다.

실행 2:
1. `playerLoad`는 이미 성공적으로 완료되었고, `allow-start-if-complete`가 `false`(기본값)이므로 실행되지 않는다.
2. `gameLoad`가 재실행되고 또 다른 2개의 파일을 처리하여, 콘텐츠도 GAMES 테이블에 로드(아직 처리되지 않았음을 나타내는 프로세스 표시기 포함)한다.
3. `playerSummarization`은 나머지 모든 게임 데이터의 처리를 시작하고(프로세스 표시기를 사용하여 필터링) 30분 후에 다시 실패한다.

실행 3:
1. `playerLoad`는 이미 성공적으로 완료되었고, `allow-start-if-complete`가 `false`(기본값)이므로 실행되지 않는다.
2. `gameLoad`가 재실행되고 또 다른 2개의 파일을 처리하여, 콘텐츠도 GAMES 테이블에 로드(아직 처리되지 않았음을 나타내는 프로세스 표시기 포함)한다.
3. `playerSummarization`이 시작되지 않고 잡이 즉시 종료된다. 이는 `playerSummarization`의 세 번째 실행이고 제한이 2이기 때문이다. 제한을 높이거나 잡을 새 `잡인스턴스(JobInstance)`로 실행해야 한다.


### 5.1.5. Configuring Skip Logic
처리 중에 발생한 오류로 스텝 실패가 발생하지 않고, 건너뛰어야 하는 시나리오가 많이 있다. 이것은 일반적으로 데이터 자체와 데이터의 의미를 이해하는 사람이 내릴 수 있는 결정이다. 예를 들어 금융 데이터는 완전히 정확해야 하는 송금으로 이어지기 때문에 건너뛸 수 없다.

반면, 공급업체 목록을 로드하는 것은 건너뛸 수 있다. 형식이 잘못되었거나, 필요한 정보가 누락되어 공급업체가 로드되지 않은 경우, 문제가 없을 수 있다. 일반적으로, 이러한 잘못된 레코드도 기록되며 나중에 리스너(listener)에 대해 논의할 때 다룬다.

다음 XML 예제는 건너뛰기 제한을 사용하는 예제를 보여준다:

`XML 구성`
```
  <step id="step1">
    <tasklet>
      <chunk reader="flatFileItemReader" writer="itemWriter" commit-interval="10" skip-limit="10">
        <skippable-exception-classes>
          <include class="org.springframework.batch.item.file.FlatFileParseException"/>
        </skippable-exception-classes>
      </chunk>
    </tasklet>
  </step>
```

다음 자바 예제는 건너뛰기 제한을 사용하는 예제를 보여준다:

`자바 구성`
```
  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      return new StepBuilder("step1", jobRepository)
                  .<String, String>chunk(10, transactionManager)
                  .reader(flatFileItemReader())
                  .writer(itemWriter())
                  .faultTolerant()
                  .skipLimit(10)
                  .skip(FlatFileParseException.class)
                  .build();
  }
```

앞의 예에서는, `플랫파일아이템리더(FlatFileItemReader)`가 사용됐다. 어느 시점에서든, `플랫파일파스익셉션(FlatFileParseException)`가 발생하면, 아이템을 건너뛰고 전체 건너뛰기 제한인 10에서 계산된다. 선언된 예외(및 해당 하위 클래스)는 청크 처리(읽기(reader), 처리(process) 또는 쓰기(writer))의 모든 스텝에서 발생할 수 있다. 별도의 카운트는 스텝 익스큐션(step execution) 내부의 읽기, 처리 및 쓰기에 대한 건너뛰기로 구성되지만, 한도는 모든 건너뛰기에 적용된다. 건너뛰기 제한에 도달하면 다음 예외로 스텝가 실패한다. 즉, 11번째 건너뛰기가 예외를 트리거하지만 10번째 건너뛰기는 트리거하지 않는다. 

이전 예제의 한 가지 문제점은 `플랫파일파스익셉션(FlatFileParseException)` 이외의 다른 예외로 인해 잡이 실패한다는 것이다. 특정 시나리오에서는 이것이 올바른 동작일 수 있다. 그러나 다른 시나리오에서는 실패를 유발하는 예외를 식별하고 다른 모든 것을 건너뛰는 것이 더 쉬울 수 있다.

다음 XML 예제는 특정 예외를 제외한 예제를 보여준다:

`XML 구성`
```
<step id="step1">
      <tasklet>
          <chunk reader="flatFileItemReader" writer="itemWriter" commit-interval="10" skip-limit="10">
              <skippable-exception-classes>
                  <include class="java.lang.Exception"/>
                  <exclude class="java.io.FileNotFoundException"/>
              </skippable-exception-classes>
          </chunk>
      </tasklet>
  </step>
```

다음 자바 예제는 특정 예외를 제외한 예제를 보여준다:

`자바 구성`
```
  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      return new StepBuilder("step1", jobRepository)
                  .<String, String>chunk(10, transactionManager)
                  .reader(flatFileItemReader())
                  .writer(itemWriter())
                  .faultTolerant()
                  .skipLimit(10)
                  .skip(Exception.class)
                  .noSkip(FileNotFoundException.class)
                  .build();
  }
```

`java.lang.Exception`을 건너뛸 수 있는 예외 클래스로 식별함으로써 해당 구성은 모든 예외를 건너뛸 수 있음을 나타낸다. 그러나 `java.io.FileNotFoundException`을 "제외(excluding)"함으로써 해당 구성은 건너뛸 수 있는 예외 클래스 목록을 `파일낫파운드익셉션(FileNotFoundException)`을 제외한 모든 예외로 세분화한다. 제외된 예외 클래스는 발생하는 것은 치명적(즉, 건너뛰지 않음)이다. 발생한 모든 예외에 대해, 건너뛰기 기능은 클래스 계층 구조에서 가장 가까운 슈퍼클래스에 의해 결정된다. 분류되지 않은 모든 예외는 '치명적(fatal)'으로 처리된다. include와 exclude를 지정하는 순서(XML 태그 또는 skip 및 noSkip 메소드 호출 사용)는 중요하지 않다.


### 5.1.6. Configuring Retry Logic
대부분의 경우, 건너뛰기 또는 `스텝` 실패를 유발하는 예외면 충분하다. 그러나 모든 예외가 그렇게 결정된 것은 아니다. 읽는 동안 `플랫파일파스익셉션(FlatFileParseException)`이 발생하면 해당 레코드는 항상 예외를  발생시킨다. `아이템리더(ItemReader)`를 재설정해도 도움이 되지 않는다. 그러나, 다른 예외(예: 현재 프로세스가 다른 프로세스가 보유하고 있는 락(lock)이 걸린 레코드를 업데이트하려고 시도했음을 나타내는 `데드락루저데이터억세스익셉션(DeadlockLoserDataAccessException)`)의 경우, 기다렸다가 재시도하면 성공할 수 있다.

XML에서, 재시도는 다음과 같이 구성해야 한다:

```
  <step id="step1">
    <tasklet>
      <chunk reader="itemReader" writer="itemWriter" commit-interval="2" retry-limit="3">
        <retryable-exception-classes>
          <include class="org.springframework.dao.DeadlockLoserDataAccessException"/>
        </retryable-exception-classes>  
      </chunk> 
    </tasklet>
  </step>
```

자바에서, 재시도는 다음과 같이 구성해야 한다:

```
  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      return new StepBuilder("step1", jobRepository)
                  .<String, String>chunk(2, transactionManager)
                  .reader(itemReader())
                  .writer(itemWriter())
                  .faultTolerant()
                  .retryLimit(3)
                  .retry(DeadlockLoserDataAccessException.class)
                  .build();
  }
```

이 `스텝`에서는 개별 아이템을 재시도할 수 있는 횟수 제한과 "재시도 가능한(retryable)" 예외 목록이 있다. 재시도 작동 방식에 대한 자세한 내용은 재시도(Retry)에서 확인할 수 있다.


### 5.1.7. Controlling Rollback
기본적으로, 재시도 또는 건너뛰기에 관계없이 `아이템라이터(ItemWriter)`에서 예외가 발생하면 스텝에서 제어하는 ​​트랜잭션이 롤백된다. 앞서 설명한 대로 건너뛰기를 구성하면, `아이템리더(ItemReader)`에서 발생한 예외로 인해 롤백이 발생하지 않는다. 그러나, 트랜잭션을 무효화하기 위한 작업이 수행되지 않았기 때문에, `아이템라이터(ItemWriter)`에서 발생한 예외로 인해 롤백이 발생하지 않는 많은 시나리오가 있다. 이러한 이유로, 롤백을 발생시키지 않아야 하는 예외 목록으로 `스텝`를 구성할 수 있다.

XML에서는, 다음과 같이 롤백을 제어할 수 있다:

`XML 구성`
```
<step id="step1">
    <tasklet>
      <chunk reader="itemReader" writer="itemWriter" commit-interval="2"/>
      <no-rollback-exception-classes>
        <include class="org.springframework.batch.item.validator.ValidationException"/>
      </no-rollback-exception-classes>
    </tasklet>
  </step>
```

자바에서는, 다음과 같이 롤백을 제어할 수 있다:

`자바 구성`
```
  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      return new StepBuilder("step1", jobRepository)
                  .<String, String>chunk(2, transactionManager)
                  .reader(itemReader())
                  .writer(itemWriter())
                  .faultTolerant()
                  .noRollback(ValidationException.class)
                  .build();
  }
```

#### Transactional Readers
`아이템리더(ItemReader)`의 기본적인 기능은 전달이다. 스텝에서 롤백이 발생할 경우, 리더(reader)에서 아이템을 다시 읽을 필요가 없도록 리더의 입력을 버퍼링한다. 그러나, 리더(reader)가 JMS 큐(queue)와 같은, 트랜잭션 리소스 위에 구축되는 특정 시나리오가 있다. 이 경우, 롤백된 트랜잭션에 큐가 연결되어 있으므로, 큐에서 가져온 메시지를 다시 저장한다. 이러한 이유로, 아이템을 버퍼링하지 않도록 스텝를 구성할 수 있다.

다음 예제는 XML에서 아이템을 버퍼링하지 않는 리더(reader)를 만드는 방법을 보여준다:

`XML 구성`
```
  <step id="step1">
    <tasklet>
        <chunk reader="itemReader" writer="itemWriter" commit-interval="2" is-reader-transactional-queue="true"/>
    </tasklet>
  </step>
```

다음 예제는 자바에서 아이템을 버퍼링하지 않는 리더(reader)를 만드는 방법을 보여준다:

`자바 구성`
```
  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      return new StepBuilder("step1", jobRepository)
                  .<String, String>chunk(2, transactionManager)
                  .reader(itemReader())
                  .writer(itemWriter())
                  .readerIsTransactionalQueue()
                  .build();
  }
```


### 5.1.8. Transaction Attributes
트랜잭션 애트리뷰트를 사용하여 `격리(isolation)`, `전파(propagation)` 및 `제한 시간(timeout)` 설정을 제어할 수 있다. [스프링 코어 문서](https://docs.spring.io/spring-framework/reference/data-access/transaction.html)에서 트랜잭션 속성 설정에 대한 자세한 정보를 찾을 수 있다.

다음 예는 XML에서 `격리`, `전파` 및 `제한 시간`을 트랜잭션 애트리뷰트로 설정한다:

`XML 구성`
```
<step id="step1">
      <tasklet>
          <chunk reader="itemReader" writer="itemWriter" commit-interval="2"/>
          <transaction-attributes isolation="DEFAULT" propagation="REQUIRED" timeout="30"/>
      </tasklet>
  </step>
```

다음 예는 자바에서 `격리`, `전파` 및 `제한 시간`을 트랜잭션 애트리뷰트로 설정한다:

`자바 구성`
```
  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      DefaultTransactionAttribute attribute = new DefaultTransactionAttribute();
      attribute.setPropagationBehavior(Propagation.REQUIRED.value());
      attribute.setIsolationLevel(Isolation.DEFAULT.value());
      attribute.setTimeout(30);
      return new StepBuilder("step1", jobRepository)
                  .<String, String>chunk(2, transactionManager)
                  .reader(itemReader())
                  .writer(itemWriter())
                  .transactionAttribute(attribute)
                  .build();
  }
```

### 5.1.9. Registering `ItemStream` with a `Step`
스텝은 라이프사이클이 필요한 시점에서 `아이템스트림(ItemStream)`(`아이템스트림(ItemStream)` 인터페이스에 대한 자세한 내용은 아이템스트림(ItemStream)을 참조하자.)을 콜백을 처리해야 한다.  `아이템스트림(ItemStream)`인터페이스는 스텝 실행 사이의 지속 상태에 대해 필요한 정보를 가져오는 곳이기 때문에, 스텝이 실패하고 다시 시작해야 하는 경우 중요하다.

`아이템리더(ItemReader)`, `아이템프로세서(ItemProcessor)` 또는 `아이템라이터(ItemWriter)` 자체가 `아이템스트림(ItemStream)` 인터페이스를 구현하는 경우 자동으로 등록된다. 다른 모든 스트림은 별도로 등록해야 한다. 델리게이트와 같은, 간접 의존성이 리더와 라이터에, 주입되는 경우가 많다. `스트림(stream)` 엘리먼트를 통해 스텝에 스트림을 등록할 수 있다.

다음 예는 XML의 스텝에서 스트림을 등록하는 방법을 보여준다:

`XML 구성`
```
  <step id="step1">
    <tasklet>
      <chunk reader="itemReader" writer="compositeWriter" commit-interval="2">
        <streams>
          <stream ref="fileItemWriter1"/>
          <stream ref="fileItemWriter2"/>
        </streams>
      </chunk>
    </tasklet>
  </step>
  <beans:bean id="compositeWriter" class="org.springframework.batch.item.support.CompositeItemWriter">
    <beans:property name="delegates">
      <beans:list>
        <beans:ref bean="fileItemWriter1" />
        <beans:ref bean="fileItemWriter2" />
      </beans:list>
    </beans:property>
  </beans:bean>
```

다음 예는 자바의 스텝에서 스트림을 등록하는 방법을 보여준다:

`자바 구성`
```
  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
      return new StepBuilder("step1", jobRepository)
                  .<String, String>chunk(2, transactionManager)
                  .reader(itemReader())
                  .writer(compositeItemWriter())
                  .stream(fileItemWriter1())
                  .stream(fileItemWriter2())
                  .build();
  }

  /**
   * 스프링 배치 4에서, 컴포짓아이템라이터(CompositeItemWriter)는 아이템스트림(ItemStream)을 구현하므로 필요하지 않지만, 예제로 사용된다.
   */
  @Bean
  public CompositeItemWriter compositeItemWriter() {
      List<ItemWriter> writers = new ArrayList<>(2);
      writers.add(fileItemWriter1());
      writers.add(fileItemWriter2());
      CompositeItemWriter itemWriter = new CompositeItemWriter();
      itemWriter.setDelegates(writers);
      return itemWriter;
  }
```

앞의 예에서, `컴포짓아이템라이터(CompositeItemWriter)`는 `아이템스트림(ItemStream)`이 아니지만, 두 객체 모두 델리게이트(delegate)는 아이템스트림(ItemStream)이다. 따라서, 두 델리게이트 라이터(delegate writers)는 프레임워크가 올바르게 처리할 수 있도록 스트림으로 명시적인 등록을 해야한다. `아이템리더(ItemReader)`는 `스텝`의 직접적인 프로퍼티이므로 스트림으로 명시적인 등록을 할 필요가 없다. 이제 스텝를 재시작할 수 있으며, 오류 발생 시 리더(reader) 및 라이터(writer)의 상태가 올바르게 유지된다.


### 5.1.10. Intercepting `Step` Execution
`잡`과 마찬가지로, 스텝을 실행면서 일부 기능을 수행해야 하는 많은 이벤트가 있다. 예를 들어, 푸터(footer)를 플랫 파일에 작성하려면, 푸터(footer)를 쓸 수 있도록 `스텝`이 완료되었을 때 `아이템라이터(ItemWriter)`에 알려야 한다. 이는 많은 `스텝` 스코프 리스너(Step scoped listeners) 중 하나를 사용하여 수행할 수 있다. 

`스텝리스너(StepListener)`의 확장(extension) 중 하나를 구현하는 클래스(비어 있는 인터페이스 자체는 아님)를 `리스너(listeners)` 엘리먼트를 통해 스텝에 적용할 수 있다. 리스너(listeners) 엘리먼트는 스텝, 태스크릿(tasklet) 또는 청크 선언 내에서 유효하다. 기능이 적용되는 레벨에 리스너를 선언하거나, 다기능인 경우(예: `스텝익스큐션리스너(StepExecutionListener)` 및 `아이템리드리스너(ItemReadListener)`) 적용되는 가장 세분화된 레벨에서 리스너를 선언하는 것이 좋다.

다음 예는 XML의 청크 레벨에 적용된 리스너를 보여준다:

`XML 구성`
```
  <step id="step1">
    <tasklet>
      <chunk reader="reader" writer="writer" commit-interval="10"/>
      <listeners>
        <listener ref="chunkListener"/>
      </listeners>
    </tasklet>
  </step>
```

다음 예는 자바의 청크 레벨에 적용된 리스너를 보여준다:

`자바 구성`
```
  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
    return new StepBuilder("step1", jobRepository)
                .<String, String>chunk(10, transactionManager)
                .reader(reader())
                .writer(writer())
                .listener(chunkListener())
                .build();
  }
```

`스텝리스너(StepListener)` 인터페이스 중 하나를 구현하는 `아이템리더(ItemReader)`, `아이템라이터(ItemWriter)` 또는 `아이템프로세서(ItemProcessor)`는 네임스페이스 `<step>` 엘리먼트 또는 `*StepFactoryBean` 팩토리 중 하나를 사용하는 경우 스텝에 자동으로 등록된다. 이는 스텝에 직접 주입된 컴포넌트에만 적용된다. 리스너가 다른 컴포넌트 내에 중첩된 경우 (이전에 [아이템스트림(ItemStream) 등록](https://onestone9900.github.io/docs/spring_batch/5.0.2/5.%20configuring_a_step/#519-registering-itemstream-with-a-step)에서 설명한 대로)명시적으로 등록해야 한다.

`스텝리스너(StepListener)` 인터페이스 외에도, 동일한 문제를 해결하기 위해 어노테이션이 제공된다. 일반 자바 객체는 이러한 어노테이션이 포함된 메서드를 가질 수 있으며 해당 `스텝리스너(StepListener)` 타입으로 변환된다. `아이템리더(ItemReader)`, `아이템라이터(ItemWriter)` 또는 `태스크릿(Tasklet)`과 같은 청크 컴포넌트의 커스텀 구현체에 어노테이션을 추가하는 것도 가능하다. 어노테이션은 `<listener/>` 엘리먼트에 대한 XML 파서에 의해 분석되고 빌더의 리스너 메소드에 등록되므로, XML 네임스페이스 또는 빌더를 사용하여 리스너를 스텝에 등록하기만 하면 된다.


#### `StepExecutionListener`
`스텝익스큐션리스너(StepExecutionListener)`는 스텝 익스큐션(Step execution)을 위한 가장 일반적인 리스너이다. 다음 예제와 같이 스텝이 시작되기 전과 끝난 후에, 정상적으로 종료되었는지 또는 실패했는지에 대한, 알림 허용한다:

```
  public interface StepExecutionListener extends StepListener {
    void beforeStep(StepExecution stepExecution);
    ExitStatus afterStep(StepExecution stepExecution);
  }
```

`엑시트스테이터스(ExitStatus)`에는 리스너가 스텝 완료 시 반환하는 종료 코드를 수정할 수 있도록 `afterStep` 반환 타입이 있다.

이 인터페이스에 해당하는 어노테이션은 다음과 같다:
- `@BeforeStep`
- `@AfterStep`


#### `ChunkListener`
"청크(chunk)"는 트랜잭션 범위 내에서 처리되는 아이템이다. 커밋 인터벌(commit interval)마다 트랜잭션을 커밋하면 청크가 커밋된다. 다음 인터페이스 정의와 같이 `청크리스너(ChunkListener)`를 사용하여 청크 처리를 시작하기 전 또는 청크가 성공적으로 완료된 후의 로직을 수행할 수 있다:

```
  public interface ChunkListener extends StepListener {
    void beforeChunk(ChunkContext context);
    void afterChunk(ChunkContext context);
    void afterChunkError(ChunkContext context);
  }
```

`beforeChunk` 메서드는 트랜잭션이 시작된 후 `아이템리더(ItemReader)`에서 읽기가 시작되기 전에 호출된다. 반대로, `afterChunk`는 청크가 커밋(또는 롤백이 있는 경우 전혀 호출되지 않음)된 후 호출된다.

이 인터페이스에 해당하는 어노테이션은 다음과 같다:
- `@BeforeChunk`
- `@AfterChunk`
- `@AfterChunkError`

청크 선언이 없을 때 청크리스너(ChunkListener)를 적용할 수 있다. `태스크릿스텝(TaskletStep)`은 `청크리스너(ChunkListener)` 호출을 담당하므로, `아이템 지향이 아닌(non-item-oriented)` 태스크릿(tasklet)에도 적용(tasklet 전후에 호출됨)된다.


#### `ItemReadListener`
이전에 건너뛰기(skip) 로직을 논의할 때, 건너뛴 레코드를 나중에 처리할 수 있도록 기록하는 것이 도움이 될 수 있다고 언급했다. 읽기 오류의 경우, 다음 인터페이스 정의와 같이 `아이템리더리스너(ItemReaderListener)`를 사용하여 이를 수행할 수 있다:

```
  public interface ItemReadListener<T> extends StepListener {
    void beforeRead();
    void afterRead(T item);
    void onReadError(Exception ex);
  }
```

`beforeRead` 메서드는 `아이템리더(ItemReader)`에서 각각의 아이템을 읽기 전에 호출된다. `afterRead` 메서드는 읽기의 성공 후 호출되며 읽은 아이템이 전달된다. 읽는 동안 오류가 발생하면, `onReadError` 메서드가 호출된다. 발생한 예외는 기록할 수 있도록 한다.

이 인터페이스에 해당하는 어노테이션은 다음과 같다:

- `@BeforeRead`
- `@AfterRead`
- `@OnReadError`


#### `ItemProcessListener`
`아이템리드리스너(ItemReadListener)`와 마찬가지로, 아이템 처리(processing)는 다음 인터페이스 정의와 같이, "듣을(listened)" 수 있다:
```
  public interface ItemProcessListener<T, S> extends StepListener {
    void beforeProcess(T item);
    void afterProcess(T item, S result);
    void onProcessError(T item, Exception e);
  }
```

`beforeProcess` 메서드는 `아이템프로세서(ItemProcessor)`에서 처리하기 전에 호출되어 처리할 아이템을 전달받는다. `afterProcess` 메서드는 아이템이 성공적으로 처리된 후 호출된다. 처리 중 오류가 발생하면, `onProcessError` 메서드가 호출된다. 발생한 예외 및 처리를 시도한 아이템이, 기록될 수 있다.

이 인터페이스에 해당하는 어노테이션은 다음과 같다:
- `@BeforeProcess`
- `@AfterProcess`
- `@OnProcessError`


#### `ItemWriteListener`
다음 인터페이스 정의에서 볼 수 있듯이, `아이템라이터리스너(ItemWriteListener)`를 사용하여 항목 쓰기를 "듣을(listened)" 수 있다:
```
  public interface ItemWriteListener<S> extends StepListener {
    void beforeWrite(List<? extends S> items);
    void afterWrite(List<? extends S> items);
    void onWriteError(Exception exception, List<? extends S> items);
  }
```

`beforeWrite` 메소드는 `아이템라이터(ItemWriter)`에 쓰기 전 호출되며 작성된 아이템 목록을 전달받는다. `afterWrite` 메서드는 아이템이 성공적으로 작성된 후 호출된다. 작성하는 동안 오류가 발생하면 `onWriteError` 메서드가 호출된다. 발생한 예외 및 작성을 시도한 항목이 기록될 수 있다.

이 인터페이스에 해당하는 어노테이션은 다음과 같다:

- `@BeforeWrite` 
- `@AfterWrite`
- `@OnWriteError`


#### `SkipListener`
`아이템리드리스너(ItemReadListener)`, `아이템프로세스리스너(ItemProcessListener)` 및 `아이템라이트리스너(ItemWriteListener)`는 모두 오류를 알리는 메커니즘을 제공하지만, 실제로 레코드를 건너뛰었음(skip)을 알려주는 메커니즘은 없다. 예를 들어 `onWriteError`는 아이템이 재시도되고 성공한 경우에도 호출된다. 이러한 이유로 다음 인터페이스 정의와 같이 건너뛴 아이템을 추적하기 위한 별도의 인터페이스가 있다:

```
  public interface SkipListener<T,S> extends StepListener {
    void onSkipInRead(Throwable t);
    void onSkipInProcess(T item, Throwable t);
    void onSkipInWrite(S item, Throwable t);
  }
```

`onSkipInRead`는 읽는 동안 아이템을 건너뛸 때마다 호출된다. 롤백으로 인해 동일한 아이템이 두 번 이상 건너뛴 것으로 등록될 수 있다. `onSkipInWrite`는 쓰는 동안 아이템을 건너뛸 때 호출된다. 아이템을 성공적으로 읽었기 때문에(건너뛰지 않았으므로), 아이템 자체도 아규먼트로 제공된다.

이 인터페이스에 해당하는 어노테이션은 다음과 같다:

- `@OnSkipInRead`
- `@OnSkipInWrite`
- `@OnSkipInProcess`


##### SkipListeners and Transactions
`스킵리스너(SkipListener)`의 가장 일반적인 사용 사례 중 하나는 건너뛴 아이템을 로그 아웃하여, 다른 배치 프로세스 또는 휴먼 프로세스를 사용하여 건너뛴 문제를 진단하고 수정할 수 있도록 하는 것이다. 트랜잭션이 롤백될 수 있는 경우가 많기 때문에, 스프링 배치는 두 가지를 보장한다:

- 적절한 건너뛰기(skip) 메서드(오류 발생 시기에 따라 다름)는 아이템당 한 번만 호출된다.
- `스킵리스너(SkipListener)`는 항상 트랜잭션이 커밋되기 전에 호출된다. 이는 리스너가 호출하는 모든 트랜잭션 리소스가 `아이템라이터(ItemWriter)` 내 오류로 인해 롤백되지 않도록 하기 위한 것이다.


## 5.2. `TaskletStep`
`스텝`에서 [청크 지향 처리](https://onestone9900.github.io/docs/spring_batch/5.0.2/5.%20configuring_a_step/#51-chunk-oriented-processing)가 유일한 방법은 아니다. `스텝`이 저장 프로시저 호출로 구성되어야 하는 경우 어떻게 해야할까? 호출을 `아이템리더(ItemReader)`로 구현하고 절차가 완료된 후 null을 반환할 수 있다. 그러나, 그렇게 하는 것은 약간 부자연스러운데, 왜냐하면 무작동(no-op) `아이템라이터(ItemWriter)`가 필요하기 때문이다. 스프링 배치는 이런 시나리오를 위해 `태스크릿스텝(TaskletStep)`을 제공한다.

`태스크릿(Tasklet)` 인터페이스에는 `RepeatStatus.FINISHED`를 반환하거나 예외를 발생시켜 실패 신호를 보낼 때까지, `태스크릿스텝(TaskletStep)`에 의해 반복적으로 호출되는 `execute`라는 메서드가 하나 있다. `태스크릿(Tasklet)`의 각 호출은 트랜잭션으로 래핑된다. `태스크릿(Tasklet)` 구현체는 저장 프로시저, 스크립트 또는 SQL 업데이트 문을 호출할 수 있다.

`태스크릿스텝(TaskletStep)`을 생성하려면 스텝와 연결된 빈(네임스페이스를 사용할 때 `ref` 애트리뷰트을 사용며 자바 구성을 사용할 때 `tasklet` 메서드에 전달됨)은 `태스크릿(Tasklet)` 인터페이스를 구현해야 한다. 다음 예제는 간단한 tasklet을 보여준다:

`XML 구성`
```
  <step id="step1">
      <tasklet ref="myTasklet"/>
  </step>
```

`자바 구성`
```
  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
    return new StepBuilder("step1", jobRepository)
                .tasklet(myTasklet(), transactionManager)
                .build();
  }
```

{: .important}
>`스텝리스너(StepListener)` 인터페이스를 구현하는 경우, `태스크릿스텝(TaskletStep)`은 자동으로 tasklet을 `스텝리스너(StepListener)`로 등록한다.


### 5.2.1. `TaskletAdapter`
`아이템리더(ItemReader)` 및 `아이템라이터(ItemWriter)` 인터페이스에 대한 다른 어댑터와 마찬가지로, `태스크릿(Tasklet)` 인터페이스에는 기존 클래스에 적응할 수 있는 `태스크릿어댑터(TaskletAdapter)`와 같은 구현체가 포함되어 있다. 이것이 유용하게 사용되는 예시가 레코드 집합에서 플래그를 업데이트하는 데 사용되는 기존 DAO이다. `태스크릿(Tasklet)` 인터페이스용 어댑터를 작성하지 않고도 `태스크릿어댑터(TaskletAdapter)`를 사용하여 이 클래스를 호출할 수 있다.

다음 예제는 XML에서 `태스크릿어댑터(TaskletAdapter)`를 정의하는 방법을 보여준다:

`XML 구성`
```
  <bean id="myTasklet" class="o.s.b.core.step.tasklet.MethodInvokingTaskletAdapter">
    <property name="targetObject">
      <bean class="org.mycompany.FooDao"/>
    </property>
    <property name="targetMethod" value="updateFoo" />
  </bean>
```

다음 예제는 자바에서 `태스크릿어댑터(TaskletAdapter)`를 정의하는 방법을 보여준다:

`자바 구성`
```
  @Bean
  public MethodInvokingTaskletAdapter myTasklet() {
    MethodInvokingTaskletAdapter adapter = new MethodInvokingTaskletAdapter();
    adapter.setTargetObject(fooDao());
    adapter.setTargetMethod("updateFoo");
    return adapter;
  }
```

### 5.2.2. Example `Tasklet` Implementation
많은 배치 잡에는 메인 처리가 시작되기 전, 다양한 리소스를 설정하기 위해 또는 처리가 완료된 후 해당 리소스를 정리하기 위해 수행해야 하는 스텝이 포함되어 있다. 파일 작업이 많은 잡의 경우, 특정 파일을 다른 위치에 성공적으로 업로드한 후 로컬에서 삭제해야 하는 경우가 많다. 다음 예제([스프링 배치 샘플 프로젝트에서 가져옴](https://github.com/spring-projects/spring-batch/tree/main/spring-batch-samples))는 그러한 책임이 있는 태스크릿(Tasklet) 구현체이다:

```
  public class FileDeletingTasklet implements Tasklet, InitializingBean {
    private Resource directory;

    public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
      File dir = directory.getFile();
      Assert.state(dir.isDirectory());
      File[] files = dir.listFiles();
      for (int i = 0; i < files.length; i++) {
        boolean deleted = files[i].delete();
        if (!deleted) {
          throw new UnexpectedJobExecutionException("Could not delete file " + files[i].getPath());
        }
      }
      return RepeatStatus.FINISHED;
    }

    public void setDirectoryResource(Resource directory) {
      this.directory = directory;
    }

    public void afterPropertiesSet() throws Exception {
      Assert.state(directory != null, "directory must be set");
    } 
  }
```

위의 `태스크릿(tasklet)` 구현체는 지정된 디렉터리 내의 모든 파일을 삭제한다. `execute` 메서드는 한 번만 호출된다는 점에 유의해야 한다. 남은 것은 스텝에서 태스크릿(tasklet)을 참조하는 것이다.

다음 예는 XML의 스텝에서 `태스크릿(tasklet)`을 참조하는 방법을 보여준다:

`XML 구성`
```
  <job id="taskletJob">
    <step id="deleteFilesInDir">
      <tasklet ref="fileDeletingTasklet"/>
    </step>
  </job>

  <beans:bean id="fileDeletingTasklet" class="org.springframework.batch.sample.tasklet.FileDeletingTasklet">
    <beans:property name="directoryResource">
      <beans:bean id="directory" class="org.springframework.core.io.FileSystemResource">
        <beans:constructor-arg value="target/test-outputs/test-dir" />
      </beans:bean>
    </beans:property>
  </beans:bean>
```

다음 예는 자바의 스텝에서 `태스크릿(tasklet)`을 참조하는 방법을 보여준다:

`자바 구성`
```
  @Bean
  public Job taskletJob(JobRepository jobRepository) {
    return new JobBuilder("taskletJob", jobRepository)
            .start(deleteFilesInDir())
            .build();
  }

  @Bean
  public Step deleteFilesInDir(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
    return new StepBuilder("deleteFilesInDir", jobRepository)
              .tasklet(fileDeletingTasklet(), transactionManager)
              .build();
  }

  @Bean
  public FileDeletingTasklet fileDeletingTasklet() {
    FileDeletingTasklet tasklet = new FileDeletingTasklet();
    tasklet.setDirectoryResource(new FileSystemResource("target/test-outputs/test-dir"));
    return tasklet;
  }
```
