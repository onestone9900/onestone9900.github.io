---
layout: default
title:  13. Spring Batch Integration
parent: 5.0.2
grand_parent: SpringBatch
nav_order: 15
---


# 13. Spring Batch Integration
많은 스프링 배치 사용자는 스프링 인테그레이션(Spring Integration)을 사용하면 효율적이고 간단하게 구현가능한 요구 사항이 있을 수 있다. 반대로, 스프링 인테그레이션(Spring Integration) 사용자는 스프링 배치 요구 사항이 있을 수 있으며 두 프레임워크를 효율적으로 통합하는 방법이 필요할 수 있다. 이러한 맥락에서 여러 패턴과 사례가 나타나고 스프링 배치 인테그레이션은 이러한 요구 사항을 해결한다.

스프링 배치와 스프링 인테그레이션 사이의 경계가 항상 명확하지는 않지만, 세분성에 대해 생각하고 공통 패턴을 적용하는 두 가지 조언이 도움이 될 수 있다: 이 절에서는 이러한 일반적인 패턴 중 일부를 설명한다.

배치 프로세스에 메시징을 추가하면 운영을 자동화하고 주요 관심사를 분리 및 전략화할 수 있다. 예를 들어, 메시지는 잡 실행을 트리거할 수 있으며, 메시지 전송은 다양한 방식으로 노출될 수 있다. 또는 잡이 완료되거나 실패하면 해당 이벤트가 메시지 전송을 트리거할 수 있으며 해당 메시지의 소비자는 애플리케이션 자체와 관련이 없는 운영 문제(예: 채널을 통해 처리할 아이템 읽기 또는 쓰기)를 가질 수 있다. 원격 분할 및 원격 청킹은 여러 워커에게 작업 부하를 분산하는 방법을 제공한다.

이 장에서는 다음과 같은 개념을 다룬다.
- Namespace Support
- Launching Batch Jobs through Messages
- Providing Feedback with Informational Messages 
- Asynchronous Processors
- Externalizing Batch Process Execution


## 13.1. Namespace Support
더 쉬운 구성을 제공하기 위해 버전 1.3의 스프링 배치 인테그레이션에 전용 XML 네임스페이스 지원이 추가됐다. 네임스페이스를 사용하려면 스프링 XML 애플리케이션 컨텍스트 파일에 다음 네임스페이스 선언을 추가하자:

```xml
    <beans  xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:batch-int="http://www.springframework.org/schema/batch-integration"
            xsi:schemaLocation="
                http://www.springframework.org/schema/batch-integration
                https://www.springframework.org/schema/batch-integration/spring-batch-integration.xsd">
    ...
    </beans>
```

다음 예제는 스프링 배치 인테그레이션을 위해 완전히 구성된 스프링 XML 애플리케이션 컨텍스트 파일을 보여준다:

```xml
    <beans  xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:int="http://www.springframework.org/schema/integration"
            xmlns:batch="http://www.springframework.org/schema/batch"
            xmlns:batch-int="http://www.springframework.org/schema/batch-integration"
            xsi:schemaLocation="
                http://www.springframework.org/schema/batch-integration
                https://www.springframework.org/schema/batch-integration/spring-batch-integration.xsd
                http://www.springframework.org/schema/batch
                https://www.springframework.org/schema/batch/spring-batch.xsd
                http://www.springframework.org/schema/beans
                https://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/integration
                https://www.springframework.org/schema/integration/spring-integration.xsd">
    ...
    </beans>
```

참조된 XSD 파일에 버전 번호를 추가하는 것도 가능하다. 그러나 버전 없는 선언은 항상 최신 스키마를 사용하므로 일반적으로 XSD명에 버전 번호를 추가하지 않는 것이 좋다. 버전 번호를 추가하면 최신 버전의 XML 스키마가 필요할 수 있으므로 스프링 배치 인테그레이션 의존성을 업데이트할 때 문제가 발생할 수 있다.


## 13.2. Launching Batch Jobs through Messages
코어(core) 스프링 배치 API를 사용하여 배치 잡을 시작할 때 기본적으로 두 가지 옵션이 있다:

- `커맨트라인잡러너(CommandLineJobRunner)`로 명령줄 사용
- `JobOperator.start()` 또는 `JobLauncher.run()`을 사용한 프로그래밍 방식

예를 들어, 쉘 스크립트를 사용하여 배치 잡을 호출할 때, `커맨드라인잡러너(CommandLineJobRunner)`를 사용할 수 있다. 또는 `잡오퍼레이터(JobOperator)`를 직접 사용(예: 스프링 배치를 웹 애플리케이션의 일부로 사용하는 경우)할 수 있다.

그러나, 더 복잡한 사용 사례는 어떨까? 배치 잡 대한 데이터를 검색하기 위해 원격 (S)FTP 서버를 폴링해야 하거나 애플리케이션이 여러 다른 데이터 소스를 동시에 지원해야 할 수도 있다. 예를 들어, 웹뿐만 아니라 FTP 및 기타 소스에서도 데이터 파일을 받을 수 있다. 스프링 배치를 호출하기 전에 입력 파일의 추가 변환이 필요할 수 있다. 따라서 스프링 인테그레이션과 그에 따른 수많은 어댑터를 사용하여 배치 잡을 실행하는 것이 훨씬 더 강력할 수 있다. 예를 들어 파일 인바운드 채널 어댑터(File Inbound Channel Adapter)를 사용하여 파일 시스템의 디렉터리를 모니터링하고 입력 파일이 도착하자마자 배치 잡을 시작할 수 있다. 또한, 여러 어댑터를 사용하는 스프링 인테그레이션 플로우(flow)를 사용하여 동시에 여러 소스에서 배치 잡에 대한 데이터를 쉽게 수집할 수 있다. `잡런처(JobLauncher)`의 분리(decoupled) 및 이벤트 드리븐(event-driven)을 허용하기 때문에 스프링 인테그레이션으로 이런 상황을 구현하는 것은 쉽다. 

스프링 배치 인테그레이션은 배치 잡을 시작하는 데 사용할 수 있는 `잡런칭메세지핸들러(JobLaunchingMessageHandler)` 클래스를 제공한다. `잡런칭메세지핸들러(JobLaunchingMessageHandler)`에 대한 입력은 `잡런치리퀘스트(JobLaunchRequest)` 타입의 페이로드가 있는 스프링 인테그레이션 메시지에 의해 제공된다. 이 클래스는 배치 잡 및 잡을 시작하는 데 필요한 잡파라미터(JobParameters) 주변의 래퍼(wrapper)이다.

다음 이미지는 배치 잡을 시작하는 데 필요한 일반적인 스프링 인테그레이션 메시지 플로우(flow)을 보여준다. [EIP(Enterprise Integration Patterns)](https://www.enterpriseintegrationpatterns.com/patterns/messaging/toc.html) 웹사이트는 메시징 아이콘과 해당 설명에 대한 전체 개요를 제공한다.

![Launch Batch Job](https://docs.spring.io/spring-batch/docs/current/reference/html/images/launch-batch-job.pngs)

이미지 28. 배치 잡 실행


### 13.2.1. Transforming a File into a JobLaunchRequest
다음 예제에서 파일을 `잡런치리퀘스트(JobLaunchRequest)`로 변환한다:

```java
    package io.spring.sbi;
    import org.springframework.batch.core.Job;
    import org.springframework.batch.core.Job;
    import org.springframework.batch.core.JobParametersBuilder;
    import org.springframework.batch.integration.launch.JobLaunchRequest;
    import org.springframework.integration.annotation.Transformer;
    import org.springframework.messaging.Message;
    import java.io.File;

    public class FileMessageToJobRequest {
        private Job job;
        private String fileParameterName;

        public void setFileParameterName(String fileParameterName) {
            this.fileParameterName = fileParameterName;
        }
      
        public void setJob(Job job) {
            this.job = job;
        }
      
        @Transformer
        public JobLaunchRequest toRequest(Message<File> message) {
            JobParametersBuilder jobParametersBuilder = new JobParametersBuilder();
            jobParametersBuilder.addString(fileParameterName, message.getPayload().getAbsolutePath());
            return new JobLaunchRequest(job, jobParametersBuilder.toJobParameters());
        }
}
```


### 13.2.2. The JobExecution Response
배치 잡이 실행되면 `잡익스큐션(JobExecution)` 인스턴스가 반환된다. 이 인스턴스를 사용하여 실행 상태를 확인할 수 있다. `잡익스큐션(JobExecution)`을 성공적으로 생성하면, 실제 실행 성공 여부에 관계없이 항상 반환된다. `잡익스큐션(JobExecution)` 인스턴스가 반환되는 방식에 대한 정확한 동작은 제공된 `태스크익스큐터(TaskExecutor)`에 따라 다르다. 동기(승글 스레드) `태스트익스큐터(TaskExecutor)` 구현체가 사용되는 경우 `잡익스큐션(JobExecution)` 응답은 작업이 완료된 후에만 반환됩니다.
If a synchronous (single-threaded) TaskExecutor implementation is used, the JobExecution response is returned only after the job completes. When using an asynchronous TaskExecutor, the JobExecution instance is returned immediately. You can then take the id of JobExecution instance (with JobExecution.getJobId()) and query the JobRepository for the job’s updated status using the JobExplorer. For more information, see Querying the Repository.


### 13.2.3. Spring Batch Integration Configuration
Consider a case where someone needs to create a file inbound-channel-adapter to listen for CSV files in the provided directory, hand them off to a transformer (FileMessageToJobRequest), launch the job through the job launching gateway, and log the output of the JobExecution with the logging-channel- adapter.
The following example shows how that common case can be configured in XML: .XML Configuration

```xml
  <int:channel id="inboundFileChannel"/>
  <int:channel id="outboundJobRequestChannel"/>
  <int:channel id="jobLaunchReplyChannel"/>
  <int-file:inbound-channel-adapter id="filePoller"
      channel="inboundFileChannel"
      directory="file:/tmp/myfiles/"
      filename-pattern="*.csv">
    <int:poller fixed-rate="1000"/>
  </int-file:inbound-channel-adapter>
  <int:transformer input-channel="inboundFileChannel"
      output-channel="outboundJobRequestChannel">
    <bean class="io.spring.sbi.FileMessageToJobRequest">
      <property name="job" ref="personJob"/>
      <property name="fileParameterName" value="input.file.name"/>
    </bean>
  </int:transformer>
  <batch-int:job-launching-gateway request-channel="outboundJobRequestChannel"
      reply-channel="jobLaunchReplyChannel"/>
<int:logging-channel-adapter channel="jobLaunchReplyChannel"/>
```

The following example shows how that common case can be configured in Java:

`자바 구성`
```java
    @Bean
    public FileMessageToJobRequest fileMessageToJobRequest() {
        FileMessageToJobRequest fileMessageToJobRequest = new FileMessageToJobRequest();
        fileMessageToJobRequest.setFileParameterName("input.file.name");
        fileMessageToJobRequest.setJob(personJob());
        return fileMessageToJobRequest;
    }
    
    @Bean
    public JobLaunchingGateway jobLaunchingGateway() {
        TaskExecutorJobLauncher jobLauncher = new TaskExecutorJobLauncher();
        jobLauncher.setJobRepository(jobRepository);
        jobLauncher.setTaskExecutor(new SyncTaskExecutor());
        JobLaunchingGateway jobLaunchingGateway = new JobLaunchingGateway(jobLauncher);
        return jobLaunchingGateway;
    }

    @Bean
    public IntegrationFlow integrationFlow(JobLaunchingGateway jobLaunchingGateway) {
        return IntegrationFlow.from(Files.inboundAdapter(new File("/tmp/myfiles"))
                            .filter(new SimplePatternFileListFilter("*.csv")),
                            c -> c.poller(Pollers.fixedRate(1000).maxMessagesPerPoll(1)))
                            .transform(fileMessageToJobRequest())
                            .handle(jobLaunchingGateway)
                            .log(LoggingHandler.Level.WARN, "headers.id + ': ' + payload")
                            .get();
    }
```


### 13.2.4. Example ItemReader Configuration
Now that we are polling for files and launching jobs, we need to configure our Spring Batch ItemReader (for example) to use the files found at the location defined by the job parameter called "input.file.name", as the following bean configuration shows:
The following XML example shows the necessary bean configuration:

`XML 구성`
```xml
    <bean id="itemReader" class="org.springframework.batch.item.file.FlatFileItemReader" scope="step">
        <property name="resource" value="file://#{jobParameters['input.file.name']}"/>
        ...
    </bean>
```

The following Java example shows the necessary bean configuration:

`자바 구성`
```java
    @Bean
    @StepScope
    public ItemReader sampleReader(@Value("#{jobParameters[input.file.name]}") String resource) {
        ...
        FlatFileItemReader flatFileItemReader = new FlatFileItemReader();
        flatFileItemReader.setResource(new FileSystemResource(resource));
        ...
        return flatFileItemReader;
    }
```

The main points of interest in the preceding example are injecting the value of #{jobParameters['input.file.name']} as the Resource property value and setting the ItemReader bean to have step scope. Setting the bean to have step scope takes advantage of the late binding support, which allows access to the jobParameters variable.


## 13.3. Available Attributes of the Job-Launching Gateway
The job-launching gateway has the following attributes that you can set to control a job:
- `id`: Identifies the underlying Spring bean definition, which is an instance of either:
    - EventDrivenConsumer
    - PollingConsumer (The exact implementation depends on whether the component’s input channel is a SubscribableChannel or a PollableChannel.)
- `auto-startup`: Boolean flag to indicate that the endpoint should start automatically on startup. The default is true.
- `request-channel`: The input MessageChannel of this endpoint.
- `reply-channel`: MessageChannel to which the resulting JobExecution payload is sent.
- `reply-timeout`: Lets you specify how long (in milliseconds) this gateway waits for the reply message to be sent successfully to the reply channel before throwing an exception. This attribute applies only when the channel might block (for example, when using a bounded queue channel that is currently full). Also, keep in mind that, when sending to a DirectChannel, the invocation occurs in the sender’s thread. Therefore, the failing of the send operation may be caused by other components further downstream. The reply-timeout attribute maps to the sendTimeout property of the underlying MessagingTemplate instance. If not specified, the attribute defaults to -1, meaning that, by default, the Gateway waits indefinitely.
- `job-launcher`: Optional. Accepts a custom JobLauncher bean reference. If not specified, the adapter re-uses the instance that is registered under the id of jobLauncher. If no default instance exists, an exception is thrown.
- `order`: Specifies the order of invocation when this endpoint is connected as a subscriber to a SubscribableChannel.s


## 13.4. Sub-elements
When this Gateway is receiving messages from a PollableChannel, you must either provide a global default Poller or provide a Poller sub-element to the Job Launching Gateway.
The following example shows how to provide a poller in XML:
XML Configuration
  <batch-int:job-launching-gateway request-channel="queueChannel"
      reply-channel="replyChannel" job-launcher="jobLauncher">
    <int:poller fixed-rate="1000">
  </batch-int:job-launching-gateway>
The following example shows how to provide a poller in Java:
Java Configuration
  @Bean
  @ServiceActivator(inputChannel = "queueChannel", poller = @Poller(fixedRate="1000"))
  public JobLaunchingGateway sampleJobLaunchingGateway() {
      JobLaunchingGateway jobLaunchingGateway = new JobLaunchingGateway(jobLauncher());
      jobLaunchingGateway.setOutputChannel(replyChannel());
      return jobLaunchingGateway;
}


### 13.4.1. Providing Feedback with Informational Messages
As Spring Batch jobs can run for long times, providing progress information is often critical. For example, stakeholders may want to be notified if some or all parts of a batch job have failed. Spring Batch provides support for this information being gathered through:
- Active polling
- Event-driven listeners
When starting a Spring Batch job asynchronously (for example, by using the Job Launching Gateway), a JobExecution instance is returned. Thus, you can use JobExecution.getJobId() to continuously poll for status updates by retrieving updated instances of the JobExecution from the JobRepository by using the JobExplorer. However, this is considered sub-optimal, and an event- driven approach is preferred.
Therefore, Spring Batch provides listeners, including the three most commonly used listeners:
- StepListener
- ChunkListener
- JobExecutionListener
In the example shown in the following image, a Spring Batch job has been configured with a StepExecutionListener. Thus, Spring Integration receives and processes any step before or after events. For example, you can inspect the received StepExecution by using a Router. Based on the results of that inspection, various things can occur (such as routing a message to a mail outbound channel adapter), so that an email notification can be sent out based on some condition.


이미지 29. Handling Informational Messages

The following two-part example shows how a listener is configured to send a message to a Gateway for a StepExecution events and log its output to a logging-channel-adapter.
First, create the notification integration beans.
The following example shows the how to create the notification integration beans in XML: 

`XML 구성`
```xml
    <int:channel id="stepExecutionsChannel"/>

    <int:gateway id="notificationExecutionsListener"
        service-interface="org.springframework.batch.core.StepExecutionListener"
        default-request-channel="stepExecutionsChannel"/>

    <int:logging-channel-adapter channel="stepExecutionsChannel"/>
```

The following example shows the how to create the notification integration beans in Java:

`자바 구성`
```java
    @Bean
    @ServiceActivator(inputChannel = "stepExecutionsChannel")
    public LoggingHandler loggingHandler() {
        LoggingHandler adapter = new LoggingHandler(LoggingHandler.Level.WARN);
        adapter.setLoggerName("TEST_LOGGER");
        adapter.setLogExpressionString("headers.id + ': ' + payload");
        return adapter;
    }

    @MessagingGateway(name = "notificationExecutionsListener", defaultRequestChannel = "stepExecutionsChannel")
    public interface NotificationExecutionListener extends StepExecutionListener {}
```

{: .important}
>You need to add the @IntegrationComponentScan annotation to your configuration.

Second, modify your job to add a step-level listener.
The following example shows the how to add a step-level listener in XML:

`XML 구성`
```xml
    <job id="importPayments">
        <step id="step1">
            <tasklet ../>
                <chunk ../>
                <listeners>
                    <listener ref="notificationExecutionsListener"/>
                </listeners>
            </tasklet>
            ...
        </step>
    </job>
```

The following example shows the how to add a step-level listener in Java:

`자바 구성`
```java
    public Job importPaymentsJob(JobRepository jobRepository) {
        return new JobBuilder("importPayments", jobRepository)
                .start(
                    stepBuilderFactory.get("step1")
                    .chunk(200)
                    .listener(notificationExecutionsListener())
                    ...
                )
    }
```