---
layout: default
title:  13. Spring Batch Integration
parent: 5.0.2
grand_parent: SpringBatch
nav_order: 15
---


# 13. Spring Batch Integration
많은 스프링 배치 사용자는 스프링 인테그레이션(Spring Integration)을 사용하면 효율적이고 간단하게 구현가능한 요구 사항이 있을 수 있다. 반대로, 스프링 인테그레이션(Spring Integration) 사용자는 스프링 배치 요구 사항이 있을 수 있으며 두 프레임워크를 효율적으로 통합하는 방법이 필요할 수 있다. 이러한 맥락에서 여러 패턴과 사례가 나타나고 스프링 배치 인테그레이션은 이러한 요구 사항을 해결한다.

스프링 배치와 스프링 인테그레이션 사이의 경계가 항상 명확하지는 않지만, 세분성에 대해 생각하고 공통 패턴을 적용하는 두 가지 조언이 도움이 될 수 있다: 이 절에서는 이러한 일반적인 패턴 중 일부를 설명한다.

배치 프로세스에 메시징을 추가하면 운영을 자동화하고 주요 관심사를 분리 및 전략화할 수 있다. 예를 들어, 메시지는 잡 실행을 트리거할 수 있으며, 메시지 전송은 다양한 방식으로 노출될 수 있다. 또는 잡이 완료되거나 실패하면 해당 이벤트가 메시지 전송을 트리거할 수 있으며 해당 메시지의 소비자는 애플리케이션 자체와 관련이 없는 운영 문제(예: 채널을 통해 처리할 아이템 읽기 또는 쓰기)를 가질 수 있다. 원격 분할 및 원격 청킹은 여러 워커에게 작업 부하를 분산하는 방법을 제공한다.

이 장에서는 다음과 같은 개념을 다룬다.
- Namespace Support
- Launching Batch Jobs through Messages
- Providing Feedback with Informational Messages 
- Asynchronous Processors
- Externalizing Batch Process Execution


## 13.1. Namespace Support
더 쉬운 구성을 제공하기 위해 버전 1.3의 스프링 배치 인테그레이션에 전용 XML 네임스페이스 지원이 추가됐다. 네임스페이스를 사용하려면 스프링 XML 애플리케이션 컨텍스트 파일에 다음 네임스페이스 선언을 추가하자:

```xml
    <beans  xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:batch-int="http://www.springframework.org/schema/batch-integration"
            xsi:schemaLocation="
                http://www.springframework.org/schema/batch-integration
                https://www.springframework.org/schema/batch-integration/spring-batch-integration.xsd">
    ...
    </beans>
```

다음 예제는 스프링 배치 인테그레이션을 위해 완전히 구성된 스프링 XML 애플리케이션 컨텍스트 파일을 보여준다:

```xml
    <beans  xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:int="http://www.springframework.org/schema/integration"
            xmlns:batch="http://www.springframework.org/schema/batch"
            xmlns:batch-int="http://www.springframework.org/schema/batch-integration"
            xsi:schemaLocation="
                http://www.springframework.org/schema/batch-integration
                https://www.springframework.org/schema/batch-integration/spring-batch-integration.xsd
                http://www.springframework.org/schema/batch
                https://www.springframework.org/schema/batch/spring-batch.xsd
                http://www.springframework.org/schema/beans
                https://www.springframework.org/schema/beans/spring-beans.xsd
                http://www.springframework.org/schema/integration
                https://www.springframework.org/schema/integration/spring-integration.xsd">
    ...
    </beans>
```

참조된 XSD 파일에 버전 번호를 추가하는 것도 가능하다. 그러나 버전 없는 선언은 항상 최신 스키마를 사용하므로 일반적으로 XSD명에 버전 번호를 추가하지 않는 것이 좋다. 버전 번호를 추가하면 최신 버전의 XML 스키마가 필요할 수 있으므로 스프링 배치 인테그레이션 의존성을 업데이트할 때 문제가 발생할 수 있다.


## 13.2. Launching Batch Jobs through Messages
코어(core) 스프링 배치 API를 사용하여 배치 잡을 시작할 때 기본적으로 두 가지 옵션이 있다:

- `커맨트라인잡러너(CommandLineJobRunner)`로 명령줄 사용
- `JobOperator.start()` 또는 `JobLauncher.run()`을 사용한 프로그래밍 방식

예를 들어, 쉘 스크립트를 사용하여 배치 잡을 호출할 때, `커맨드라인잡러너(CommandLineJobRunner)`를 사용할 수 있다. 또는 `잡오퍼레이터(JobOperator)`를 직접 사용(예: 스프링 배치를 웹 애플리케이션의 일부로 사용하는 경우)할 수 있다.

그러나, 더 복잡한 사용 사례는 어떨까? 배치 잡 대한 데이터를 검색하기 위해 원격 (S)FTP 서버를 폴링해야 하거나 애플리케이션이 여러 다른 데이터 소스를 동시에 지원해야 할 수도 있다. 예를 들어, 웹뿐만 아니라 FTP 및 기타 소스에서도 데이터 파일을 받을 수 있다. 스프링 배치를 호출하기 전에 입력 파일의 추가 변환이 필요할 수 있다. 따라서 스프링 인테그레이션과 그에 따른 수많은 어댑터를 사용하여 배치 잡을 실행하는 것이 훨씬 더 강력할 수 있다. 예를 들어 파일 인바운드 채널 어댑터(File Inbound Channel Adapter)를 사용하여 파일 시스템의 디렉터리를 모니터링하고 입력 파일이 도착하자마자 배치 잡을 시작할 수 있다. 또한, 여러 어댑터를 사용하는 스프링 인테그레이션 플로우(flow)를 사용하여 동시에 여러 소스에서 배치 잡에 대한 데이터를 쉽게 수집할 수 있다. `잡런처(JobLauncher)`의 분리(decoupled) 및 이벤트 드리븐(event-driven)을 허용하기 때문에 스프링 인테그레이션으로 이런 상황을 구현하는 것은 쉽다. 

스프링 배치 인테그레이션은 배치 잡을 시작하는 데 사용할 수 있는 `잡런칭메세지핸들러(JobLaunchingMessageHandler)` 클래스를 제공한다. `잡런칭메세지핸들러(JobLaunchingMessageHandler)`에 대한 입력은 `잡런치리퀘스트(JobLaunchRequest)` 타입의 페이로드가 있는 스프링 인테그레이션 메시지에 의해 제공된다. 이 클래스는 배치 잡 및 잡을 시작하는 데 필요한 잡파라미터(JobParameters) 주변의 래퍼(wrapper)이다.

다음 이미지는 배치 잡을 시작하는 데 필요한 일반적인 스프링 인테그레이션 메시지 플로우(flow)을 보여준다. [EIP(Enterprise Integration Patterns)](https://www.enterpriseintegrationpatterns.com/patterns/messaging/toc.html) 웹사이트는 메시징 아이콘과 해당 설명에 대한 전체 개요를 제공한다.

![Launch Batch Job](https://docs.spring.io/spring-batch/docs/current/reference/html/images/launch-batch-job.png)

이미지 28. 배치 잡 실행


### 13.2.1. Transforming a File into a JobLaunchRequest
다음 예제에서 파일을 `잡런치리퀘스트(JobLaunchRequest)`로 변환한다:

```java
    package io.spring.sbi;
    import org.springframework.batch.core.Job;
    import org.springframework.batch.core.Job;
    import org.springframework.batch.core.JobParametersBuilder;
    import org.springframework.batch.integration.launch.JobLaunchRequest;
    import org.springframework.integration.annotation.Transformer;
    import org.springframework.messaging.Message;
    import java.io.File;

    public class FileMessageToJobRequest {
        private Job job;
        private String fileParameterName;

        public void setFileParameterName(String fileParameterName) {
            this.fileParameterName = fileParameterName;
        }
      
        public void setJob(Job job) {
            this.job = job;
        }
      
        @Transformer
        public JobLaunchRequest toRequest(Message<File> message) {
            JobParametersBuilder jobParametersBuilder = new JobParametersBuilder();
            jobParametersBuilder.addString(fileParameterName, message.getPayload().getAbsolutePath());
            return new JobLaunchRequest(job, jobParametersBuilder.toJobParameters());
        }
}
```


### 13.2.2. The JobExecution Response
배치 잡이 실행되면 `잡익스큐션(JobExecution)` 인스턴스가 반환된다. 이 인스턴스를 사용하여 실행 상태를 확인할 수 있다. `잡익스큐션(JobExecution)`을 성공적으로 생성하면, 실제 실행 성공 여부에 관계없이 항상 반환된다. 

`잡익스큐션(JobExecution)` 인스턴스가 반환되는 방식에 대한 정확한 동작은 제공된 `태스크익스큐터(TaskExecutor)`에 따라 다르다. 동기(승글 스레드) `태스트익스큐터(TaskExecutor)` 구현체가 사용되는 경우 `잡익스큐션(JobExecution)` 응답은 작업이 완료된 후에만 반환된다. 비동기 `태스크익스큐터(TaskExecutor)`를 사용하면, `잡익스큐션(JobExecution)` 인스턴스가 즉시 반환된다. 그런 다음 `잡익스큐션(JobExecution)` 인스턴스의 ID(JobExecution.getJobId() 사용)를 가져오고 `잡익스플로러(JobExplorer)`를 사용하여 `잡리포지터리(JobRepository)`에서 잡의 업데이트된 상태를 쿼리할 수 있다. 자세한 내용은 [리포지토리 쿼리](https://onestone9900.github.io/docs/spring_batch/5.0.2/5.configuring_and_running_a_job/#461-querying-the-repository)를 참고하자.


### 13.2.3. Spring Batch Integration Configuration
제공된 디렉터리에서 CSV 파일을 수신하고, 변환기(`파일메세지투잡리퀘스트(FileMessageToJobRequest)`)에 전달하고, 잡 런칭 게이트웨이(job launching gateway)를 통해 잡을 실행하고, `로깅 채널 어댑터(logging-channel-adapter)`를 사용하여 `잡익스큐션(JobExecution)`의 출력을 기록하고, 출력을 기록하기 위해 누군가 `인바운드 채널 어댑터(inbound-channel-adapter)` 파일을 생성해야 하는 경우를 생각해 보자.

다음 예제는 XML에서 일반적인 사례 구성 방법을 보여준다:

`XML 구성`

```xml
  <int:channel id="inboundFileChannel"/>
  <int:channel id="outboundJobRequestChannel"/>
  <int:channel id="jobLaunchReplyChannel"/>
  <int-file:inbound-channel-adapter id="filePoller"
      channel="inboundFileChannel"
      directory="file:/tmp/myfiles/"
      filename-pattern="*.csv">
    <int:poller fixed-rate="1000"/>
  </int-file:inbound-channel-adapter>
  <int:transformer input-channel="inboundFileChannel"
      output-channel="outboundJobRequestChannel">
    <bean class="io.spring.sbi.FileMessageToJobRequest">
      <property name="job" ref="personJob"/>
      <property name="fileParameterName" value="input.file.name"/>
    </bean>
  </int:transformer>
  <batch-int:job-launching-gateway request-channel="outboundJobRequestChannel"
      reply-channel="jobLaunchReplyChannel"/>
<int:logging-channel-adapter channel="jobLaunchReplyChannel"/>
```

다음 예제는 자바에서 일반적인 사례 구성 방법을 보여준다:

`자바 구성`
```java
    @Bean
    public FileMessageToJobRequest fileMessageToJobRequest() {
        FileMessageToJobRequest fileMessageToJobRequest = new FileMessageToJobRequest();
        fileMessageToJobRequest.setFileParameterName("input.file.name");
        fileMessageToJobRequest.setJob(personJob());
        return fileMessageToJobRequest;
    }
    
    @Bean
    public JobLaunchingGateway jobLaunchingGateway() {
        TaskExecutorJobLauncher jobLauncher = new TaskExecutorJobLauncher();
        jobLauncher.setJobRepository(jobRepository);
        jobLauncher.setTaskExecutor(new SyncTaskExecutor());
        JobLaunchingGateway jobLaunchingGateway = new JobLaunchingGateway(jobLauncher);
        return jobLaunchingGateway;
    }

    @Bean
    public IntegrationFlow integrationFlow(JobLaunchingGateway jobLaunchingGateway) {
        return IntegrationFlow.from(Files.inboundAdapter(new File("/tmp/myfiles"))
                            .filter(new SimplePatternFileListFilter("*.csv")),
                            c -> c.poller(Pollers.fixedRate(1000).maxMessagesPerPoll(1)))
                            .transform(fileMessageToJobRequest())
                            .handle(jobLaunchingGateway)
                            .log(LoggingHandler.Level.WARN, "headers.id + ': ' + payload")
                            .get();
    }
```


### 13.2.4. Example ItemReader Configuration
이제 파일을 폴링하고 잡을 시작할 것이므로, 다음 빈(Bean) 구성과 같이 잡파라미터에 정의된 "input.file.name" 위치에 있는 파일을 사용하도록 스프링 배치 `아이템리더(ItemReader)`를 구성해야 한다:

다음 예제는 XML에서 필요한 빈 구성을 보여준다:

`XML 구성`
```xml
    <bean id="itemReader" class="org.springframework.batch.item.file.FlatFileItemReader" scope="step">
        <property name="resource" value="file://#{jobParameters['input.file.name']}"/>
        ...
    </bean>
```

다음 예제는 자바에서 필요한 빈 구성을 보여준다:

`자바 구성`
```java
    @Bean
    @StepScope
    public ItemReader sampleReader(@Value("#{jobParameters[input.file.name]}") String resource) {
        ...
        FlatFileItemReader flatFileItemReader = new FlatFileItemReader();
        flatFileItemReader.setResource(new FileSystemResource(resource));
        ...
        return flatFileItemReader;
    }
```

위 예제에서 주요 관심사는 `#{jobParameters['input.file.name']}` 값을 리소스(Resource) 프로퍼티 값으로 주입하고 `아이템리더(ItemReader)` 빈이 스텝 스코프를 갖도록 설정하는 것이다. 스텝 스코프를 갖도록 빈을 설정하면, `jobParameters` 변수에 대한 접근할 수 있도록 레이트 바인딩(late binding)을 지원한다.


## 13.3. Available Attributes of the Job-Launching Gateway
잡 런칭 게이트웨이(The job-launching gateway)에는 잡을 제어하기 위해 설정할 수 있는 애트리뷰트가 있다:
- `id`: 다음 중 하나의 인스턴스인 기본 스프링 빈을 식별한다.
    - `이벤트드리븐컨슈머(EventDrivenConsumer)`
    - `폴링컨슈머(PollingConsumer)` (정확한 구현체는 컴포넌트의의 입력 채널이 `섭스크라이버블채널(SubscribableChannel)`인지 `폴러블채널(PollableChannel)`인지에 따라 달라진다.)
- `auto-startup`: 엔드포인트가 시작 시 자동으로 시작되어야 함을 나타내는 불 플래그이다. 기본값은 `true`이다.
- `request-channel`: 엔트포인트의 입력 `메세지채널(MessageChannel)`이다.
- `reply-channel`: 결과 `잡익스큐션(JobExecution)` 페이로드가 전송되는 `메세지채널(MessageChannel)`
- `reply-timeout`: 예외가 발생하기 전 이 게이트웨의 응답 메시지(reply message)가 응답 채널(reply channel)에 성공적으로 전송될 때까지 기다리는 시간(밀리초)을 지정할 수 있다. 이 애트리뷰트는 채널이 차단(예: 현재 가득 찬 제한된 큐 채널(queue channel)을 사용하려는 경우)될 수 있는 경우에만 적용된다. 또한, `다이렉트채널(DirectChannel)`로 전송할 때 발신자의 스레드에서 호출이 발생한다는 점을 명심하자. 따라서 전송 작업의 실패는 추가 다운스트림(downstream)의 다른 컴포넌트로 인해 발생할 수 있다. 응답 `reply-timeout` 애트리뷰트는 기본 `메세징템플릿(MessagingTemplate)` 인스턴스의 `sendTimeout` 프로퍼티에 매핑된다. 지정하지 않으면 애트리뷰트의의 기본값은 -1이며, 이는 기본적으로 게이트웨이가 무기한 대기함을 의미한다.
- `job-launcher`: 선택 값이다. 커스텀 `잡런처(JobLauncher)` 빈을 참조할 수있다. 지정하지 않으면 어댑터는 `jobLauncher` ID로 등록된 인스턴스를 재사용한다. 기본 인스턴스가 없으면 예외가 발생한다.
- `order`: 이 엔드포인트가 `섭스크라이버블채널(SubscribableChannel)`의 구독자(subscriber)로 연결될 때 구체적인 호출 순서를 지정한다.
