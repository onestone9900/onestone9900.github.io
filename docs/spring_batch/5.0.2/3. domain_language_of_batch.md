---
layout: default
title: 3. The Domain Language of Batch
parent: 5.0.2
grand_parent: SpringBatch
nav_order: 2
---

# The Domain Language of Batch
경험 많은 배치 아키텍트는, 스프링 배치에서 사용되는 배치 처리의 전반적인 개념이 익숙하고 편안해야 한다. "잡(Job)" 및 "스텝(Step)"과 ItemReader 및 ItemWriter라는 개발자에게 제공되는 처리 단위가 있다. 그러나 스프링의 패턴들, 작업(operation), 템플릿(template), 콜백(callback) 및 관용구를 익히면 다음과 같은 이점 있다.

- 명확한 관심사 분리를 준수하는 비율 크게 향상.
- 명확하게 기술된 아키텍처 계층 및 인터페이스로 제공되는 서비스.
- 신속하게 채택하고 즉시 사용할 수 있는 간단한 기본 구현.
- 대폭 향상된 확장성.

다음 다이어그램은 수십 년 동안 사용된 배치 참조 아키텍처의 단순한 버전이다. 배치 처리의 도메인 언어를 구성하는 구성 요소에 대한 개요이다. 이 아키텍처 프레임워크는 지난 몇 세대의 플랫폼(메인프레임의 코볼, 유닉스의 C, 이제 어디서나 사용하는 자바)에서 수십 년간 구현을 통해 입증된 청사진이다. JCL 및 코볼 개발자는 C, C# 및 자바 개발자만큼 개념에 익숙할 것이다. 스프링 배치는 매우 복잡한 요구 사항을 해결하기 위해, 인프라스트럭처 및 확장 기능으로 단순하거나 복잡한 배치 애플리케이션 생성을 처리하는 데 사용되는, 강력하고 유지 관리 가능한 시스템에서 일반적으로 발견되는 계층, 구성 요소 및 기술 서비스의 물리적 구현을 ​​제공한다.

![스프링배치](https://docs.spring.io/spring-batch/docs/current/reference/html/images/spring-batch-reference-model.png)
이미지 3. 배치 구성 요소

앞의 다이어그램은 스프링 배치의 도메인 언어를 구성하는 주요 개념들을 보여준다. 잡(Job)에는 하나 이상의 스텝(Step)이 있으며 각 단계에는 정확히 하나의 ItemReader, 하나의 ItemProcessor 및 하나의 ItemWriter가 있다. 잡을 시작 하고(JobLauncher 사용) 현재 실행 중인 프로세스에 대한 메타데이터를 저장(JobRepository에)해야 한다.


## 3.1. Job
이 섹션에서는 배치 잡(Job)의 개념과 관련된 고정관념(stereotypes)을 설명한다. 잡은 전체 배치 프로세스를 캡슐화하는 엔터티(entity)이다. 다른 스프링 프로젝트와 마찬가지로 잡은 XML 구성 파일 또는 자바-기반 구성과 함께 사용된다. 이 구성을 "잡 구성"이라 한다. 그러나, 잡은 다음 다이어그램과 같이, 전체 계층 구조에서 최상위일 뿐이다.

![스프링 배치](https://docs.spring.io/spring-batch/docs/current/reference/html/images/job-heirarchy.png)
이미지 4. 잡 계층

스프링 배치에서, `잡`은 단순히 `스텝` 인스턴스의 컨테이너이다. 논리적 흐름에 맞는 여러 스텝를 결합하고 다시 시작 가능성과 같은, 모든 단계에 전반적인 프로퍼티 구성을 허용한다. 잡 구성에는 다음이 포함된다.
- 잡 이름.
- `스텝` 인스턴스의 정의 및 순서 지정.
- 잡의 다시 시작 여부.

스프링 배치는 잡 위에 몇 가지 표준 기능을 생성하는 `SimpleJob` 클래스의 형태로 `Job` 인터페이스의 기본적인 구현(implementation)을 제공한다. 자바-기반 구성을 사용하는 경우, 다음 예제와 같이 빌더 모음을 `잡` 인스턴스화에 사용할 수 있다:
```
  @Bean
  public Job footballJob(JobRepository jobRepository) {
      return new JobBuilder("footballJob", jobRepository)
                       .start(playerLoad())
                       .next(gameLoad())
                       .next(playerSummarization())
                       .build();
  }
```

그러나, XML 구성을 사용하는 경우, 배치 네임스페이스는 이를 직접 인스턴스화할 필요성을 추상화한다. 대신 다음 예제와 같이 `<job>` 엘리먼트(element)를 사용할 수 있다:

```
  <job id="footballJob">
    <step id="playerload" next="gameLoad"/>
    <step id="gameLoad" next="playerSummarization"/>
    <step id="playerSummarization"/>
  </job>
```


### 3.1.1. JobInstance
`잡인스턴스(JobInstance)`는 논리적인 잡 실행 개념을 나타낸다. 이전 다이어그램의 `EndOfDay` `잡`과 같이, 하루가 끝날 때 한 번 실행되어야 하는 배치 잡을 생각해보자. `EndOfDay` 잡은 하나 있지만 각 개별 실행을 각각 추적해야 한다. 이 잡의 경우, 하루에 단 하나의 논리적 잡인스턴스가 있다. 예를 들어, 1월 1일 실행, 1월 2일 실행 등이 있다. 1월 1일 실행이 처음에 실패하고 다음날 다시 실행되면, 여전히 1월 1일 실행이다(일반적으로 이것은 처리 중인 데이터와도 일치한다. 즉, 1월 1일 실행이 1월 1일 데이터를 처리함을 의미한다.). 따라서, 각 잡인스턴스는 여러 번 실행될 수 있으며(잡익스큐션(JobExecution)은 이 장의 뒷부분에서 자세히 설명함), 주어진 시간에 하나의 잡인스턴스(특정 잡과 잡파라미터(JobParameters))만 실행할 수 있다.

`잡인스턴스`의 정의는 로드할 데이터와 전혀 관련이 없다. 데이터가 로드되는 방식을 결정하는 것은 전적으로 `ItemReader` 구현에 달려 있다. 예를 들어, `EndOfDay` 시나리오에서 데이터가 속한 `유효 날짜(effective date)` 또는 `일정 날짜(schedule date)`를 나타내는 데이터 열이 있을 수 있다. 따라서 1월 1일 실행은 1일의 데이터만 로드하고, 1월 2일 실행은 2일의 데이터만 사용한다. 이 결정은 비즈니스적인 결정일 가능성이 높으므로 `ItemReader`가 결정한다. 그러나 동일한 `잡인스턴스`를 사용하면 이전 실행 "상태" (즉, 이 장의 뒷부분에서 설명하는 익스큐션컨텍스트(ExecutionContext))의 사용여부가 결정된다. 새로운 잡인스턴스를 사용한다는 것은 "처음부터 시작"을 의미하고 기존 인스턴스를 사용한다는 것은 일반적으로 "중단한 부분부터 시작"을 의미한다.


### 3.1.2. JobParameters
`잡인스턴스`와 그것이 `잡`과 어떻게 다른지에 대해 논의한 후 자연스럽게 물어볼 질문은 다음과 같다: "하나의 잡인스턴스와 다른 잡인스턴스는 어떻게 구별되나?" 답은: `잡파라미터(JobParameters)`이다. `잡파라미터` 객체는 배치 잡을 시작하는 데 사용되는 매개 변수 집합을 가지고 있다. 다음 이미지와 같이 식별을 위해 사용하거나 실행 중에 참조 데이터로 사용할 수도 있다:

![잡파라미터](https://docs.spring.io/spring-batch/docs/current/reference/html/images/job-stereotypes-parameters.png)
이미지 5. 잡파라미터

앞의 예에서, 1월 1일에 대한 인스턴스와 1월 2일에 대한 두 개의 인스턴스가, 실제로는 하나의 잡이지만, 두 개의 잡파라미터 객체가 있다: 하나는 2017-01-01의 잡파라미터로 시작되었고 다른 하나는 2017-01-02의 잡파라미터로 시작되었다. 따라서 다음과 같이 정의할 수 있다: `잡인스턴스(JobInstance) = 잡(Job) + 잡파라미터(JobParameter)`. 이를 통해 개발자는 전달되는 파라미터를 제어하므로 잡인스턴스가 정의되는 방식을 효과적으로 제어할 수 있다.

{: .important}
>`잡인스턴스`를 식별하는 데 모든 잡파라미터가 필요한 것은 아니다. 기본적으로, 그렇게 한다. 그러나 프레임워크는 `잡인스턴스` 식별에 관련없는 파라미터를 사용하여 `잡`을 제출할 수도 있다.


### 3.1.3. JobExecution
`잡익스큐션(JobExecution)`은 잡을 실행하려는 단일 시도의 기술적 개념을 나타낸다. 익스큐션은 실패 또는 성공으로 종료될 수 있지만, 해당 익스큐션의 `잡인스턴스(JobInstance)`가 성공적하지 않으면, 완료된 것으로 간주되지 않는다. 앞에서 설명한 `EndOfDay 잡`을 예로 사용하여, 처음 실행했을 때 실패한 2017년 1월 1일의 `잡인스턴스`를 생각해 보자. 첫 번째 실행(2017-01-01)과 동일한 잡파라미터를 사용하여 다시 실행하면 새 `잡익스큐션`이 생성된다. 그러나 여전히 하나의 `잡인스턴스`만 있다.

잡은 잡이 무엇이고 어떻게 실행되는지 정의하며, 잡인스턴스는 잡익스큐션을 함께 그룹화하는 객체이며, 올바른 다시 시작 시맨틱(semantics)을 가능하게 한다. 그러나 잡익스큐션은 실행 중에 실제로 발생한 일에 대한 저장 메커니즘이며 다음 표와 같이 제어하고 유지해야 하는 더 많은 프로퍼티를 포함한다:

테이블 1. 잡익스큐션 프로퍼티
|프로퍼티|정의|
|---|---|
|`Status`|실행 상태를 나타내는 `BatchStatus` 객체. <br>실행 중에는 `BatchStatus#STARTED`이다. <br>실패하면 `BatchStatus#FAILED`이다. <br>성공적으로 완료되면 `BatchStatus#COMPLETED`이다.|
|`startTime`|실행이 시작된 현재 시스템 시간을 나타내는 `java.time.LocalDateTime`이다. 잡이 아직 시작되지 않은 경우 이 필드는 비어 있다.|
|`endTime`|성공 여부에 관계없이, 실행이 완료된 현재 시스템 시간을 나타내는 `java.time.LocalDateTime`이다. 잡이 아직 완료되지 않은 경우 필드가 비어 있다.|
|`exitStatus`|실행 결과를 나타내는, `ExitStatus`이다. 호출자에게 반환되는 종료 코드가 포함되어 있기 때문에 가장 중요하다. 자세한 내용은 5장을 참조하자. 잡이 아직 완료되지 않은 경우 필드가 비어 있다.|
|`createTime`|잡익스큐션이 처음 지속될 때 현재 시스템 시간을 나타내는 `java.time.LocalDateTime`이다. 잡이 아직 시작되지 않았을 수 있지만(따라서 시작 시간이 없음), 잡 수준에서 익스큐션컨텍스트(ExecutionContexts)를 관리하기 위해 프레임워크에 필요한 `createTime`이 항상 있다.|
|`lastUpdated`|`잡익스큐션`이 지속된 마지막 시간을 나타내는 `java.time.LocalDateTime`이다. 잡이 아직 시작되지 않은 경우 이 필드는 비어 있다.|
|`executionContext`|실행 간에 유지되어야 하는 사용자 데이터가 포함된 "프로퍼티 모음"이다.|
|`failureExceptions`|잡을 실행하는 동안 발생한 예외 목록이다. 잡이 실패하는 동안 둘 이상의 예외가 발생하는 경우 유용할 수 있다.|

이러한 프로퍼티는 지속되며 실행 상태를 결정할 수 있기 때문에 중요하다. 예를 들어, 01-01에 대한 `EndOfDay` 잡이 오후 9시에 실행되고 9시 30분에 실패하면, 배치 메타데이터 테이블에 다음 항목이 생성된다:


테이블 2. BATCH_JOB_INSTANCE
|JOB_INST_ID|JOB_NAME|
|---|---|
|1|EndOfDayJob|


테이블 3. BATCH_JOB_EXECUTION_PARAMS
|JOB_EXECUTION_ID|TYPE_CD|KEY_NAME|DATE_VAL|IDENTIFYING|
|---|---|---|---|---|
|1|DATE|schedule.Date|2017-01-01|TRUE


테이블 4. BATCH_JOB_EXECUTION
|JOB_EXEC_ID|JOB_INST_ID|START_TIME|END_TIME STATUS|
|---|---|---|---|
|1|1|2017-01-01 21:00|2017-01-01 21:30|FAILED|

{: .important}
>명확성과 형식을 맞추기 위해 열 이름이 축약되거나 제거됐을 수 있다.

이제 잡이 실패했으므로, "배치 윈도우"가 지금 닫혔고, 문제를 확인하는 데 밤을 샛다고 가정하자. 또한 배치 윈도우가 오후 9시에 시작한다고 가정하고, 잡이 01-01에 대해 다시 시작되어 잡이 중단된 지점부터 시작하여 9시 30분에 성공적으로 완료됐다. 지금은 다음 날이기 떄문에, 01-02 잡도 실행해야 하며, 9시 31분에 바로 시작되어 10시 30분에 정상적으로 한 시간 동안 완료됐다. 두 잡이 동일한 데이터에 접근하려고 시도하여 데이터베이스 수준에서 잠금 문제를 일으킬 가능성이 없는 한 하나의 잡인스턴스를 차례로 시작해야 한다는 요구 사항은 없다. 잡을 실행해야 하는 시기를 결정하는 것은 전적으로 스케줄러(scheduler)에게 달려 있다. 그것들은 별개의 잡인스턴스이기 때문에 스프링 배치는 동시에 실행되는 것을 막으려 하지 않는다(다른 잡인스턴스가 이미 실행 중일 때 동일한 잡인스턴스를 실행하려고 하면 JobExecutionAlreadyRunningException이 발생한다). 다음 표와 같이 잡인스턴스 및 잡파라미터 테이블에 추가 항목이 하나 있고 잡익스큐션 테이블에 두 개의 추가 항목이 있어야 한다.


테이블 5. BATCH_JOB_INSTANCE
|JOB_INST_ID|JOB_NAME|
|---|---|
|1|EndOfDayJob|
|2|EndOfDayJob|


테이블 6. BATCH_JOB_EXECUTION_PARAMS
|JOB_EXECUTION_ID|TYPE_CD|KEY_NAME|DATE_VAL|IDENTIFYING|
|---|---|---|---|---|
|1|DATE|schedule.Date|2017-01-01 00:00:00|TRUE|
|2|DATE|schedule.Date|2017-01-01 00:00:00|TRUE|
|3|DATE|schedule.Date|2017-01-02 00:00:00|TRUE|


테이블 7. BATCH_JOB_EXECUTION
|JOB_EXEC_ID|JOB_INST_ID|START_TIME|END_TIME STATUS|
|---|---|---|---|
|1|1|2017-01-01 21:00|2017-01-01 21:30|FAILED|
|2|1|2017-01-02 21:00|2017-01-02 21:30|COMPLETED|
|3|2|2017-01-02 21:31|2017-01-02 22:29|COMPLETED|


{: .important}
>명확성과 형식을 맞추기 위해 열 이름이 축약되거나 제거됐을 수 있다.

## 3.2. Step
`스텝(Step)`은 배치 잡의 독립적이고, 순차적인 단계를 캡슐화하는 도메인 객체이다. 따라서, 모든 `잡`은 하나 이상의 스텝으로 구성된다. `스텝`에는 배치 프로세스를 정의하고 제어하는 ​​데 필요한 모든 정보가 포함된다. 주어진 `스텝`의 내용은 `잡`을 작성하는 개발자의 생각을 따르기 때문에 위 설명은 조금 모호하다. `스텝`은 개발자가 원하는 만큼 간단하거나 복잡할 수 있다. 간단한 스텝은 파일에서 데이터베이스로 데이터를 로드할 수 있으며, 코드가 거의 또는 전혀(사용된 구현에 따라 다름) 필요하지 않다. 복잡한 `스텝`에는 프로세스의 일부로 적용되는 복잡한 비즈니스 규칙이 있을 수 있다. `잡`과 마찬가지로 `스텝`에는 다음 이미지와 같이 고유한 `잡익스큐션(JobExecution)`과 상관 관계가 있는 개별 `스텝익스큐션(StepExecution)`이 있다:

![스텝과 잡 계층](https://docs.spring.io/spring-batch/docs/current/reference/html/images/jobHeirarchyWithSteps.png)
이미지 6. 스텝과 잡 계층


### 3.2.1. StepExecution
`스텝익스큐션(StepExecution)`은 `스텝`을 실행하려는 하나의 시도를 나타낸다. `잡익스큐션`과 유사하게 스텝이 실행될 때마다 새 `스텝익스큐션`이 생성된다. 그러나, 이전 스텝이 실패하여 스텝이 실행되지 않으면 실행이 지속되지 않는다. `스텝익스큐션`은 `스텝`이 실제로 시작된 경우에만 생성된다. 

스텝의 실행은 `StepExecution` 클래스의 객체로 표시된다. 각 실행에는 해당 스텝 및 `잡익스큐션`에 대한 참조와 커밋 및 롤백 횟수, 시작 및 종료 시간과 같은 트랜잭션 관련 데이터가 포함된다. 또한 각 스텝의 실행에는 다시 시작하는 데 필요한 통계 또는 상태 정보와 같이 개발자가 배치 실행 간에 유지해야 하는 모든 데이터가 포함된 `익스큐션컨텍스트(ExecutionContext)`가 포함된다. 다음 표에는 `StepExecution`의 프로퍼티가 나열되어 있다.

테이블 8. StepExecution 프로퍼티

|Property|Definition|
|---|---|
|`Status`|실행 상태를 나타내는 `BatchStatus` 객체이다. <br>실행 중 상태는 `BatchStatus.STARTED`이다. <br>실패하면 상태는 `BatchStatus.FAILED`이다. <br>성공적으로 완료되면 상태는 `BatchStatus.COMPLETED`이다.<br>|
|`startTime`|실행된 현재 시스템 시간을 나타내는 `java.time.LocalDateTime` 스텝이 아직 시작되지 않은 경우 이 필드는 비어 있다.|
|`endTime`|성공 여부에 관계없이 실행이 완료된, 현재 시스템 시간을 나타내는 `java.time.LocalDateTime`이다. 스텝이 아직 종료되지 않은 경우 이 필드는 비어 있다.|
|`exitStatus`|실행 결과를 나타내는 `ExitStatus`이다. 호출자에게 반환되는 종료 코드가 포함되어 있기 때문에 가장 중요하다. 자세한 내용은 5장을 참조해보자. 잡이 아직 종료되지 않은 경우 이 필드는 비어 있다.|
|`executionContext`|실행 간에 유지되어야 하는 사용자 데이터가 포함된 "프로퍼티 모음"이다.|
|`readCount`|성공적으로 읽은 항목의 수이다.|
|`writeCount`|성공적으로 작성된 항목의 수이다.|
|`commitCount`|이 실행을 위해 커밋된 트랜잭션 수이다.|
|`rollbackCount`|스텝에서 제어하는 ​​비즈니스 트랜잭션이 롤백된 횟수이다.|
|`readSkipCount`|읽기 실패 횟수로, 스킵 항목이 발생했다.|
|`processSkipCount`|프로세스 실패 횟수로, 건너뛴 항목이 발생했다.|
|`filterCount`|ItemProcessor에 의해 "필터링"된 항목의 수이다.|
|`writeSkipCount`|쓰기 실패 횟수로, 건너뛴 항목이 발생했다.|