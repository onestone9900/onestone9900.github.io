---
layout: default
title: 6. ItemReaders and ItemWriters
parent: 5.0.2
grand_parent: SpringBatch
nav_order: 6
---


# 6. ItemReaders and ItemWriters
모든 배치 처리는 대량의 데이터를 읽고, 어떤 타입의 계산 또는 변환을 수행하고, 그 결과를 기록하는 것이라 설명할 수 있다. 스프링 배치는 대량 읽기 및 쓰기를 수행하는 데 도움이 되는 세 가지 주요 인터페이스를 제공한다: 아이템리더(ItemReader), 아이템프로세서(ItemProcessor), 그리고 아이템라이터(ItemWriter).


## 6.1. `ItemReader`
간단한 개념이지만, `아이템리더(ItemReader)`는 다양한 입력 타입의 데이터를 제공하는 수단이다. 가장 일반적인 예는 다음과 같다:

- 플랫 파일(Flat File): 플랫 파일 아이템리더는 일반적으로 파일의 고정된 위치에 정의되거나 일부 특수 문자(예: 쉼표)로 구분된 데이터 필드가 있는 레코드를 설명하는 플랫 파일에서 데이터 라인을 읽는다.
- XML: XML `아이템리더(ItemReader)`는 객체 파싱, 매핑 및 유효성 검사에 사용되는 기술과는 독립적으로 XML을 처리한다. 입력 데이터는 XSD 스키마에 대한 XML 파일의 유효성 검사를 허용한다.
- 데이터베이스(Database): 처리를 위해 객체에 매핑할 수 있는 리절트셋(resultset)을 반환하기 위해 데이터베이스 리소스에 접근한다. 기본 SQL `아이템리더` 구현체는 `로우매퍼(RowMapper)`를 호출하여 객체를 반환하고, 재시작이 필요한 경우 현재 로우을 추적하고, 기본 통계를 저장하고, 나중에 설명할 몇 가지 트랜잭션 향상 기능을 제공한다.

더 많은 상황이 있지만, 이 장에서는 기본적인 상황에 중점을 둔다. 사용 가능한 모든 `아이템리더(ItemReader)` 구현체의 전체 목록은 부록 A에서 찾을 수 있다.

`아이템리더(ItemReader)`는 다음 인터페이스에 표시된 것처럼, 일반 입력 작업을 위한 기본 인터페이스이다:
```
  public interface ItemReader<T> {
    T read() throws Exception, UnexpectedInputException, ParseException, NonTransientResourceException;
  }
```

`read` 메서드는 `아이템리더(ItemReader)`의 가장 필수적인 기능이다. 호출하면 하나의 아이템이 반환되거나 아이템이 더 이상 남아 있지 않으면 `null`이 반환된다. 아이템은 파일의 라인, 데이터베이스의 로우 또는 XML의 엘리먼트를 나타낼 수 있다. 일반적으로 사용 가능한 도메인 객체(예: `Trade`, `Foo` 또는 기타)에 매핑되는 것으로 예상되지만, 이 기능은 그럴 필요없다.

`아이템리더(ItemReader)` 인터페이스의 구현체는 다음 데이터를 읽는 기능만 가능할 것으로 예상된다. 그러나 리소스가 트랜잭션(예: JMS 대기열)인 경우 `read`를 호출하면 롤백 시나리오의 호출에서는 동일한 아이템이 반환될 수 있다. `아이템리더(ItemReader)`가 처리할 아이템이 부족해도 예외가 발생하지 않는다는 점도 주목할만하다. 예를 들어, 0개의 결과를 반환하는 쿼리로 구성된 데이터베이스 `아이템리더(ItemReader)`는 read의 첫 번째 호출에서 `null`을 반환한다.


## 6.2. `ItemWriter`
`아이템라이터(ItemWriter)`는 기능면에서 `아이템리더(ItemReader)`와 유사하지만 반대 작업이다. 리소스는 여전히 찾고(located), 열고, 닫아야 하지만 `아이템라이터(ItemWriter)`가 읽는 것이 아니라 써낸다는 점에서 다르다. 출력의 직렬화(serialization) 포맷은 각 배치 잡에 따라 다르다.

`아이템리더(ItemReader)`와 마찬가지로 `아이텝라이터(ItemWriter)`는 다음 인터페이스 정의와 같이 상당히 일반적인 인터페이스이다:
```
  public interface ItemWriter<T> {
    void write(Chunk<? extends T> items) throws Exception;
  }
```

`아이템리더(ItemReader)`에서 `read`와 마찬가지로 `write`는 아이템라이터(ItemWriter)의 기본 기능을 제공한다. 열려 있는 동안 전달된 아이템 리스트을 작성하려고 시도한다. 일반적으로 아이템이 청크 단위로 '배치'처리된 다음 출력되는 것으로 예상되기 때문에, 인터페이스는 아이템 단건이 아닌 아이템 리스트를 받는다. 리스트를 작성한 후, `write` 메서드가 반환하기 전에 필요할 경우 `flush`를 수행할 수 있다. 예를 들어, 하이버네이트 DAO에 작성하는 경우 각 아이템에 대해 하나씩 write가 여러번 호출될 수 있다. 그런 다음 라이터는 반환하기 전에 하이버네이트 세션에서 `flush`를 호출할 수 있다.


## 6.3. ItemStream
`아이템리더(ItemReader)`와 `아이템라이터(ItemWriter)`는 둘 다 개별 목적을 잘 수행하지만, 다른 인터페이스가 필요한 두 가지 상황이 있다. 일반적인 배치 작업의 일부로, 리더와 라이터를 열고 닫아야, 하며 상태를 유지하기 위한 메커니즘이 필요하다. `아이템스트림(ItemStream)` 인터페이스는 다음 예제와 같이 해당 용도로 사용된다:

```
  public interface ItemStream {
    void open(ExecutionContext executionContext) throws ItemStreamException;
    void update(ExecutionContext executionContext) throws ItemStreamException;
    void close() throws ItemStreamException;
  }
```

각 메서드를 설명하기 전에, `익스큐션컨텍스트(ExecutionContext)`를 언급해야 한다. `아이템스트림(ItemStream)`을 구현하는 `아이템리더(ItemReader)`의 클라이언트는 파일과 같은 리소스를 열거나, `read`를 호출하기 전에 `open`을 호출해야 한다. 유사한 제한이 `아이템스트림(ItemStream)`을 구현하는 아이템라이터(ItemWriter)에도 적용된다. 2장에서 언급했듯이, `익스큐션컨텍스트(ExecutionContext)`에서 기대했던 데이터가 발견되면, 초기 상태가 아닌 `아이템리더(ItemReader)` 또는 `아이템라이터(ItemWriter)`를 시작하는 데 사용될 수 있다. 반대로, `open` 중에 할당된 리소스가 안전하게 해제되도록 `close`를 호출한다. `update`는 주로 현재 보유 중인 모든 상태를 `익스큐션컨텍스트(ExecutionContext)`에 저장하기 위해 호출한다. 이 메서드는 커밋하기 전에, 현재 상태가 데이터베이스에 유지되도록 하기 위해 커밋하기 전에 호출된다.

`아이템스트림(ItemStream)`의 클라이언트가 (스프링 배치 코어에서) 스텝인 특수한 경우, 동일 `잡인스턴스(JobInstance)`가 다시 시작되면, `익스큐션컨텍스트(ExecutionContext)`는 각 `스텝익스큐션(StepExecution)`에 대해 특정 실행 상태를 저장하며, 그것이 반환된다. `쿼츠(Quartz)`에 익숙한 사용자의 경우 `잡데이터맵(JobDataMap)`과 매우 유사하다.


## 6.4. The Delegate Pattern and Registering with the Step
`컴포지트아이템라이터(CompositeItemWriter)`는 스프링 배치에서 일반적으로 사용되는 델리게이트(delegate) 패턴의 예시이다. 델리게이트 자체는 `스텝리스너(StepListener)`와 같은 콜백 인터페이스를 구현할 수 있다. `잡`에 `스텝`이 스프링 배치 코어와 함께 사용되는 경우, `스텝`에 수동 등록해야 한다. 스텝에 직접 연결된 리더(reader), 라이터(writer) 또는 프로세서(processor)는 `아이템스트림(ItemStream)` 또는 `스텝리스너(StepListener)` 인터페이스를 구현하는 경우 자동으로 등록된다. 그러나 델리게이트는 스텝에 알려지지 않았기 때문에 리스너 또는 스트림(또는 적절한 경우 둘 다)으로 주입되어야 한다.

다음 예제는 XML에서 델리게이트를 스트림으로 주입하는 방법을 보여준다:
`XML 구성`
```
  <job id="ioSampleJob">
    <step name="step1">
      <tasklet>
        <chunk reader="fooReader" processor="fooProcessor" writer="compositeItemWriter" commit-interval="2">
          <streams>
            <stream ref="barWriter" />
          </streams>
        </chunk>
      </tasklet>
    </step>
  </job>

  <bean id="compositeItemWriter" class="...CustomCompositeItemWriter">
    <property name="delegate" ref="barWriter" />
  </bean>

  <bean id="barWriter" class="...BarWriter" />
```

다음 예제는 자바에서 델리게이트를 주입하는 방법을 보여준다:
`자바 구성`
```
  @Bean
  public Job ioSampleJob(JobRepository jobRepository) {
    return new JobBuilder("ioSampleJob", jobRepository)
            .start(step1())
            .build();
  }

  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
    return new StepBuilder("step1", jobRepository)
                .<String, String>chunk(2, transactionManager)
                .reader(fooReader())
                .processor(fooProcessor())
                .writer(compositeItemWriter())
                .stream(barWriter())
                .build();
  }
  @Bean
  public CustomCompositeItemWriter compositeItemWriter() {
      CustomCompositeItemWriter writer = new CustomCompositeItemWriter();
      writer.setDelegate(barWriter());
      return writer;
  }

  @Bean
  public BarWriter barWriter() {
    return new BarWriter();
  }
```

## 6.5. Flat Files
대량 데이터를 교환하는 가장 일반적인 메커니즘 중 하나는 항상 플랫 파일이었다. 구조(XSD)을 정의하기 위한 합의된 표준이 있는 XML과 달리, 플랫 파일을 읽는 사람은 파일 구조를 정확히 미리 이해해야 한다. 일반적으로, 모든 플랫 파일은 구분된(delimited) 길이와 고정(fixed) 길이의 두 가지 타입으로 나뉜다. 구분된(Delimited) 파일은 필드가 쉼표와 같은 구분 기호로 구분된 파일이다. 고정(Fixed) 길이 파일에는 길이가 설정된 필드가 있다.


### 6.5.1. The `FieldSet`
스프링 배치에서 플랫 파일로 작업할 때, 입력용이든 출력용이든 상관없이 가장 중요한 클래스 중 하나는 `필드셋(FieldSet)`이다. 많은 아키텍처와 라이브러리에는 파일에서 읽는 데 도움이 되는 추상화가 포함되어 있지만, 일반적으로 스트링(String) 또는 스트링(String) 배열을 반환한다. 이제 절반 정도 알게 됐다. `필드셋(FieldSet)`은 파일 리소스에서 필드 바인딩을 활성화하기 위한 스프링 배치의 추상화이다. 개발자가 데이터베이스 입력으로 작업하는 것과 거의 동일한 방식으로 파일 입력을 작업할 수 있다. `필드셋(FieldSet)`은 개념적으로 JDBC `리절트셋(ResultSet)`와 유사하다. `필드셋(FieldSet)`에는 하나의 아규먼트(토큰의 문자열 배열)만 필요하다. 선택적으로, 예제와 같이 `필드셋(FieldSet)` 다음에 패턴화된 대로 인덱스 또는 이름으로 필드에 액세스할 수 있도록 필드 이름을 구성할 수도 있다.

```
  String[] tokens = new String[]{"foo", "1", "true"};
  FieldSet fs = new DefaultFieldSet(tokens);
  String name = fs.readString(0);
  int value = fs.readInt(1);
  boolean booleanValue = fs.readBoolean(2);
```
 
`필드셋(FieldSet)` 인터페이스에는 `Date`, `long`, `BigDecimal` 등과 같은 많은 옵션이 있다. `필드셋(FieldSet)`의 가장 큰 장점은 플랫 파일 입력에 대한 일관된 파싱 방식을 제공한다는 것이다. 각 배치 잡이 잠재적으로 예상치 못한 방식으로 다르게 파싱하는 대신, 형식(format) 예외로 인한 오류를 처리하거나, 간단한 데이터 변환을 수행할 때 모두 일관성을 유지할 수 있다.
