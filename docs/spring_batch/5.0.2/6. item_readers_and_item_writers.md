---
layout: default
title: 6. ItemReaders and ItemWriters
parent: 5.0.2
grand_parent: SpringBatch
nav_order: 6
---


# 6. ItemReaders and ItemWriters
모든 배치 처리는 대량의 데이터를 읽고, 어떤 타입의 계산 또는 변환을 수행하고, 그 결과를 기록하는 것이라 설명할 수 있다. 스프링 배치는 대량 읽기 및 쓰기를 수행하는 데 도움이 되는 세 가지 주요 인터페이스를 제공한다: 아이템리더(ItemReader), 아이템프로세서(ItemProcessor), 그리고 아이템라이터(ItemWriter).


## 6.1. `ItemReader`
간단한 개념이지만, `아이템리더(ItemReader)`는 다양한 입력 타입의 데이터를 제공하는 수단이다. 가장 일반적인 예는 다음과 같다:

- 플랫 파일(Flat File): 플랫 파일 아이템리더는 일반적으로 파일의 고정된 위치에 정의되거나 일부 특수 문자(예: 쉼표)로 구분된 데이터 필드가 있는 레코드를 설명하는 플랫 파일에서 데이터 라인을 읽는다.
- XML: XML `아이템리더(ItemReader)`는 객체 파싱, 매핑 및 유효성 검사에 사용되는 기술과는 독립적으로 XML을 처리한다. 입력 데이터는 XSD 스키마에 대한 XML 파일의 유효성 검사를 허용한다.
- 데이터베이스(Database): 처리를 위해 객체에 매핑할 수 있는 리절트셋(resultset)을 반환하기 위해 데이터베이스 리소스에 접근한다. 기본 SQL `아이템리더` 구현체는 `로우매퍼(RowMapper)`를 호출하여 객체를 반환하고, 재시작이 필요한 경우 현재 로우을 추적하고, 기본 통계를 저장하고, 나중에 설명할 몇 가지 트랜잭션 향상 기능을 제공한다.

더 많은 상황이 있지만, 이 장에서는 기본적인 상황에 중점을 둔다. 사용 가능한 모든 `아이템리더(ItemReader)` 구현체의 전체 목록은 부록 A에서 찾을 수 있다.

`아이템리더(ItemReader)`는 다음 인터페이스에 표시된 것처럼, 일반 입력 작업을 위한 기본 인터페이스이다:
```
  public interface ItemReader<T> {
    T read() throws Exception, UnexpectedInputException, ParseException, NonTransientResourceException;
  }
```

`read` 메서드는 `아이템리더(ItemReader)`의 가장 필수적인 기능이다. 호출하면 하나의 아이템이 반환되거나 아이템이 더 이상 남아 있지 않으면 `null`이 반환된다. 아이템은 파일의 라인, 데이터베이스의 로우 또는 XML의 엘리먼트를 나타낼 수 있다. 일반적으로 사용 가능한 도메인 객체(예: `Trade`, `Foo` 또는 기타)에 매핑되는 것으로 예상되지만, 이 기능은 그럴 필요없다.

`아이템리더(ItemReader)` 인터페이스의 구현체는 다음 데이터를 읽는 기능만 가능할 것으로 예상된다. 그러나 리소스가 트랜잭션(예: JMS 대기열)인 경우 `read`를 호출하면 롤백 시나리오의 호출에서는 동일한 아이템이 반환될 수 있다. `아이템리더(ItemReader)`가 처리할 아이템이 부족해도 예외가 발생하지 않는다는 점도 주목할만하다. 예를 들어, 0개의 결과를 반환하는 쿼리로 구성된 데이터베이스 `아이템리더(ItemReader)`는 read의 첫 번째 호출에서 `null`을 반환한다.


## 6.2. `ItemWriter`
`아이템라이터(ItemWriter)`는 기능면에서 `아이템리더(ItemReader)`와 유사하지만 반대 작업이다. 리소스는 여전히 찾고(located), 열고, 닫아야 하지만 `아이템라이터(ItemWriter)`가 읽는 것이 아니라 써낸다는 점에서 다르다. 출력의 직렬화(serialization) 포맷은 각 배치 잡에 따라 다르다.

`아이템리더(ItemReader)`와 마찬가지로 `아이텝라이터(ItemWriter)`는 다음 인터페이스 정의와 같이 상당히 일반적인 인터페이스이다:
```
  public interface ItemWriter<T> {
    void write(Chunk<? extends T> items) throws Exception;
  }
```

`아이템리더(ItemReader)`에서 `read`와 마찬가지로 `write`는 아이템라이터(ItemWriter)의 기본 기능을 제공한다. 열려 있는 동안 전달된 아이템 리스트을 작성하려고 시도한다. 일반적으로 아이템이 청크 단위로 '배치'처리된 다음 출력되는 것으로 예상되기 때문에, 인터페이스는 아이템 단건이 아닌 아이템 리스트를 받는다. 리스트를 작성한 후, `write` 메서드가 반환하기 전에 필요할 경우 `flush`를 수행할 수 있다. 예를 들어, 하이버네이트 DAO에 작성하는 경우 각 아이템에 대해 하나씩 write가 여러번 호출될 수 있다. 그런 다음 라이터는 반환하기 전에 하이버네이트 세션에서 `flush`를 호출할 수 있다.


## 6.3. ItemStream
`아이템리더(ItemReader)`와 `아이템라이터(ItemWriter)`는 둘 다 개별 목적을 잘 수행하지만, 다른 인터페이스가 필요한 두 가지 상황이 있다. 일반적인 배치 작업의 일부로, 리더와 라이터를 열고 닫아야, 하며 상태를 유지하기 위한 메커니즘이 필요하다. `아이템스트림(ItemStream)` 인터페이스는 다음 예제와 같이 해당 용도로 사용된다:

```
  public interface ItemStream {
    void open(ExecutionContext executionContext) throws ItemStreamException;
    void update(ExecutionContext executionContext) throws ItemStreamException;
    void close() throws ItemStreamException;
  }
```

각 메서드를 설명하기 전에, `익스큐션컨텍스트(ExecutionContext)`를 언급해야 한다. `아이템스트림(ItemStream)`을 구현하는 `아이템리더(ItemReader)`의 클라이언트는 파일과 같은 리소스를 열거나, `read`를 호출하기 전에 `open`을 호출해야 한다. 유사한 제한이 `아이템스트림(ItemStream)`을 구현하는 아이템라이터(ItemWriter)에도 적용된다. 2장에서 언급했듯이, `익스큐션컨텍스트(ExecutionContext)`에서 기대했던 데이터가 발견되면, 초기 상태가 아닌 `아이템리더(ItemReader)` 또는 `아이템라이터(ItemWriter)`를 시작하는 데 사용될 수 있다. 반대로, `open` 중에 할당된 리소스가 안전하게 해제되도록 `close`를 호출한다. `update`는 주로 현재 보유 중인 모든 상태를 `익스큐션컨텍스트(ExecutionContext)`에 저장하기 위해 호출한다. 이 메서드는 커밋하기 전에, 현재 상태가 데이터베이스에 유지되도록 하기 위해 커밋하기 전에 호출된다.

`아이템스트림(ItemStream)`의 클라이언트가 (스프링 배치 코어에서) 스텝인 특수한 경우, 동일 `잡인스턴스(JobInstance)`가 다시 시작되면, `익스큐션컨텍스트(ExecutionContext)`는 각 `스텝익스큐션(StepExecution)`에 대해 특정 실행 상태를 저장하며, 그것이 반환된다. `쿼츠(Quartz)`에 익숙한 사용자의 경우 `잡데이터맵(JobDataMap)`과 매우 유사하다.


## 6.4. The Delegate Pattern and Registering with the Step
`컴포지트아이템라이터(CompositeItemWriter)`는 스프링 배치에서 일반적으로 사용되는 델리게이트(delegate) 패턴의 예시이다. 델리게이트 자체는 `스텝리스너(StepListener)`와 같은 콜백 인터페이스를 구현할 수 있다. `잡`에 `스텝`이 스프링 배치 코어와 함께 사용되는 경우, `스텝`에 수동 등록해야 한다. 스텝에 직접 연결된 리더(reader), 라이터(writer) 또는 프로세서(processor)는 `아이템스트림(ItemStream)` 또는 `스텝리스너(StepListener)` 인터페이스를 구현하는 경우 자동으로 등록된다. 그러나 델리게이트는 스텝에 알려지지 않았기 때문에 리스너 또는 스트림(또는 적절한 경우 둘 다)으로 주입되어야 한다.

다음 예제는 XML에서 델리게이트를 스트림으로 주입하는 방법을 보여준다:
`XML 구성`
```
  <job id="ioSampleJob">
    <step name="step1">
      <tasklet>
        <chunk reader="fooReader" processor="fooProcessor" writer="compositeItemWriter" commit-interval="2">
          <streams>
            <stream ref="barWriter" />
          </streams>
        </chunk>
      </tasklet>
    </step>
  </job>

  <bean id="compositeItemWriter" class="...CustomCompositeItemWriter">
    <property name="delegate" ref="barWriter" />
  </bean>

  <bean id="barWriter" class="...BarWriter" />
```

다음 예제는 자바에서 델리게이트를 주입하는 방법을 보여준다:
`자바 구성`
```
  @Bean
  public Job ioSampleJob(JobRepository jobRepository) {
    return new JobBuilder("ioSampleJob", jobRepository)
            .start(step1())
            .build();
  }

  @Bean
  public Step step1(JobRepository jobRepository, PlatformTransactionManager transactionManager) {
    return new StepBuilder("step1", jobRepository)
                .<String, String>chunk(2, transactionManager)
                .reader(fooReader())
                .processor(fooProcessor())
                .writer(compositeItemWriter())
                .stream(barWriter())
                .build();
  }
  @Bean
  public CustomCompositeItemWriter compositeItemWriter() {
      CustomCompositeItemWriter writer = new CustomCompositeItemWriter();
      writer.setDelegate(barWriter());
      return writer;
  }

  @Bean
  public BarWriter barWriter() {
    return new BarWriter();
  }
```

## 6.5. Flat Files
대량 데이터를 교환하는 가장 일반적인 메커니즘 중 하나는 항상 플랫 파일이었다. 구조(XSD)을 정의하기 위한 합의된 표준이 있는 XML과 달리, 플랫 파일을 읽는 사람은 파일 구조를 정확히 미리 이해해야 한다. 일반적으로, 모든 플랫 파일은 구분된(delimited) 길이와 고정(fixed) 길이의 두 가지 타입으로 나뉜다. 구분된(Delimited) 파일은 필드가 쉼표와 같은 구분 기호로 구분된 파일이다. 고정(Fixed) 길이 파일에는 길이가 설정된 필드가 있다.


### 6.5.1. The `FieldSet`
스프링 배치에서 플랫 파일로 작업할 때, 입력용이든 출력용이든 상관없이 가장 중요한 클래스 중 하나는 `필드셋(FieldSet)`이다. 많은 아키텍처와 라이브러리에는 파일에서 읽는 데 도움이 되는 추상화가 포함되어 있지만, 일반적으로 스트링(String) 또는 스트링(String) 배열을 반환한다. 이제 절반 정도 알게 됐다. `필드셋(FieldSet)`은 파일 리소스에서 필드 바인딩을 활성화하기 위한 스프링 배치의 추상화이다. 개발자가 데이터베이스 입력으로 작업하는 것과 거의 동일한 방식으로 파일 입력을 작업할 수 있다. `필드셋(FieldSet)`은 개념적으로 JDBC `리절트셋(ResultSet)`와 유사하다. `필드셋(FieldSet)`에는 하나의 아규먼트(토큰의 문자열 배열)만 필요하다. 선택적으로, 예제와 같이 `필드셋(FieldSet)` 다음에 패턴화된 대로 인덱스 또는 이름으로 필드에 액세스할 수 있도록 필드 이름을 구성할 수도 있다.

```
  String[] tokens = new String[]{"foo", "1", "true"};
  FieldSet fs = new DefaultFieldSet(tokens);
  String name = fs.readString(0);
  int value = fs.readInt(1);
  boolean booleanValue = fs.readBoolean(2);
```
 
`필드셋(FieldSet)` 인터페이스에는 `Date`, `long`, `BigDecimal` 등과 같은 많은 옵션이 있다. `필드셋(FieldSet)`의 가장 큰 장점은 플랫 파일 입력에 대한 일관된 파싱 방식을 제공한다는 것이다. 각 배치 잡이 잠재적으로 예상치 못한 방식으로 다르게 파싱하는 대신, 형식(format) 예외로 인한 오류를 처리하거나, 간단한 데이터 변환을 수행할 때 모두 일관성을 유지할 수 있다.


### 6.5.2. `FlatFileItemReader`
플랫 파일은 최대 2차원(표 형식) 데이터를 가진 모든 파일이다. 스프링 배치 프레임워크에서 플랫 파일 읽기는, 플랫 파일을 읽기 및 파싱 기능을 제공하는 `플랫파일아이템리더(FlatFileItemReader)` 클래스에 의해 작동한다. `플랫파일아이템리더(FlatFileItemReader)`의 가장 중요한 두 가지 필수 의존성은 `리소스(Resource)` 및 `라인매퍼(LineMapper)`이다. `라인매퍼(LineMapper)` 인터페이스는 다음 장에서 자세히 살펴보자. 리소스 프로퍼티는 스프링 코어 `리소스`를 나타낸다. 이 타입의 빈을 생성하는 방법을 설명하는 문서는 [스프링 프레임워크, 5장](https://docs.spring.io/spring-framework/reference/core/resources.html)에서 찾을 수 있다. 따라서, 이 가이드에서는 다음과 같은 간단한 예제를 보여주는 것 이상으로 `리소스(Resource)` 객체 생성에 대해 자세히 다루지 않는다:

```
  Resource resource = new FileSystemResource("resources/trades.csv");
```

복잡한 배치 환경에서, 디렉터리 구성은, FTP에서 배치 처리로 또는 그 반대로 파일을 이동하기 위해 외부 인터페이스용 드롭 영역(drop zones)이 설정되는, EAI(Enterprise Application Integration) 인프라에 의해 관리되는 경우가 많다. 파일 이동 유틸리티는 스프링 배치 아키텍처의 범위를 벗어나지만, 배치 잡 스트림(job stream)이 파일 이동 유틸리티를 스텝으로 포함하는 것은 자주 있는 일이다. 배치 아키텍처는 처리할 파일을 찾는 방법만 알면 된다. 스프링 배치는 이 시작점에서 파이프로 데이터를 공급하는 프로세스를 시작한다. 그러나, [스프링 인테그레이션(Integration)](https://spring.io/projects/spring-integration)은 이러한 타입의 서비스를 많이 제공한다.


`플랫파일아이템리더(FlatFileItemReader)`의 다른 프로퍼티스를 사용하면, 다음 테이블에 설명된 대로 데이터 해석 방법을 추가로 지정할 수 있다:

테이블 15. `플랫파일아이템리더(FlatFileItemReader)` 프로퍼티스

|Property|Type|Description|
|---|---|---|
|comments|String[]|코멘트 로우를 나타내는 라인의 접두사를 지정한다.|
|encoding|String|사용할 텍스트 인코딩을 지정한다. 기본값은 UTF-8이다.|
|lineMapper|`LineMapper`|문자열을 아이템을 나타내는 객체로 변환한다.|
|linesToSkip|int|파일 상단부터 무시할 줄 수이다.|
|recordSeparatorPolicy|RecordSeparatorPolicy|줄 끝이 어딘지 확인하고 인용된 문자열 내부에 있는 경우 줄 끝에서 진행하는 것과 같은 작업을 수행한다.|
|resource|`Resource`|읽을 리소스이다.|
|skippedLinesCallback|LineCallbackHandler|파일에서 건너뛸 라인의 로우(raw) 내용을 전달하는 인터페이스이다. linesToSkip이 2로 설정되면 이 인터페이스가 두 번 호출된다.|
|strict|boolean|스트릭트 모드(strict mode)에서, 리더(reader)는 입력 리소스가 존재하지 않는 경우 `익스큐션컨텍스트(ExecutionContext)`에서 예외를 발생시킨다. 그렇지 않으면, 문제를 기록하고 진행한다.|

#### `LineMapper`
`리절트셋(ResultSet)`과 같은, 로우 레벨 구성을 사용하고 `객체`를 반환하는, `로우매퍼(RowMapper)`와 마찬가지로 플랫 파일 처리에는 다음 인터페이스 정의에 표시된 것처럼, 스트링(String) 라인을 객체로 변환하는 구성이 필요하다:

```
 public interface LineMapper<T> {
    T mapLine(String line, int lineNumber) throws Exception;
  }
```

기본 기능은, 현재 라인과 연결된 라인 번호가 주어지면, 매퍼가 결과 도메인 객체(resulting domain object)를 반환해야 한다는 것이다. 이것은 `리절트셋(ResultSet)`의 각 라인이 라인 번호에 연결되어 있는 것처럼 각 라인이 해당 라인 번호와 연결된다는 점에서 `로우매퍼(RowMapper)`와 유사하다. 이를 통해 동일성(identity) 비교 또는 유익한 로깅을 위해 라인 번호를 결과 도메인 객체에 연결할 수 있다. 그러나, 위에서 설명한 것처럼, `로우매퍼(RowMapper)`와 달리, `라인매퍼(LineMapper)`에는 절반만 기능을 하는 원시 라인으로 제공된다. 라인은 이 문서의 뒷부분에 설명된 대로, 객체에 매핑될 수 있는 `필드셋(FieldSet)`으로 토큰화되어야 한다.


#### `LineTokenizer`
`필드셋(FieldSet)`으로 변환해야 하는 플랫 파일 데이터 형식이 많을 수 있으므로 입력 라인을 `필드셋(FieldSet)`으로 전환하기 위한 추상화가 필요하다. 스프링 배치에서 이 인터페이스를 `라인토크나이저(LineTokenizer)`라 한다:

```
  public interface LineTokenizer {
    FieldSet tokenize(String line);
  }
```

`라인토크나이저(LineTokenizer)`의 기능은, 입력 라인이 주어지면(이론적으로 스트링(String)은 둘 이상의 라인을 포함할 수 있음) 해당 라인을 나타내는 `필드셋(FieldSet)`이 반환되는 것과 같다. 이 `필드셋(FieldSet)`은 `필드셋매퍼(FieldSetMapper)`에 전달될 수 있다. 스프링 배치는 다음 라인토크나이저(LineTokenizer) 구현체를 가지고 있다:
- `디리미티드라인토크나이저(DelimitedLineTokenizer)`: 레코드의 필드가 구분 기호(delimiter)로 구분되는 파일에 사용된다. 가장 일반적인 구분 기호는 쉼표(,)이지만, 파이프(|)나 세미콜론(;)도 자주 사용된다.
- `픽스드렝스토크나이저(FixedLengthTokenizer)`: 레코드의 필드가 각각 "고정 너비"인 파일에 사용된다. 각 레코드 유형에 대해 각 필드의 너비를 정의해야 한다.
- `패턴매칭컴포지트라인토크나이저(PatternMatchingCompositeLineTokenizer)`: 패턴을 확인하여 토크나이저 목록 중 특정 라인에서 사용해야 하는 `라인토크나이저(LineTokenizer)`를 결정한다.


#### `FieldSetMapper`
`필드셋매퍼(FieldSetMapper)` 인터페이스는 `필드셋(FieldSet)` 객체를 가져오고 내용을 객체에 매핑하는 메서드인 `mapFieldSet`를 정의한다. 이 객체는 잡의 필요에 따라, 커스텀 DTO, 도메인 객체 또는 배열일 수 있다. `필드셋매퍼(FieldSetMapper)`는 `라인토크나이저(LineTokenizer)`와 함께 사용되어, 다음 인터페이스 정의된 것처럼, 리소스의 데이터 라인을 원하는 타입의 객체로 변환한다:

```
 public interface FieldSetMapper<T> {
    T mapFieldSet(FieldSet fieldSet) throws BindException;
  }
```

사용 패턴은 `JdbcTemplate`에서 사용하는 `로우매퍼(RowMapper)`와 동일하다.


#### `DefaultLineMapper`
이제 플랫 파일을 읽기 위한 기본 인터페이스가 정의되었으므로, 세 가지 단계가 필요하다는 것이 분명해졌다:
1. 파일에서 한 줄 읽는다.
2. 스트링(String) 라인을 `LineTokenizer#tokenize()` 메서드에 전달하여 `필드셋(FieldSet)`을 검색한다.
3. 토큰화 후 반환된 `필드셋(FieldSet)`을 `필드셋매퍼(FieldSetMapper)`에 전달하고, `ItemReader#read()` 메서드의 결과를 반환한다.


위에서 설명한 두 인터페이스는 라인을 `필드셋(FieldSet)`으로 변환하고 `필드셋(FieldSet)`을 도메인 객체에 매핑하는 두 가지 개별 작업을 나타낸다. `라인토크나이저(LineTokenizer)`의 입력은 `라인매퍼(LineMapper)`(라인)의 입력과 일치하고, `필드셋매퍼(FieldSetMapper)`의 출력은 `라인매퍼(LineMapper)`의 출력과 일치하므로 `라인토크나이저(LineTokenizer)`와 `필드셋매퍼(FieldSetMapper)`를 모두 사용하는 구현체가 제공된다. 다음 클래스 정의에 표시된, `디폴트라인매퍼(DefaultLineMapper)`는 대부분의 사용자에게 필요한 동작들이 만들어져 있다:

```
  public class DefaultLineMapper<T> implements LineMapper<>, InitializingBean {
    private LineTokenizer tokenizer;
    private FieldSetMapper<T> fieldSetMapper;

    public T mapLine(String line, int lineNumber) throws Exception {
      return fieldSetMapper.mapFieldSet(tokenizer.tokenize(line));
    }

    public void setLineTokenizer(LineTokenizer tokenizer) {
      this.tokenizer = tokenizer;
    }

    public void setFieldSetMapper(FieldSetMapper<T> fieldSetMapper) {
      this.fieldSetMapper = fieldSetMapper;
    } 
  }
```

위의 기능은 특히 원시 라인에 대한 접근이 필요한 경우, 사용자가 파싱 프로세스 제어 시 유연성 주기위해 리더(reader) 자체에 내장되지 않고(이전 버전의 프레임워크에서 수행된 것처럼) 기본 구현체로 제공된다.


#### Simple Delimited File Reading Example
다음 예는 실제 도메인 시나리오로 플랫 파일을 읽는 방법을 보여준다. 이 특정 배치 잡은 다음 파일에서 축구 선수를 읽는다:

```
  ID,lastName,firstName,position,birthYear,debutYear
  "AbduKa00,Abdul-Jabbar,Karim,rb,1974,1996",
  "AbduRa00,Abdullah,Rabih,rb,1975,1999",
  "AberWa00,Abercrombie,Walter,rb,1959,1982",
  "AbraDa00,Abramowicz,Danny,wr,1945,1967",
  "AdamBo00,Adams,Bob,te,1946,1969",
  "AdamCh00,Adams,Charlie,wr,1979,2003"
```

이 파일의 내용은 다음 `플레이어(Player)` 도메인 객체에 매핑된다:
```
  public class Player implements Serializable {
    private String ID;
    private String lastName;
    private String firstName;
    private String position;
    private int birthYear;
    private int debutYear;

    public String toString() {
      return "PLAYER:ID=" + ID + ",Last Name=" + lastName +
          ",First Name=" + firstName + ",Position=" + position +
          ",Birth Year=" + birthYear + ",DebutYear=" +
          debutYear;
    }

    // setters and getters...
  }
```

`필드셋(FieldSet)`을 `플레이어(Player)` 객체에 매핑하려면, 다음 예제와 같이 플레이어를 반환하는 `필드셋매퍼(FieldSetMapper)`를 정의해야 한다:
```
 protected static class PlayerFieldSetMapper implements FieldSetMapper<Player> {
    public Player mapFieldSet(FieldSet fieldSet) {
      Player player = new Player();
      
      player.setID(fieldSet.readString(0));
      player.setLastName(fieldSet.readString(1));
      player.setFirstName(fieldSet.readString(2));
      player.setPosition(fieldSet.readString(3));
      player.setBirthYear(fieldSet.readInt(4));
      player.setDebutYear(fieldSet.readInt(5));

      return player;
    }
  }
```

그러면 다음 예제와 같이 `플랫파일아이템리더(FlatFileItemReader)`를 올바르게 구성하고 `read`를 호출하여 파일을 읽을 수 있다;
```
  FlatFileItemReader<Player> itemReader = new FlatFileItemReader<>();
  itemReader.setResource(new FileSystemResource("resources/players.csv"));
  DefaultLineMapper<Player> lineMapper = new DefaultLineMapper<>();
  //디리미티드라인토크나이저(DelimitedLineTokenizer)는 기본적으로 구분 기호(delimiter)로 쉼표(,)를 사용한다.
  lineMapper.setLineTokenizer(new DelimitedLineTokenizer());
  lineMapper.setFieldSetMapper(new PlayerFieldSetMapper());
  itemReader.setLineMapper(lineMapper);
  itemReader.open(new ExecutionContext());

  Player player = itemReader.read();
```
`read`를 호출할 때마다 파일의 각 줄에서 새 `플레이어(Player)` 개체를 반환한다. 파일 끝에 도달하면 null이 반환된다.


#### Mapping Fields by Name
`디리미티드라인토크나이저(DelimitedLineTokenizer)` 및 `픽스드렝스토크나이저(FixedLengthTokenizer)` 모두 허용되고 기능이 JDBC `리졸트셋(ResultSet)`과 유사한 추가 기능이 하나 있다. 필드명은 매핑 함수의 가독성을 높이기 위해 `라인토크나이저(LineTokenizer)` 구현체 중 하나에 주입될 수 있다. 먼저, 다음 예제와 같이 플랫 파일에 있는 모든 필드의 컬럼명이 토크나이저에 주입된다:

```
  tokenizer.setNames(new String[] {"ID", "lastName", "firstName", "position", "birthYear", "debutYear"});
```

`필드셋매퍼(FieldSetMapper)`는 이 정보를 다음과 같이 사용할 수 있다:
```
  public class PlayerMapper implements FieldSetMapper<Player> {
    public Player mapFieldSet(FieldSet fs) {
      if (fs == null) {
        return null;
      }

      Player player = new Player();

      player.setID(fs.readString("ID"));
      player.setLastName(fs.readString("lastName"));
      player.setFirstName(fs.readString("firstName"));
      player.setPosition(fs.readString("position"));
      player.setDebutYear(fs.readInt("debutYear"));
      player.setBirthYear(fs.readInt("birthYear"));

      return player;
    }
  }
```


#### Automapping FieldSets to Domain Objects
많은 사람들에게, 특정 `필드셋매퍼(FieldSetMapper)`를 작성해야 하는 것은 `JdbcTemplate`에 대한 특정 `로우매퍼(RowMapper)`를 작성하는 것만큼 번거롭다. 스프링 배치는 자바빈(JavaBean) 사양을 사용하여 객체의 setter와 필드명을 일치시켜 필드를 자동으로 매핑하는 `필드셋매퍼(FieldSetMapper)`를 제공하여 이를 더 쉽게 만든다.

축구 예제를 ​​다시 사용하면, `빈래퍼파일셋매퍼(BeanWrapperFieldSetMapper)` 구성은 XML에서 다음 스니펫으로 보여준다:

`XML 구성`
```
  <bean id="fieldSetMapper" class="org.springframework.batch.item.file.mapping.BeanWrapperFieldSetMapper">
    <property name="prototypeBeanName" value="player" />
  </bean>
  <bean id="player"
        class="org.springframework.batch.sample.domain.Player"
        scope="prototype" />
```

축구 예제를 ​​다시 사용하면, `빈래퍼파일셋매퍼(BeanWrapperFieldSetMapper)` 구성은 자바에서 다음 스니펫으로 보여준다:
`자바 구성`
```
  @Bean
  public FieldSetMapper fieldSetMapper() {
    BeanWrapperFieldSetMapper fieldSetMapper = new BeanWrapperFieldSetMapper();
    fieldSetMapper.setPrototypeBeanName("player");
    return fieldSetMapper;
  }
  
  @Bean
  @Scope("prototype")
  public Player player() {
    return new Player();
  }
```

`필드셋(FieldSet)`의 각 아이템에 대해 매퍼는 스프링 컨테이너가 프로퍼티명과 일치하는 setter를 찾는 것과 같은 방식으로 플레이어(Player) 객체의 새 인스턴스에서 해당 setter를 찾는다(이러한 이유로 프로토타입 스코프가 필요함). `필드셋(FieldSet)`에서 사용 가능한 각 필드가 매핑되고, 코드를 작성하지 않고도, `플레이어(Player)` 객체가 반환된다.


#### Fixed Length File Formats
지금까지, 구분된(delimited) 파일에 대해서만 자세히 설명했다. 그러나 이것은 파일 읽기의 절반만 보여준 것이다. 플랫 파일을 사용하는 많은 조직에서는 고정 길이 형식(fixed length file)을 사용한다. 고정 길이 파일의 예는 다음과 같다.

```
  UK21341EAH4121131.11customer1
  UK21341EAH4221232.11customer2
  UK21341EAH4321333.11customer3
  UK21341EAH4421434.11customer4
  UK21341EAH4521535.11customer5
```

이것은 하나의 큰 필드처럼 보이지만 실제로는 4개의 개별 필드를 나타낸다:
1. ISIN: 주문 항목의 고유 식별자 - 12자 길이
2. Quantity: 주문할 항목의 번호 - 3자 길이.
3. Price: 아이템 가격 - 5자 길이.
4. Customer: 아이템을 주문하는 고객 ID - 9자 길이.
`픽스드렝스라인토크나이저(FixedLengthLineTokenizer)`를 구성할 때, 이러한 각 길이는 범위 형식으로 제공된다.

다음 예는 XML에서 `픽스드렝스라인토크나이저(FixedLengthLineTokenizer)`의 범위를 정의하는 방법을 보여준다:
`XML 구성`
```
  <bean id="fixedLengthLineTokenizer" class="org.springframework.batch.item.file.transform.FixedLengthTokenizer">
    <property name="names" value="ISIN,Quantity,Price,Customer" />
    <property name="columns" value="1-12, 13-15, 16-20, 21-29" />
  </bean>
```

`픽스드렝스라인토크나이저(FixedLengthLineTokenizer)`는 앞에서 설명한 것과 동일한 `라인토크나이저(LineTokenizer)` 인터페이스를 사용하므로, 구분 기호(delimiter)가 사용된 것처럼 동일한 `필드셋(FieldSet)`을 반환한다. 이를 통해 `빈래퍼필드셋매퍼(BeanWrapperFieldSetMapper)`를 사용하는 것과 같은 출력 처리와 같은 접근 방식을 사용할 수 있다.

{: .important}
>범위에 대한 앞의 구문을 지원하려면 특수 프로퍼티 에디터인 `레인지어레이프로퍼티에디터(RangeArrayPropertyEditor)`가 `어플리케이션컨텍스트(ApplicationContext)`에  구성되어 있어야 한다. 그러나, 이 빈은 배치(batch) 네임스페이스가 사용되는 `어플리케이션컨텍스트(ApplicationContext)`에 자동으로 선언된다

다음 예는 자바에서 `픽스드렝스라인토크나이저(FixedLengthLineTokenizer)`의 범위를 정의하는 방법을 보여준다:
`자바 구성`
```
  @Bean
  public FixedLengthTokenizer fixedLengthTokenizer() {
    FixedLengthTokenizer tokenizer = new FixedLengthTokenizer();
    tokenizer.setNames("ISIN", "Quantity", "Price", "Customer");
    tokenizer.setColumns(new Range(1, 12),
                        new Range(13, 15),
                        new Range(16, 20),
                        new Range(21, 29));

    return tokenizer;
  }
```

`픽스드렝스라인토크나이저(FixedLengthLineTokenizer)`는 위에서 설명한 것과 동일한 `라인토크나이저(LineTokenizer)` 인터페이스를 사용하므로, 구분 기호(delimiter)가 사용된 것처럼 동일한 `필드셋(FieldSet)`을 반환한다. 를 통해 `빈래퍼필드셋매퍼(BeanWrapperFieldSetMapper)`를 사용하는 것과 같은 출력 처리와 같은 접근 방식을 사용할 수 있다.


#### Multiple Record Types within a Single File
지금까지 파일 읽기 예제 단순화를 위해 모든 레코드는 동일한 형식을 가진다는 가정을 했다. 그러나, 항상 그런 것은 아니다. 일반적으로 파일에 다르게 토큰화하고 다른 객체에 매핑해야 하는 형식의 레코드가 있을 수 있따. 다음은 파일의 내용이다:
```
  USER;Smith;Peter;;T;20014539;F
  LINEA;1044391041ABC037.49G201XX1383.12H
  LINEB;2134776319DEF422.99M005LI
```

이 파일에는 "USER", "LINEA" 및 "LINEB"의 세 가지 유형의 레코드가 있다. "USER" 라인은 `유저(User)` 객체에 해당한다. "LINEA"와 "LINEB"는 둘 다 `라인(Line)` 객체에 해당하지만, "LINEA"는 "LINEB"보다 더 많은 정보를 가지고 있다. 

`아이템리더(ItemReader)`는 각 라인을 개별적으로 읽지만, `아이템라이터(ItemWriter)`가 올바른 아이템을 수신하도록 서로 다른 `라인토크나이저(LineTokenizer)` 및 `필드셋매퍼(FieldSetMapper)` 객체를 지정해야 한다. `패턴와칭컴포짓라인매퍼(PatternMatchingCompositeLineMapper)`를 사용하면 `라인토크나이저(LineTokenizer)`에 대한 패턴 맵(map)과 필드셋매퍼(FieldSetMapper)에 대한 패턴을 구성할 수 있으므로 이를 쉽게 수행할 수 있다.

다음 예에서는 XML에서 `픽스드렝스라인토크나이저(FixedLengthLineTokenizer)`의 범위를 정의하는 방법을 보여준다:
`XML 구성`
```
  <bean id="orderFileLineMapper" class="org.spr...PatternMatchingCompositeLineMapper">
    <property name="tokenizers">
      <map>
        <entry key="USER*" value-ref="userTokenizer" />
        <entry key="LINEA*" value-ref="lineATokenizer" />
        <entry key="LINEB*" value-ref="lineBTokenizer" />
      </map>
    </property>
    <property name="fieldSetMappers">
      <map>
        <entry key="USER*" value-ref="userFieldSetMapper" />
        <entry key="LINE*" value-ref="lineFieldSetMapper" />
      </map>
    </property>
  </bean>
```

`자바 구성`
```
  @Bean
  public PatternMatchingCompositeLineMapper orderFileLineMapper() {
      PatternMatchingCompositeLineMapper lineMapper = new PatternMatchingCompositeLineMapper();

      Map<String, LineTokenizer> tokenizers = new HashMap<>(3);
      tokenizers.put("USER*", userTokenizer());
      tokenizers.put("LINEA*", lineATokenizer());
      tokenizers.put("LINEB*", lineBTokenizer());

      lineMapper.setTokenizers(tokenizers);

      Map<String, FieldSetMapper> mappers = new HashMap<>(2);
      mappers.put("USER*", userFieldSetMapper());
      mappers.put("LINE*", lineFieldSetMapper());

      lineMapper.setFieldSetMappers(mappers);

      return lineMapper;
  }
```

이 예에서 "LINEA" 및 "LINEB"에는 별도의 `라인토크나이저(LineTokenizer)` 인스턴스가 있지만, 둘 다 동일한 `필드셋매퍼(FieldSetMapper)`를 사용한다.

`패턴매칭컴포짓라인매퍼(PatternMatchingCompositeLineMapper)`는 `PatternMatcher#match` 메서드를 사용하여 각 라인에 대한 올바른 델리게이트(delegate)를 선택한다. `패턴매처(PatternMatcher)`는 특별한 의미를 가진 두 개의 와일드카드 문자를 사용한다. 물음표(question mark: `?`)는 정확히 한 문자와 일치하고, 별표(asterisk: `*`)는 0개 이상의 문자와 일치한다. 이전 구성에서, 모든 패턴은 별표로 끝나므로, 기능적으로 라인의 접두사가 된다. `패턴매처(PatternMatcher)`는 구성 순서에 관계없이 항상 구체적인 패턴과 일치시킨다. 따라서 "LINE`*`" 및 "LINEA`*`"가 모두 패턴으로 나열된 경우 "LINEA"는 패턴 "LINEA`*`"와 일치하고 "LINEB"는 패턴 "LINE`*`"과 일치한다. 또한, 단일 별표("`*`")는 다른 패턴과 일치하지 않는 라인을 일치시키는 기본값으로 사용할 수 있다.

다음 예에서는 XML의 다른 패턴과 일치하지 않는 라인을 일치시키는 방법을 보여준다:
`XML 구성`
```
  <entry key="*" value-ref="defaultLineTokenizer" />
```

다음 예에서는 자바의 다른 패턴과 일치하지 않는 라인을 일치시키는 방법을 보여준다:
`자바 구성`
```
  ...
  tokenizers.put("*", defaultLineTokenizer());
  ...
```

토큰화에만 사용할 수 있는 `패턴매칭컴포짓라인토크나이저(PatternMatchingCompositeLineTokenizer)`도 있다.

플랫 파일에 각각 여러 라인에 걸쳐 있는 레코드가 포함되는 것도 일반적이다. 이 상황을 처리하려면 더 복잡한 전략이 필요하다. 이 일반적인 패턴의 데모는 `multiLineRecords` 샘플에서 찾을 수 있다.


#### Exception Handling in Flat Files
라인을 토큰화하면 예외가 발생할 수 있는 여러 상황이 있다. 플랫 파일이 불완전하고 형식이 잘못된 레코드를 포함할 수 있다. 많은 사용자가 문제, 라인 및 라인 번호를 기록하는 동안 이러한 잘못된 라인을 건너뛰도록 선택한다. 이러한 로그는 나중에 수동으로 또는 다른 배치 잡으로 검사할 수 있다. 이러한 이유로 스프링 배치는 파링 예외를 처리하기 위한 예외 계층(`플랫파일파스익셉션(FlatFileParseException)` 및 `플랫파일포맷익셉션(FlatFileFormatException)`)을 제공한다. 파일을 읽으려고 시도하는 동안 오류가 발생하면 `플랫파일파스익셉션(FlatFileParseException)`이 `플랫파일아이템리더(FlatFileItemReader)`에 의해 발생한다. `플랫파일포맷익셉션(FlatFileFormatException)`은 `라인토크나이저(LineTokenizer)` 인터페이스의 구현체에서 발생하며 토큰화하는 동안 보다 구체적인 오류를 나타냅니다.


##### `IncorrectTokenCountException`
`디리미티드라인토크나이저(DelimitedLineTokenizer)` 및 `픽스트렝스라인토크나이저(FixedLengthLineTokenizer)` 모두 `필드셋(FieldSet)` 생성에 사용할 수 있는 컬럼 이름을 지정하는 기능이 있다. 그러나 컬럼명의 수가 라인을 토큰화하는 동안 발견된 컬럼의 수와 일치하지 않으면, `필드셋(FieldSet)`을 생성할 수 없으며, 다음 예시처럼, 발생한 토큰 수와 예상되는 수를 포함하는 `인코렉트토큰카운트익셉션(IncorrectTokenCountException)`이 발생한다:

```
  tokenizer.setNames(new String[] {"A", "B", "C", "D"});

  try {
    tokenizer.tokenize("a,b,c");
  } catch (IncorrectTokenCountException e) {
    assertEquals(4, e.getExpectedCount());
    assertEquals(3, e.getActualCount());
  }
```

토크나이저가 4개의 컬럼명으로 구성되었지만, 파일에서 3개의 토큰만 발견되었기 때문에 `인코렉트토큰카운트익셉션(IncorrectTokenCountException)`이 발생했다.


##### `IncorrectLineLengthException`
고정 길이 형식으로 형식이 지정된 파일은 구분(delimited) 형식과 달리 각 컬럼이 미리 정의된 너비를 엄격하게 준수해야 하므로, 파싱에 추가 요구 사항이 있다. 라인의 총 길이가 이 컬럼의 가장 넓은 값과 같지 않으면 다음 예시처럼 예외가 발생한다:

```
  tokenizer.setColumns(new Range[] { new Range(1, 5),
                                     new Range(6, 10),
                                     new Range(11, 15) });
  try {
      tokenizer.tokenize("12345");
      fail("Expected IncorrectLineLengthException");
  } catch (IncorrectLineLengthException ex) {
      assertEquals(15, ex.getExpectedLength());
      assertEquals(5, ex.getActualLength());
  }
```

위의 토크나이저에 구성된 범위는 1-5, 6-10 및 11-15이다. 따라서 선의 총 길이는 15여야 한다. 그러나, 앞의 예에서 길이가 5인 라인이 전달되어 `인코렉트라인렝스익셉션(IncorrectLineLengthException)`이 발생했다. 첫 번째 컬럼만 매핑하는 대신 예외를 발생하면 `필드셋매퍼(FieldSetMapper)`의 컬럼 2를 읽기를 실패한 경우보다 더 많은 정보와 함께 라인 처리가 더 일찍 실패할 수 있다. 그러나 라인의 길이가 항상 일정하지 않은 경우가 있다. 이러한 이유로 다음 예와 같이 'strict' 프로퍼티을 통해 라인 길이 유효성 검사를 끌 수 있다:

```
  tokenizer.setColumns(new Range[] { new Range(1, 5), new Range(6, 10) });
  tokenizer.setStrict(false);
  FieldSet tokens = tokenizer.tokenize("12345");
  assertEquals("12345", tokens.readString(0));
  assertEquals("", tokens.readString(1));
```

앞의 예제는 `tokenizer.setStrict(false)`가 호출되었다는 점을 제외하면 이전 예제와 거의 동일하다. 이제 `필드셋(FieldSet)`이 올바르게 생성되고 반환된다. 그러나 나머지 토큰 값은 비어있다.