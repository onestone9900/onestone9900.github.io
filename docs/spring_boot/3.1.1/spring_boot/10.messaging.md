---
layout: default
title: 10. 메세징(Messaging)
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 10
---

***
10. 메세징(Messaging)
    - 10.1. JMS
        - 10.1.1. ActiveMQ 지원(ActiveMQ Support)
        - 10.1.2. ActiveMQ 아르테미스 지원(ActiveMQ Artemis Support)
        - 10.1.3. JNDI 커넥션팩토리 사용(Using a JNDI ConnectionFactory)
        - 10.1.4. 메세지 보내기(Sending a Message)
        - 10.1.5. 메세지 받기(Receiving a Message)
    - 10.2. AMQP
        - 10.2.1. 래빗MQ 지원(RabbitMQ Support)
        - 10.2.2. 메세지 전송(Sending a Message)
        - 10.2.3. 스트림으로 메시지 보내기(Sending a Message To A Stream)
        - 10.2.4. 메세지 받기(Receiving a Message)
    - 10.3. Apache Kafka Support
        - 10.4.1. RSocket Strategies Auto-configuration
        - 10.4.2. RSocket server Auto-configuration
        - 10.4.3. Spring Messaging RSocket support
        - 10.4.4. Calling RSocket Services with RSocketRequester
    - 10.5. Spring Integration
    - 10.6. WebSockets
    - 10.7. What to Read Next 

***


# 10. 메세징(Messaging)
스프링 프레임워크는 JmsTemplate을 사용하는 JMS API의 단순한 사용부터 메시지를 비동기적으로 수신하는 인프라에 이르기까지 메시징 시스템과의 통합을 위한 광범위한 지원을 제공한다. 스프링 AMQP는 Advanced Message Queuing Protocol과 유사한 기능을 제공한다. 스프링 부트는 래빗템플릿(RabbitTemplate) 및 RabbitMQ에 대한 자동 구성 옵션도 제공한다. 스프링 웹소켓(Spring WebSocket)에는 기본적으로 STOMP 메시징 지원이 포함되어 있으며 스프링 부트는 스타터 자동 구성을 통해 이를 지원한다. 스프링 부트는 아파치 카프카도 지원한다.

## 10.1. JMS
`jakarta.jms.ConnectionFactory` 인터페이스는 JMS 브로커와 상호 작용하기 위해 `jakarta.jms.Connection`을 생성하는 표준 방법을 제공한다. 스프링이 JMS와 작동하려면 커넥션팩토리(ConnectionFactory)가 필요하지만 일반적으로 이를 직접 사용할 필요는 없으며 대신 더 높은 레벨의 메시징 추상화에 의존할 수 있다. (자세한 내용은 스프링 프레임워크 레퍼런스 문서의 관련 절을 참고하자.) 또한 스프링 부트는 메시지를 보내고 받는 데 필요한 인프라를 자동 구성한다.


### 10.1.1. ActiveMQ 지원(ActiveMQ Support)
클래스패스에서 ActiveMQ를 사용할 수 있으면 스프링 부트는 커넥션팩토리(ConnectionFactory)를 구성할 수 있다.

{: .note}
`spring-boot-starter-activemq`를 사용하는 경우 JMS와 통합하기 위한 스프링 인프라와 마찬가지로 ActiveMQ 인스턴스에 연결하는 데 필요한 의존성이 제공된다.

ActiveMQ 구성은 `spring.activemq.*`의 외부 구성 프로퍼티스에 의해 제어된다. 기본적으로 ActiveMQ는 TCP 전송을 사용하도록 자동 구성되어 기본적으로 `tcp://localhost:61616`에 연결된다. 다음 예제에서는 기본 브로커 URL을 변경하는 방법을 보여준다.

`프로퍼티스(Properties)`
```
spring.activemq.broker-url=tcp://192.168.1.210:9876
spring.activemq.user=admin
spring.activemq.password=secret
```

`Yaml`
```yaml
spring:
  activemq:
    broker-url: "tcp://192.168.1.210:9876"
    user: "admin"
    password: "secret"
```

기본적으로, 캐싱커넥션팩토리(CachingConnectionFactory)는 `spring.jms.*`의 외부 구성 프로퍼티스로 제어할 수 있는 합리적인 설정으로 기본 커넥션팩토리(ConnectionFactory)를 래핑한다.

`프로퍼티스(Properties)`
```
spring.jms.cache.session-cache-size=5
```

`Yaml`
```yaml
spring: 
  jms:
    cache:
      session-cache-size: 5
```

기본 풀링을 사용하려는 경우, 다음 예제와 같이 `org.messaginghub:pooled-jms`에 의존성을 추가하고 그에 따라 Jms풀커넥션팩토리(JmsPoolConnectionFactory)를 구성하여 그렇게 할 수 있다.

`프로퍼티스(Properties)`
```
spring.activemq.pool.enabled=true
spring.activemq.pool.max-connections=50
```

`Yaml`
```yaml
spring:
  activemq:
    pool:
      enabled: true
      max-connections: 50
```

{: .note}
지원되는 옵션에 대한 자세한 내용은 액티브MQ프로퍼티스(ActiveMQProperties)를 참고하자. 또한 고급 커스텀를 위해 액티브MQ커넥션팩토리커스터마이저(ActiveMQConnectionFactoryCustomizer)를 구현하는 임의 개수의 빈을 등록할 수도 있다.

기본적으로, ActiveMQ는 대상이 아직 존재하지 않는 경우 제공된 대상을 이름을 확인 후 생성한다.


### 10.1.2. ActiveMQ 아르테미스 지원(ActiveMQ Artemis Support)
스프링 부트는 클래스패스에서 ActiveMQ 아르테미스(Artemis)를 사용할 수 있음을 감지하면 커넥션팩토리(ConnectionFactory)를 자동으로 구성할 수 있다. mode 프로퍼티가 명시적으로 설정되지 않은 경우, 브로커가 있으면 포함된 브로커가 자동으로 시작되고 구성된다. 지원되는 모드는 임베디드(임베디드 브로커가 필요하며 클래스패스에서 브로커를 사용할 수 없는 경우 오류가 발생해야 함을 명시하기 위해) 및 네이티브(네티 전송 프로토콜을 사용하여 브로커에 연결하기 위해) 모드다. 후자가 구성되면 스프링 부트는 기본 설정으로 로컬 시스템에서 실행되는 브로커에 연결하는 커넥션팩토리(ConnectionFactory)를 구성한다.

{: .note}
`spring-boot-starter-artemis`를 사용하는 경우 기존 ActiveMQ 아르테미스 인스턴스에 연결하는 데 필요한 의존성은 물론 JMS와 통합하기 위한 스프링 인프라도 제공된다. `org.apache.activemq:artemis-jakarta-server`를 애플리케이션에 추가하면 임베디드 모드를 사용할 수 있다.

ActiveMQ 아르테미스 구성은 `spring.artemis.*`의 외부 구성 프로퍼티스에 의해 제어된다. 다음 예제는 `application.properties`에서 선언할 수 있는 프로퍼티를 보여준다.

`프로퍼티스(Properties)`
```
spring.artemis.mode=native
spring.artemis.broker-url=tcp://192.168.1.210:9876
spring.artemis.user=admin
spring.artemis.password=secret
```

`Yaml`
```yaml
spring:
  artemis:
    mode: native
    broker-url: "tcp://192.168.1.210:9876"
    user: "admin"
    password: "secret"
```

브로커를 내장할 때, 지속성(persistence) 활성화 여부를 선택하고 사용 가능한 대상을 나열할 수 있다. 이는 쉼표로 구분된 목록으로 지정하여 기본 옵션으로 생성하거나 `org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration` 또는 `org.apache.activemq` 타입의 빈을 정의할 수 있다. `artemis.jms.server.config.TopicConfiguration` - 각각 고급 큐 및 토픽 구성용이다.

기본적으로, 캐싱커넥션팩토리(CachingConnectionFactory)는 `spring.jms.*`의 외부 구성 프로퍼티스로 제어할 수 있는 설정이며 기본 커넥션팩토리(ConnectionFactory)를 래핑한다.

`프로퍼티스(Properties)`
```
spring.jms.cache.session-cache-size=5
```

`Yaml`
```yaml
spring: 
  jms:
    cache:
      session-cache-size: 5
```

네이티브 풀링을 사용하려는 경우, 다음 예제와 같이 `org.messaginghub:pooled-jms`에 대한 의존성을 추가하고 그에 따라 Jms풀커넥션팩토리(JmsPoolConnectionFactory)를 구성할 수 있다.

`프로퍼티스(Properties)`
```
spring.artemis.pool.enabled=true
spring.artemis.pool.max-connections=50
```

`Yaml`
```yaml
spring:
  artemis:
    pool:
      enabled: true
      max-connections: 50
```

지원되는 추가 옵션은 아르테미스프로퍼티스(ArtemisProperties)를 참고하자.

JNDI 조회는 포함되지 않으며, 대상은 아르테미스(Artemis) 구성의 애트리뷰트명 또는 구성으로 제공된 이름을 사용하여 이름을 확인한다.


### 10.1.3. JNDI 커넥션팩토리 사용(Using a JNDI ConnectionFactory)
애플리케이션 서버에서 애플리케이션을 실행 중인 경우 스프링 부트는 JNDI를 사용하여 JMS 커넥션팩토리(ConnectionFactory)를 찾는다. 기본적으로 `java:/JmsXA` 및 `java:/XAConnectionFactory` 위치가 확인된다. 다음 예제와 같이 대체 위치를 지정해야 하는 경우 `spring.jms.jndi-name` 프로퍼티를 사용할 수 있다.

`프로퍼티스(Properties)`
```
spring.jms.jndi-name=java:/MyConnectionFactory
```

`Yaml`
```yaml
spring: 
  jms:
    jndi-name: "java:/MyConnectionFactory"
```


#### 10.1.4. 메세지 보내기(Sending a Message)
스프링의 Jms템플릿(JmsTemplate)은 자동으로 구성되며 다음 예제와 같이 빈에 자동 연결할 수 있다.

`자바`
```java
import org.springframework.jms.core.JmsTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {
    private final JmsTemplate jmsTemplate;

    public MyBean(JmsTemplate jmsTemplate) {
        this.jmsTemplate = jmsTemplate;
    }

    public void someMethod() {
        this.jmsTemplate.convertAndSend("hello");
    } 
}
```

`코틀린`
```kotlin
import org.springframework.jms.core.JmsTemplate
import org.springframework.stereotype.Component

@Component
class MyBean(private val jmsTemplate: JmsTemplate) {
    fun someMethod() {
        jmsTemplate.convertAndSend("hello")
    } 
}
```

{: .note}
`Jms메세징템플릿(JmsMessagingTemplate)`도 비슷한 방식으로 주입할 수 있다. `데스티네이션리졸버(DestinationResolver)` 또는 `메세지컨버터(MessageConverter)` 빈이 정의되면 자동으로 구성된 Jms템플릿(JmsTemplate)에 자동으로 연결된다.


### 10.1.5. 메세지 받기(Receiving a Message)
JMS 인프라가 있는 경우 모든 빈에 @JmsListener 어노테이션을 추가하여 리스너 엔드포인트를 생성할 수 있다. `Jms리스너컨테이너팩토리(JmsListenerContainerFactory)`가 정의되지 않은 경우, 기본 항목이 자동으로 구성된다. 데스티네이션리졸버(DestinationResolver), 메세지컨버터(MessageConverter) 또는 `jakarta.jms.ExceptionListener` 빈이 정의된 경우 기본 팩토리와 자동으로 연관된다.

기본적으로, 기본 팩토리는 트랜잭션이다. Jta트랜젝션매니저(JtaTransactionManager)가 있는 인프라에서 실행하는 경우 기본적으로 리스너 컨테이너에 연결된다. 그렇지 않은 경우 `sessionTransacted` 플래그가 활성화된다. 후자의 시나리오에서는 리스너 메서드(또는 그 델리게이트(delegate))에 @Transactional을 추가하여 로컬 데이터 저장소 트랜잭션을 수신 메시지 처리에 연결할 수 있다. 이렇게 하면 로컬 트랜잭션이 완료되면 들어오는 메시지가 승인된다. 여기에는 동일한 JMS 세션에서 수행된 응답 메시지 전송도 포함된다.

다음 컴포넌트는 someQueue 대상에 리스너 엔드포인트를 생성한다.

`자바`
```java
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

@Component
public class MyBean {
    @JmsListener(destination = "someQueue")
    public void processMessage(String content) {
        // ... 
    }
}
```

`코틀린`
```kotlin
import org.springframework.jms.annotation.JmsListener
import org.springframework.stereotype.Component

@Component
class MyBean {
    @JmsListener(destination = "someQueue")
    fun processMessage(content: String?) {
        // ... 
    }
}
```

자세한 내용은 @EnableJms의 자바독(Javadoc)을 참고하자.

더 많은 `Jms리스너컨테이너팩토리(JmsListenerContainerFactory)` 인스턴스를 생성해야 하거나 기본값을 오버라이드하려는 경우 스프링 부트는 자동 구성된 것과 동일한 설정으로 `디폴트Jms리스너컨테이너팩토리(DefaultJmsListenerContainerFactory)`를 초기화하는 데 사용할 수 있는 `디폴트Jms리스너컨테이너팩토리컨피규어러(DefaultJmsListenerContainerFactoryConfigurer)`를 제공한다.

다음 예제에서는 특정 메세지컨버터(MessageConverter)를 사용하는 다른 팩토리를 노출한다.

`자바`
```java
import jakarta.jms.ConnectionFactory;
import org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;

@Configuration(proxyBeanMethods = false)
public class MyJmsConfiguration {
    @Bean
    public DefaultJmsListenerContainerFactorymyFactory(DefaultJmsListenerContainerFactoryConfigurer configurer) {
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        ConnectionFactory connectionFactory = getCustomConnectionFactory();
        configurer.configure(factory, connectionFactory);
        factory.setMessageConverter(new MyMessageConverter());
        return factory;
    }

    private ConnectionFactory getCustomConnectionFactory() {
        return ...
    }
}
```

`코틀린`
```kotlin
import jakarta.jms.ConnectionFactory
import org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.jms.config.DefaultJmsListenerContainerFactory

@Configuration(proxyBeanMethods = false)
class MyJmsConfiguration {
    @Bean
    fun myFactory(configurer: DefaultJmsListenerContainerFactoryConfigurer): DefaultJmsListenerContainerFactory {
        val factory = DefaultJmsListenerContainerFactory()
        val connectionFactory = getCustomConnectionFactory()
        configurer.configure(factory, connectionFactory)
        factory.setMessageConverter(MyMessageConverter())
        return factory
    }

    fun getCustomConnectionFactory() : ConnectionFactory? {
        return ...
    } 
}
```

그런 다음 다음과 같이 @JmsListener 어노테이션이 달린 메서드에서 팩토리를 사용할 수 있다.

`자바`
```java
import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;

@Component
public class MyBean {
    @JmsListener(destination = "someQueue", containerFactory = "myFactory")
    public void processMessage(String content) {
        // ... 
    }
}
```

`코틀린`
```kotlin
import org.springframework.jms.annotation.JmsListener
import org.springframework.stereotype.Component

@Component
class MyBean {
    @JmsListener(destination = "someQueue", containerFactory = "myFactory")
    fun processMessage(content: String?) {
        // ... 
    }
}
```


## 10.2. AMQP
AMQP(Advanced Message Queuing Protocol)는 메시지 지향 미들웨어를 위한 플랫폼 중립적, 와이어 레벨(wire-level) 프로토콜이다. 스프링 AMQP 프로젝트는 AMQP 기반 메시징 솔루션 개발에 코어 스프링 개념을 적용한다. 스프링 부트는 `spring-boot-starter-amqp` "스타터(Starter)"를 포함하여 레빗MQ를 통해 AMQP로 작업할 수 있는 여러 가지 편의를 제공한다.


### 10.2.1. 래빗MQ 지원(RabbitMQ Support)
래빗MQ는 AMQP 프로토콜을 기반으로 하는 가볍고 안정적이며 확장 가능하고 이식 가능한 메시지 브로커다. 스프링은 AMQP 프로토콜을 통해 통신하기 위해 래빗MQ를 사용한다.

래빗MQ 구성은 `spring.rabbitmq.*`의 외부 구성 프로퍼티스에 의해 제어된. 다음 예제는 `application.properties`의 선언을 보여준다.

`프로퍼티스(Properties)`
```
spring.rabbitmq.host=localhost
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=secret
```

`Yaml`
```yaml
spring:
  rabbitmq:
    host: "localhost"
    port: 5672
    username: "admin"
    password: "secret"
```

또는, 다음과 같이 addresses 애트리뷰트를 사용하여 동일한 커넥션을 구성할 수도 있다.

`프로퍼티스(Properties)`
```
spring.rabbitmq.addresses=amqp://admin:secret@localhost
```

`Yaml`
```yaml
spring:
  rabbitmq:
    addresses: "amqp://admin:secret@localhost"
```

{: .note}
이런 방식으로 addresses를 지정하면 호스트 및 포트 프로퍼티스가 무시된다. addresses가 amqps 프로토콜을 사용하는 경우 SSL 지원이 자동으로 활성화된다.

지원되는 프로퍼팃 구성 옵션에 대한 자세한 내용은 래빗프로퍼티스(RabbitProperties)를 참고하자. 스프링 AMQP에서 사용되는 래빗MQ 커네션팩토리(ConnectionFactory)의 하위 레벨 디테일을 구성하려면 커넥션팩토리커스터마이저(ConnectionFactoryCustomizer) 빈을 정의하자.

`커넥션네임스트래티지(ConnectionNameStrategy)` 빈이 컨텍스트에 존재하는 경우 자동 구성된 `캐싱커넥션팩토리(CachingConnectionFactory)`에 의해 생성된 커넥션명을 지정하는 데 자동으로 사용된다.

애플리케이션 전체에 걸쳐 래빗템플릿(RabbitTemplate)에 대한 추가 커스텀을 수행하려면 `래빗템플릿커스터마이저(RabbitTemplateCustomizer)` 빈을 사용하자.

{: .note}
See Understanding AMQP, the protocol used by RabbitMQ for more details.


## 10.2.2. 메세지 전송(Sending a Message)
스프링의 Amqp템플릿(AmqpTemplate) 및 Ampq어드민(AmqpAdmin)은 자동 구성되며, 다음 예제와 같이 이를 사용자 고유의 빈에 직접 오토와이어드(autowire)할 수 있다.

`자바`
```java
import org.springframework.amqp.core.AmqpAdmin;
import org.springframework.amqp.core.AmqpTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {
    private final AmqpAdmin amqpAdmin;
    
    private final AmqpTemplate amqpTemplate;

    public MyBean(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate) {
        this.amqpAdmin = amqpAdmin;
        this.amqpTemplate = amqpTemplate;
    }

    public void someMethod() {
        this.amqpAdmin.getQueueInfo("someQueue");
    }

    public void someOtherMethod() {
        this.amqpTemplate.convertAndSend("hello");
    } 
}
```

`코틀린`
```kotlin
import org.springframework.amqp.core.AmqpAdmin
import org.springframework.amqp.core.AmqpTemplate
import org.springframework.stereotype.Component

@Component
class MyBean(private val amqpAdmin: AmqpAdmin, private val amqpTemplate: AmqpTemplate) {
    fun someMethod() {
        amqpAdmin.getQueueInfo("someQueue")
    }

    fun someOtherMethod() {
        amqpTemplate.convertAndSend("hello")
    } 
}
```

{: .note}
래빗메세징템플릿(RabbitMessagingTemplate)도 비슷한 방식으로 주입할 수 있다. 메세지컨버터(MessageConverter) 빈이 정의되면, 자동으로 구성된 Ampq템플릿(AmqpTemplate에) 자동으로 연결된다.

필요한 경우, 빈으로 정의된 `org.springframework.amqp.core.Queue`는 래빗MQ 인스턴스에서 해당 큐을 선언하는 데 자동으로 사용된다.

작업을 재시도하려면, AmqpTemplate에서 재시도(retry)를 활성화하면 된다(예: 브로커 연결이 끊어진 경우).

`프로퍼티스(Properties)`
```
spring.rabbitmq.template.retry.enabled=true
spring.rabbitmq.template.retry.initial-interval=2s
```

`Yaml`
```yaml
spring:
  rabbitmq:
    template:
      retry:
        enabled: true
        initial-interval: "2s"
```

재시도는 기본적으로 비활성화되어 있다. `래빗리트라이템플릿커스터마이저(RabbitRetryTemplateCustomizer)` 빈을 선언하여 프로그래밍 방식으로 `리트라이템플릿(RetryTemplate)`을 커스텀할 수도 있다.

더 많은 래빗템플릿(RabbitTemplate) 인스턴스를 생성해야 하거나 기본값을 오버라이드하려는 경우 스프링 부트는 자동 구성에서 사용되는 팩토리와 동일한 설정으로 래빗템플릿(RabbitTemplate)을 초기화하는 데 사용할 수 있는 래빗템플릿컨피규어러(RabbitTemplateConfigurer) 빈을 제공한다.


### 10.2.3. 스트림으로 메시지 보내기(Sending a Message To A Stream)
특정 스트림에 메시지를 보내려면 다음 예제와 같이 스트림명을 지정하자.

`프로퍼티스(Properties)`
```
spring.rabbitmq.stream.name=my-stream
```

`Yaml`
```yaml
spring:
  rabbitmq:
    stream:
      name: "my-stream"
```

메세지컨버터(MessageConverter), 스트림메세지컨버터(StreamMessageConverter) 또는 프로듀서커스터마이저(ProducerCustomizer) 빈이 정의된 경우 자동 구성된 래빗스트림템플릿(RabbitStreamTemplate)에 자동으로 연결된다.


### 10.2.4. 메세지 받기(Receiving a Message)
래빗 인프라가 있는 경우 모든 빈에 @RabbitListener 어노테이션을 추가하여 리스너 엔드포인트를 생성할 수 있다. `래빗리스너컨테이너팩토리(RabbitListenerContainerFactory)`가 정의되지 않은 경우 기본 `심플래빗리스너컨테이너팩토리(SimpleRabbitListenerContainerFactory)`가 자동으로 구성되며 `spring.rabbitmq.listener.type` 프로퍼티를 사용하여 직접 컨테이너로 전환할 수 있다. 메세지컨버터(MessageConverter) 또는 메세지리커버러(MessageRecoverer) 빈이 정의되면 자동으로 기본 팩토리와 연결된다.

다음 샘플 컴포넌트는 someQueue 큐에 리스너 엔드포인트를 생성한다.

`자바`
```java
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

@Component
public class MyBean {
    @RabbitListener(queues = "someQueue")
    public void processMessage(String content) {
        // ... 
    }
}
```

`코틀린`
```kotlin
import org.springframework.amqp.rabbit.annotation.RabbitListener
import org.springframework.stereotype.Component

@Component
class MyBean {
    @RabbitListener(queues = ["someQueue"])
    fun processMessage(content: String?) {
        // ... 
    }
}
```

{: .note}
자세한 내용은 @EnableRabbit의 자바독(Javadoc)을 참고하자

많은 래빗리스너컨테이너팩토리(RabbitListenerContainerFactory) 인스턴스를 생성해야 하거나 기본값을 오버라이드하려는 경우 스프링 부트는 자동 구성에서 사용되는 팩토리와 동일한 설정으로 심플래빗리스너컨테이너팩토리(SimpleRabbitListenerContainerFactory) 및 다이렉트래빗리스너컨테이너팩토리(DirectRabbitListenerContainerFactory)를 초기화하는 데 사용할 수 있는 심플래빗리스너컨테이너팩토리컨피규어러(SimpleRabbitListenerContainerFactoryConfigurer) 및 다이렉트래빗리스너컨테이너팩토리컨피규어러(DirectRabbitListenerContainerFactoryConfigurer)를 제공한다.

{: .note}
어떤 컨테이너 타입을 선택했는지는 중요하지 않다. 이 두 개의 빈은 자동 구성에 의해 노출된다.

예를 들어, 다음 구성 클래스는 특정 메세지컨버터(MessageConverter)를 사용하는 다른 팩터리를 노출한다.

`자바`
```java
import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.boot.autoconfigure.amqp.SimpleRabbitListenerContainerFactoryConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
public class MyRabbitConfiguration {
    @Bean
    public SimpleRabbitListenerContainerFactorymyFactory(SimpleRabbitListenerContainerFactoryConfigurer configurer) {
        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
        ConnectionFactory connectionFactory = getCustomConnectionFactory();
        configurer.configure(factory, connectionFactory);
        factory.setMessageConverter(new MyMessageConverter());
        return factory;
    }

    private ConnectionFactory getCustomConnectionFactory() {
        return ...
    } 
}
```

`코틀린`
```kotlin
import org.springframework.amqp.rabbit.config.SimpleRabbitListenerContainerFactory
import org.springframework.amqp.rabbit.connection.ConnectionFactory
import org.springframework.boot.autoconfigure.amqp.SimpleRabbitListenerContainerFactoryConfigurer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration(proxyBeanMethods = false)
class MyRabbitConfiguration {
    @Bean
    fun myFactory(configurer: SimpleRabbitListenerContainerFactoryConfigurer): SimpleRabbitListenerContainerFactory {
        val factory = SimpleRabbitListenerContainerFactory()
        val connectionFactory = getCustomConnectionFactory()
        configurer.configure(factory, connectionFactory)
        factory.setMessageConverter(MyMessageConverter())
        return factory
    }
    
    fun getCustomConnectionFactory() : ConnectionFactory? {
        return ...
    } 
}
```

그런 다음 다음과 같이 @RabbitListener 어노테이션이 달린 메서드에서 팩토리를 사용할 수 있다.

`자바`
```java
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

@Component
public class MyBean {
    @RabbitListener(queues = "someQueue", containerFactory = "myFactory")
    public void processMessage(String content) {
        // ... 
    }
}
```

`코틀린`
```kotlin
import org.springframework.amqp.rabbit.annotation.RabbitListener
import org.springframework.stereotype.Component

@Component
class MyBean {
    @RabbitListener(queues = ["someQueue"], containerFactory = "myFactory")
    fun processMessage(content: String?) {
        // ... 
    }
}
```

리스너가 예외를 발생시키는 상황을 처리하기 위해 재시도를 활성화할 수 있다. 기본적으로 리젝트엔돈트리큐리커버러(RejectAndDontRequeueRecoverer)가 사용되지만 고유한 메세지리커버러(MessageRecoverer)를 정의할 수 있다. 재시도 횟수가 모두 소모되면 메시지가 거부되고 삭제되거나 브로커가 그렇게 하도록 구성된 경우 배달 못한 편지 교환으로 라우팅된다. 기본적으로 재시도는 비활성화되어 있다. 래빗리트라이템플릿커스터마이저(RabbitRetryTemplateCustomizer) 빈을 선언하여 프로그래밍 방식으로 리트라이템플릿(RetryTemplate)을 사용자 정의할 수도 있다.

{: .important}
기본적으로 재시도가 비활성화되어 있고 리스너에서 예외가 발생하면 전달이 무기한 재시도된다. 이 동작은 두 가지 방법으로 수정할 수 있다. defaultRequeueRejected 프로퍼티를 false로 설정하여 재전송을 시도하지 않거나 Amqp리젝트엔돈트리큐익셉션(AmqpRejectAndDontRequeueException)을 발생시켜 메시지가 거부되어야 한다는 신호를 보낸다. 후자는 재시도가 활성화되고 최대 배달 시도 횟수에 도달했을 때 사용되는 메커니즘이다.
