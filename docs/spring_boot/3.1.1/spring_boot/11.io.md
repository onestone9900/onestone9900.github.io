---
layout: default
title: 11. IO
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 11
---

***
11. IO
    - 11.1. 캐싱(Caching)
        - 11.1.1. 지원되는 캐시 프로바이더(Supported Cache Providers)
            - 제네릭(Generic)
            - JCache (JSR-107)
            - Hazelcast
            - Infinispan
            - Couchbase
            - Redis
            - Caffeine
            - Cache2k
            - Simple
            - None
    - 11.2. Hazelcast
    - 11.3. Quartz Scheduler
    - 11.4. Sending Email
    - 11.5. Validation
    - 11.6. Calling REST Services
        - 11.6.1. RestTemplate
            - RestTemplate Customization
            - RestTemplate SSL Support
        - 11.6.2. WebClient
            - WebClient Runtime
            - WebClient Customization
            - WebClient SSL Support
    - 11.7. Web Services
        - 11.7.1. Calling Web Services with WebServiceTemplate
    - 11.8. Distributed Transactions With JTA
        - 11.8.1. Using a Jakarta EE Managed Transaction Manager 
        - 11.8.2. Mixing XA and Non-XA JMS Connections
        - 11.8.3. Supporting an Embedded Transaction Manager
    - 11.9. 다음에 읽을 내용(What to Read Next)

***

# 11. IO
대부분의 애플리케이션은 어느 시점에서는 입력 및 출력 문제를 처리해야 한다. 스프링 부트는 IO 기능이 필요할 때 도움이 되는 다양한 기술과의 통합 및 유틸리티를 제공한다. 이 장에서는 캐싱 및 유효성 검사와 같은 표준 IO 기능뿐만 아니라 예약 및 분산 트랜잭션과 같은 고급 주제도 다훈다. 또한 원격 REST 또는 SOAP 서비스 호출 및 이메일 전송도 다룬다.


## 11.1. 캐싱(Caching)
스프링 프레임워크는 애플리케이션에 캐싱을 지원한다. 기본적으로 추상화는 메서드에 캐싱을 적용하여 캐시에서 사용 가능한 정보를 기반으로 실행 횟수를 줄인다. 캐싱 로직는 호출자에게 어떠한 간섭도 없이 투명하게 적용된다. 스프링 부트는 @EnableCaching 어노테이션을 사용하여 캐싱 지원 활성화 후 캐시 인프라를 자동 구성한다.

{: .note}
자세한 내용은 스프링 프레임워크 레퍼런스 관련 장을 확인하자.

간단히 말해, 서비스 작업에 캐싱을 추가하려면 다음 예제와 같이 해당 메서드에 관련 어노테이션을 추가하자.

`자바`
```java
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;

@Component
public class MyMathService {
    @Cacheable("piDecimals")
    public int computePiDecimal(int precision) {
        ... 
    }
}
```

`코틀린`
```kotlin
import org.springframework.cache.annotation.Cacheable
import org.springframework.stereotype.Component
@Component
class MyMathService {
    @Cacheable("piDecimals")
    fun computePiDecimal(precision: Int): Int {
        ... 
    }
}
```

이 예제에서는 잠재적으로 비용이 많이 드는 작업에 캐싱을 사용하는 방법을 보여준다. 컴퓨트파이데시말(ComputePiDecimal)을 호출하기 전에 추상화는 i 인수와 일치하는 piDecimals 캐시에서 아이템을 찾는다. 아이템이 발견되면 캐시의 콘텐츠가 호출자에게 즉시 반환되고 메서드는 호출되지 않는다. 그렇지 않으면 메서드가 호출되고 값을 반환하기 전에 캐시가 업데이트된다.

{: .warning}
표준 JSR-107(JCache) 어노테이션(예: @CacheResult)을 투명하게 사용할 수도 있다. 그러나 스프링 캐시와 JCache 어노테이션을 혼합하여 사용하지 않는 것이 좋다.

특정 캐시 라이브러리를 추가하지 않으면, 스프링 부트는 메모리에서 컨커런트 맵(concurrent maps)을 사용하는 간단한 프로바이더(provider)를 자동 구성한다. 캐시가 필요한 경우(예: 이전 예의 piDecimals) 이 프로바이더가 이를 생성한다. 간단한 프로바이더는 프로덕션 용도로 실제로 권장되지는 않지만 시작하고 기능을 이해하는 데 좋다. 사용할 캐시 프로바이더를 결정한 경우, 해당 문서를 읽고 애플리케이션에서 사용하는 캐시를 구성하는 방법을 알아보자. 거의 모든 프로바이더는 애플리케이션에서 사용하는 모든 캐시를 명시적으로 구성하도록 요구한다. 일부는 `spring.cache.cache-names` 프로퍼티로 정의된 기본 캐시를 커스텀하는 방법을 제공한다.

{: .note}
캐시에서 데이터를 투명하게 업데이트하거나 제거하는 것도 가능하다.


### 11.1.1. 지원되는 캐시 프로바이더(Supported Cache Providers)
캐시 추상화는 실제 저장소를 제공하지 않으며 `org.springframework.cache.Cache` 및 `org.springframework.cache.CacheManager` 인터페이스에 의해 구체화된 추상화에 의존한다.

캐시매니저(CacheManager) 타입의 빈 또는 캐시리졸버(CacheResolver)(캐싱컨피규어러(CachingConfigurer) 참고)명을 정의하지 않은 경우 스프링 부트는 다음 프로바이더를 지정된 순서대로 감지하려고 시도한다.

1. 제네릭(Generic)
2. JCache (JSR-107) (EhCache 3, Hazelcast, Infinispan, and others) 
3. 헤이즐캐스트(Hazelcast)
4. 인피니스판(Infinispan)
5. 카우치베이스(Couchbase)
6. 레디스(Redis)
7. 카페인(Caffeine)
8. 캐시2k(Cache2k)
9. 심플(Simple)


또한, 아파치 지오드(Apache Geode)용 스프링 부트는 아파치 지오드를 캐시 프로바이더로 사용하기 위한 자동 구성을 제공한다.

{: .note}
`spring.cache.type` 프로퍼티를 설정하여 특정 캐시 프로바이더를 강제하는 것도 가능하다. 특정 환경(예: 테스트)에서 캐싱을 완전히 비활성화해야 하는 경우 이 프로퍼티를 사용하자.

{: .note}
`spring-boot-starter-cache` "스타터(Starter)"를 사용하여 기본 캐싱 의존성을 빠르게 추가하자. 스타터는 스프링 컨텍스트 지원을 제공한다. 의존성을 수동으로 추가하는 경우 JCache 또는 카페인(Caffeine) 지원을 사용하려면 `spring-context-support`를 포함해야 한다.

캐시매니저(CacheManager)가 스프링 부트에 의해 자동 구성되는 경우 캐시매니저커스터마이저(CacheManagerCustomizer) 인터페이스를 구현하는 빈을 노출하여 완전히 초기화되기 전에 해당 구성을 추가로 조정할 수 있다. 다음 예제에서는 null 값이 기본 맵에 전달되어서는 안 된다는 플래그를 설정한다.

`자바`
```java
import org.springframework.boot.autoconfigure.cache.CacheManagerCustomizer;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
public class MyCacheManagerConfiguration {
    @Bean
    public CacheManagerCustomizer<ConcurrentMapCacheManager> cacheManagerCustomizer() {
        return (cacheManager) -> cacheManager.setAllowNullValues(false);
    }
}
```

`코틀린`
```kotlin
import org.springframework.boot.autoconfigure.cache.CacheManagerCustomizer
import org.springframework.cache.concurrent.ConcurrentMapCacheManager
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration(proxyBeanMethods = false)
class MyCacheManagerConfiguration {
    @Bean
    fun cacheManagerCustomizer(): CacheManagerCustomizer<ConcurrentMapCacheManager> {
        return CacheManagerCustomizer { cacheManager ->
            cacheManager.isAllowNullValues = false
        }    
    }
}
```

{: .note}
앞의 예제에서, 자동 구성된 컨커런트맵캐시매니저(ConcurrentMapCacheManager)를 기대한다. 그렇지 않은 경우(자신의 구성을 제공했거나 다른 캐시 프로바이더가 자동으로 구성된 경우) 커스터마이저가 전혀 호출되지 않는다. 원하는 만큼 커스터마이저를 가질 수 있으며 @Order 또는 Ordered를 사용하여 순서를 정할수도 있다.


#### 제네릭(Generic)
컨텍스트가 최소한 하나의 `org.springframework.cache.Cache` 빈을 정의하는 경우 제네릭 캐싱이 사용된다. 해당 타입의 모든 빈을 래핑하는 캐시매니저(CacheManager)가 생성된다.


#### JCache (JSR-107)
JCache는 클래스패스 있는 `javax.cache.spi.CachingProvider`를 통해 부트스트랩되며(즉, JSR-107 호환 캐싱 라이브러리가 클래스패스에 존재함) J캐시캐시매니저(JCacheCacheManager)는 `spring-boot-starter-cache`에 의해 제공된다. 다양한 호환 라이브러리를 사용할 수 있으며 스프링 부트는 Ehcache 3, 헤이즐캐스트(Hazelcast) 및 인피니스판(Infinispan)에 대한 의존성 관리를 제공한다. 다른 호환 라이브러리도 추가할 수 있다.

둘 이상의 프로바이더가 존재할 수 있으며, 이 경우 프로바이더를 명시적으로 지정해야 한다. JSR-107 표준이 구성 파일의 위치를 ​​정의하는 표준화된 방법을 적용하지 않더라도 스프링 부트는 다음 예제와 같이 구현 세부 사항으로 캐시 설정을 수용하기 위해 최선을 다한다.

`프로퍼티스(Properties)`
```
# 둘 이상의 프로바이더가 있는 경우에만 필요하다.
spring.cache.jcache.provider=com.example.MyCachingProvider
spring.cache.jcache.config=classpath:example.xml
```

`Yaml`
```yaml
# 둘 이상의 프로바이더가 있는 경우에만 필요하다.
spring:
  cache:
    jcache:
      provider: "com.example.MyCachingProvider"
      config: "classpath:example.xml"
```

{: .note}
캐시 라이브러리가 기본 구현과 JSR-107 지원을 모두 제공하는 경우 스프링 부트는 JSR-107 지원을 선호하므로 다른 JSR-107 구현으로 전환해도 동일한 기능을 사용할 수 있다.

{: .note}
스프링 부트 헤이즐캐스트를 일반적으로 지원합니다. 단일 해이즐캐스트인스턴스(HazelcastInstance)를 사용할 수 있는 경우 `spring.cache.jcache.config` 프로퍼티를 지정하지 않는 한 캐시매니저(CacheManager)에도 자동 재사용된다.

기본 javax.cache.cacheManager를 커스텀하는 방법에는 두 가지가 있다.
- `spring.cache.cache-names` 프로퍼티를 설정하여 시작 시 캐시를 생성할 수 있다. 커스텀 `javax.cache.configuration.Configuration` 빈이 정의된 경우 이를 커스텀하는 데 사용된다.
- `org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer` 빈은 전체 커스텀를 위해 캐시매니저(CacheManager)의 레퍼런스로 호출된다.

{: .note}
표준 `javax.cache.CacheManager` 빈이 정의되면 추상화가 기대하는 `org.springframework.cache.CacheManager` 구현에 자동으로 래핑된다. 더 이상 커스텀이 적용되지 않는다.

If a standard javax.cache.CacheManager bean is defined, it is wrapped automatically in an org.springframework.cache.CacheManager implementation that the abstraction expects. No further customization is applied to it.