---
layout: default
title: 11. IO
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 11
---

***
11. IO
    - 11.1. 캐싱(Caching)
        - 11.1.1. 지원되는 캐시 프로바이더(Supported Cache Providers)
            - 제네릭(Generic)
            - JCache (JSR-107)
            - 헤이즐캐스트(Hazelcast)
            - 인피니스판(Infinispan)
            - 카우치베이스(Couchbase)
            - 레디스(Redis)
            - 카페인(Caffeine)
            - 캐시2k(Cache2k)
            - 심플(Simple)
            - 없음(None)
    - 11.2. 헤이즐캐스트(Hazelcast)
    - 11.3. 쿼츠 스케줄러(Quartz Scheduler)
    - 11.4. 이메일 전송(Sending Email)
    - 11.5. Validation
    - 11.6. Calling REST Services
        - 11.6.1. RestTemplate
            - RestTemplate Customization
            - RestTemplate SSL Support
        - 11.6.2. WebClient
            - WebClient Runtime
            - WebClient Customization
            - WebClient SSL Support
    - 11.7. Web Services
        - 11.7.1. Calling Web Services with WebServiceTemplate
    - 11.8. Distributed Transactions With JTA
        - 11.8.1. Using a Jakarta EE Managed Transaction Manager 
        - 11.8.2. Mixing XA and Non-XA JMS Connections
        - 11.8.3. Supporting an Embedded Transaction Manager
    - 11.9. 다음에 읽을 내용(What to Read Next)

***

# 11. IO
대부분의 애플리케이션은 어느 시점에서는 입력 및 출력 문제를 처리해야 한다. 스프링 부트는 IO 기능이 필요할 때 도움이 되는 다양한 기술과의 통합 및 유틸리티를 제공한다. 이 장에서는 캐싱 및 유효성 검사와 같은 표준 IO 기능뿐만 아니라 예약 및 분산 트랜잭션과 같은 고급 주제도 다훈다. 또한 원격 REST 또는 SOAP 서비스 호출 및 이메일 전송도 다룬다.


## 11.1. 캐싱(Caching)
스프링 프레임워크는 애플리케이션에 캐싱을 지원한다. 기본적으로 추상화는 메서드에 캐싱을 적용하여 캐시에서 사용 가능한 정보를 기반으로 실행 횟수를 줄인다. 캐싱 로직는 호출자에게 어떠한 간섭도 없이 투명하게 적용된다. 스프링 부트는 @EnableCaching 어노테이션을 사용하여 캐싱 지원 활성화 후 캐시 인프라를 자동 구성한다.

{: .note}
자세한 내용은 스프링 프레임워크 레퍼런스 관련 장을 확인하자.

간단히 말해, 서비스 작업에 캐싱을 추가하려면 다음 예제와 같이 해당 메서드에 관련 어노테이션을 추가하자.

`자바`
```java
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Component;

@Component
public class MyMathService {
    @Cacheable("piDecimals")
    public int computePiDecimal(int precision) {
        ... 
    }
}
```

`코틀린`
```kotlin
import org.springframework.cache.annotation.Cacheable
import org.springframework.stereotype.Component
@Component
class MyMathService {
    @Cacheable("piDecimals")
    fun computePiDecimal(precision: Int): Int {
        ... 
    }
}
```

이 예제에서는 잠재적으로 비용이 많이 드는 작업에 캐싱을 사용하는 방법을 보여준다. 컴퓨트파이데시말(ComputePiDecimal)을 호출하기 전에 추상화는 i 인수와 일치하는 piDecimals 캐시에서 아이템을 찾는다. 아이템이 발견되면 캐시의 콘텐츠가 호출자에게 즉시 반환되고 메서드는 호출되지 않는다. 그렇지 않으면 메서드가 호출되고 값을 반환하기 전에 캐시가 업데이트된다.

{: .warning}
표준 JSR-107(JCache) 어노테이션(예: @CacheResult)을 투명하게 사용할 수도 있다. 그러나 스프링 캐시와 JCache 어노테이션을 혼합하여 사용하지 않는 것이 좋다.

특정 캐시 라이브러리를 추가하지 않으면, 스프링 부트는 메모리에서 컨커런트 맵(concurrent maps)을 사용하는 간단한 프로바이더(provider)를 자동 구성한다. 캐시가 필요한 경우(예: 이전 예의 piDecimals) 이 프로바이더가 이를 생성한다. 간단한 프로바이더는 프로덕션 용도로 실제로 권장되지는 않지만 시작하고 기능을 이해하는 데 좋다. 사용할 캐시 프로바이더를 결정한 경우, 해당 문서를 읽고 애플리케이션에서 사용하는 캐시를 구성하는 방법을 알아보자. 거의 모든 프로바이더는 애플리케이션에서 사용하는 모든 캐시를 명시적으로 구성하도록 요구한다. 일부는 `spring.cache.cache-names` 프로퍼티로 정의된 기본 캐시를 커스텀하는 방법을 제공한다.

{: .note}
캐시에서 데이터를 투명하게 업데이트하거나 제거하는 것도 가능하다.


### 11.1.1. 지원되는 캐시 프로바이더(Supported Cache Providers)
캐시 추상화는 실제 저장소를 제공하지 않으며 `org.springframework.cache.Cache` 및 `org.springframework.cache.CacheManager` 인터페이스에 의해 구체화된 추상화에 의존한다.

캐시매니저(CacheManager) 타입의 빈 또는 캐시리졸버(CacheResolver)(캐싱컨피규어러(CachingConfigurer) 참고)명을 정의하지 않은 경우 스프링 부트는 다음 프로바이더를 지정된 순서대로 감지하려고 시도한다.

1. 제네릭(Generic)
2. JCache (JSR-107) (EhCache 3, Hazelcast, Infinispan, and others) 
3. 헤이즐캐스트(Hazelcast)
4. 인피니스판(Infinispan)
5. 카우치베이스(Couchbase)
6. 레디스(Redis)
7. 카페인(Caffeine)
8. 캐시2k(Cache2k)
9. 심플(Simple)


또한, 아파치 지오드(Apache Geode)용 스프링 부트는 아파치 지오드를 캐시 프로바이더로 사용하기 위한 자동 구성을 제공한다.

{: .note}
`spring.cache.type` 프로퍼티를 설정하여 특정 캐시 프로바이더를 강제하는 것도 가능하다. 특정 환경(예: 테스트)에서 캐싱을 완전히 비활성화해야 하는 경우 이 프로퍼티를 사용하자.

{: .note}
`spring-boot-starter-cache` "스타터(Starter)"를 사용하여 기본 캐싱 의존성을 빠르게 추가하자. 스타터는 스프링 컨텍스트 지원을 제공한다. 의존성을 수동으로 추가하는 경우 JCache 또는 카페인(Caffeine) 지원을 사용하려면 `spring-context-support`를 포함해야 한다.

캐시매니저(CacheManager)가 스프링 부트에 의해 자동 구성되는 경우 캐시매니저커스터마이저(CacheManagerCustomizer) 인터페이스를 구현하는 빈을 노출하여 완전히 초기화되기 전에 해당 구성을 추가로 조정할 수 있다. 다음 예제에서는 null 값이 기본 맵에 전달되어서는 안 된다는 플래그를 설정한다.

`자바`
```java
import org.springframework.boot.autoconfigure.cache.CacheManagerCustomizer;
import org.springframework.cache.concurrent.ConcurrentMapCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
public class MyCacheManagerConfiguration {
    @Bean
    public CacheManagerCustomizer<ConcurrentMapCacheManager> cacheManagerCustomizer() {
        return (cacheManager) -> cacheManager.setAllowNullValues(false);
    }
}
```

`코틀린`
```kotlin
import org.springframework.boot.autoconfigure.cache.CacheManagerCustomizer
import org.springframework.cache.concurrent.ConcurrentMapCacheManager
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration(proxyBeanMethods = false)
class MyCacheManagerConfiguration {
    @Bean
    fun cacheManagerCustomizer(): CacheManagerCustomizer<ConcurrentMapCacheManager> {
        return CacheManagerCustomizer { cacheManager ->
            cacheManager.isAllowNullValues = false
        }    
    }
}
```

{: .note}
앞의 예제에서, 자동 구성된 컨커런트맵캐시매니저(ConcurrentMapCacheManager)를 기대한다. 그렇지 않은 경우(자신의 구성을 제공했거나 다른 캐시 프로바이더가 자동으로 구성된 경우) 커스터마이저가 전혀 호출되지 않는다. 원하는 만큼 커스터마이저를 가질 수 있으며 @Order 또는 Ordered를 사용하여 순서를 정할수도 있다.


#### 제네릭(Generic)
컨텍스트가 최소한 하나의 `org.springframework.cache.Cache` 빈을 정의하는 경우 제네릭 캐싱이 사용된다. 해당 타입의 모든 빈을 래핑하는 캐시매니저(CacheManager)가 생성된다.


#### JCache (JSR-107)
JCache는 클래스패스 있는 `javax.cache.spi.CachingProvider`를 통해 부트스트랩되며(즉, JSR-107 호환 캐싱 라이브러리가 클래스패스에 존재함) J캐시캐시매니저(JCacheCacheManager)는 `spring-boot-starter-cache`에 의해 제공된다. 다양한 호환 라이브러리를 사용할 수 있으며 스프링 부트는 Ehcache 3, 헤이즐캐스트(Hazelcast) 및 인피니스판(Infinispan)에 대한 의존성 관리를 제공한다. 다른 호환 라이브러리도 추가할 수 있다.

둘 이상의 프로바이더가 존재할 수 있으며, 이 경우 프로바이더를 명시적으로 지정해야 한다. JSR-107 표준이 구성 파일의 위치를 ​​정의하는 표준화된 방법을 적용하지 않더라도 스프링 부트는 다음 예제와 같이 구현 세부 사항으로 캐시 설정을 수용하기 위해 최선을 다한다.

`프로퍼티스(Properties)`
```
# 둘 이상의 프로바이더가 있는 경우에만 필요하다.
spring.cache.jcache.provider=com.example.MyCachingProvider
spring.cache.jcache.config=classpath:example.xml
```

`Yaml`
```yaml
# 둘 이상의 프로바이더가 있는 경우에만 필요하다.
spring:
  cache:
    jcache:
      provider: "com.example.MyCachingProvider"
      config: "classpath:example.xml"
```

{: .note}
캐시 라이브러리가 기본 구현과 JSR-107 지원을 모두 제공하는 경우 스프링 부트는 JSR-107 지원을 선호하므로 다른 JSR-107 구현으로 전환해도 동일한 기능을 사용할 수 있다.

{: .note}
스프링 부트 헤이즐캐스트를 일반적으로 지원합니다. 단일 해이즐캐스트인스턴스(HazelcastInstance)를 사용할 수 있는 경우 `spring.cache.jcache.config` 프로퍼티를 지정하지 않는 한 캐시매니저(CacheManager)에도 자동 재사용된다.

기본 javax.cache.cacheManager를 커스텀하는 방법에는 두 가지가 있다.
- `spring.cache.cache-names` 프로퍼티를 설정하여 시작 시 캐시를 생성할 수 있다. 커스텀 `javax.cache.configuration.Configuration` 빈이 정의된 경우 이를 커스텀하는 데 사용된다.
- `org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer` 빈은 전체 커스텀를 위해 캐시매니저(CacheManager)의 레퍼런스로 호출된다.

{: .note}
표준 `javax.cache.CacheManager` 빈이 정의되면 추상화가 기대하는 `org.springframework.cache.CacheManager` 구현에 자동으로 래핑된다. 더 이상 커스텀이 적용되지 않는다.


#### 헤이즐캐스트(Hazelcast)
스프링 부트는 헤이즐캐스트(Hazelcast)를 지원한다. 헤이즐캐스트인스턴스(HazelcastInstance)가 자동 구성되고, `com.hazelcast:hazelcast-spring`이 클래스패스에 있는 경우 자동으로 캐시매니저(CacheManager)에 래핑된다.

{: .note}
헤이즐캐스트(Hazelcast)는 J캐시(JCache) 호환 또는 스프링 캐시매니저(CacheManager) 호환 캐시로 사용할 수 있다. `spring.cache.type`을 `hazelcast`로 설정하면 스프링 부트는 캐시매니저(CacheManager) 기반 구현을 사용한다. 헤이즐캐스트(Hazelcast)를 J캐시(JCache) 호환 캐시로 사용하려면 `spring.cache.type`을 `jcache`로 설정하자. J캐시(JCache) 호환 캐시 프로바이더가 여러 개 있고 헤이즐캐스트(Hazelcast)를 강제로 사용하려는 경우 J캐시(JCache) 프로바이더를 명시적으로 설정해야 한다.


#### 인피니스판(Infinispan)
인피니스판(Infinispan)에는 기본 구성 파일 위치가 없으므로 명시적으로 지정해야 한다. 그렇지 않으면 기본 부트스트랩이 사용된다.

`프로퍼티스(Properties)`
```
spring.cache.infinispan.config=infinispan.xml
```

`Yaml`
```yaml
spring:
  cache:
    infinispan:
      config: "infinispan.xml"
```
`spring.cache.cache-names` 프로퍼티를 설정하여 시작 시 캐시를 생성할 수 있다. 커스텀 컨피규레이션빌더(ConfigurationBuilder) 빈이 정의된 경우 캐시를 커스텀하는 데 사용된다.

스프링 부트의 자카르타 EE 9 기준과 호환되려면 인피니스판의 `-jakarta` 모듈을 사용해야 한다. `-jakarta` 변형이 있는 모든 모듈의 경우 표준 모듈 대신 변형을 사용해야 한다. 예를 들어 `infinispan-core-jakarta` 및 `infinispan-commons-jakarta`는 각각 `infinispan-core` 및 `infinispan-commons` 대신 사용해야 한다.


#### 카우치베이스(Couchbase)
스프링 데이터 카우치베이스를 사용할 수 있고 카우치베이스가 구성된 경우 카우치베이스캐시매니저(CouchbaseCacheManager)가 자동 구성된다. `spring.cache.cache-names` 프로퍼티를 설정하여 시작 시 추가 캐시를 생성할 수 있으며, `spring.cache.couchbase.*` 프로퍼티스를 사용하여 캐시 기본값을 구성할 수 있다. 예를 들어 다음 구성은 항목 만료 시간이 10분인 캐시1 및 캐시2 캐시를 생성한다.

`프로퍼티스(Properties)`
```
spring.cache.cache-names=cache1,cache2
spring.cache.couchbase.expiration=10m
```

`Yaml`
```yaml
spring:
  cache:
    cache-names: "cache1,cache2"
    couchbase:
      expiration: "10m"
```

구성에 대한 추가 제어가 필요한 경우 카우치베이스캐시매니저빌더커스터마이저(CouchbaseCacheManagerBuilderCustomizer) 빈 등록을 고려하자. 다음 예제에서는 캐시1 및 캐시2에 대한 특정 아이템 만료를 구성하는 커스터마이저를 보여준다.

`자바`
```java
import java.time.Duration;
import org.springframework.boot.autoconfigure.cache.CouchbaseCacheManagerBuilderCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.couchbase.cache.CouchbaseCacheConfiguration;

@Configuration(proxyBeanMethods = false)
public class MyCouchbaseCacheManagerConfiguration {
    @Bean
    public CouchbaseCacheManagerBuilderCustomizer myCouchbaseCacheManagerBuilderCustomizer() {
        return (builder) -> builder
                .withCacheConfiguration(
                    "cache1", 
                    CouchbaseCacheConfiguration.defaultCacheConfig()
                    .entryExpiry(Duration.ofSeconds(10))
                )
                .withCacheConfiguration(
                    "cache2", 
                    CouchbaseCacheConfiguration.defaultCacheConfig()
                    .entryExpiry(Duration.ofMinutes(1))
                );
    }
}
```

`코틀린`
```kotlin
import org.springframework.boot.autoconfigure.cache.CouchbaseCacheManagerBuilderCustomizer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.data.couchbase.cache.CouchbaseCacheConfiguration
import java.time.Duration

@Configuration(proxyBeanMethods = false)
class MyCouchbaseCacheManagerConfiguration {
    @Bean
    fun myCouchbaseCacheManagerBuilderCustomizer(): CouchbaseCacheManagerBuilderCustomizer {
        return CouchbaseCacheManagerBuilderCustomizer { builder ->
            builder
                .withCacheConfiguration(
                    "cache1", 
                    CouchbaseCacheConfiguration.defaultCacheConfig()
                    .entryExpiry(Duration.ofSeconds(10))
                )
                .withCacheConfiguration(
                    "cache2", 
                    CouchbaseCacheConfiguration.defaultCacheConfig()
                    .entryExpiry(Duration.ofMinutes(1))) 
        }
    } 
}
```


#### 레디스(Redis)
레디스를 구성한 경우, 레디스캐시매니저(RedisCacheManager)가 자동으로 구성된다. `spring.cache.cache-names` 프로퍼티스를 설정하여 시작 시 추가 캐시를 생성할 수 있으며, `spring.cache.redis.*` 프로퍼티스를 사용하여, 캐시 기본값을 구성할 수 있다. 예를 들어 다음 구성은 TTL(Time to Live)이 10분인 캐시1 및 캐시2 캐시를 생성한다.

`프로퍼티스(Properties)`
```
spring.cache.cache-names=cache1,cache2
spring.cache.redis.time-to-live=10m
```

`Yaml`
```yaml
spring:
  cache:
    cache-names: "cache1,cache2"
    redis:
      time-to-live: "10m"
```

{: .note}
기본적으로, 두 개의 별도 캐시가 동일한 키를 사용하는 경우 레디스는 겹치는 키가 없고 잘못된 값을 반환할 수 없도록 키 접두사를 추가한다. 자체 레디스캐시매니저(RedisCacheManager)를 생성하는 경우 이 설정을 활성화된 상태로 유지하는 것이 좋다.

{: .note}
자신만의 레디스캐시컨피규레이션(RedisCacheConfiguration) @Bean을 추가하여 기본 구성을 완전히 제어할 수 있다. 이는 기본 직렬화 전략을 커스텀해야 하는 경우 유용할 수 있다.

구성에 대한 추가 제어가 필요한 경우 레디스캐시매니저빌더커스터마이저(RedisCacheManagerBuilderCustomizer) 빈 등록을 고려하자. 다음 예제에서는 캐시1 및 캐시2에 대한 특정 TTL(Time to Live)을 구성하는 커스터마이저를 보여준다.

`자바`
```java
import java.time.Duration;
import org.springframework.boot.autoconfigure.cache.RedisCacheManagerBuilderCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;

@Configuration(proxyBeanMethods = false)
public class MyRedisCacheManagerConfiguration {
    @Bean
    public RedisCacheManagerBuilderCustomizer myRedisCacheManagerBuilderCustomizer() {
        return (builder) -> 
            builder.withCacheConfiguration(
                "cache1", 
                RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofSeconds(10))
            )
            .withCacheConfiguration(
                "cache2", 
                RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(1))
            );
    } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.autoconfigure.cache.RedisCacheManagerBuilderCustomizer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.data.redis.cache.RedisCacheConfiguration
import java.time.Duration

@Configuration(proxyBeanMethods = false)
class MyRedisCacheManagerConfiguration {
    @Bean
    fun myRedisCacheManagerBuilderCustomizer(): RedisCacheManagerBuilderCustomizer {
        return RedisCacheManagerBuilderCustomizer { builder ->
            builder.withCacheConfiguration(
                "cache1", 
                RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofSeconds(10))
            ).withCacheConfiguration(
                "cache2", 
                RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(1))
            ) 
        }
    } 
}
```


#### 카페인(Caffeine)
카페인은 구아바(Guava)에 대한 지원을 대체하는 구아바 캐시의 자바 8 재작성이다. 카페인(Caffeine)이 있으면 카페인캐시매니저(CaffeineCacheManager)(spring-boot-starter-cache "스타터"에서 제공)가 자동으로 구성된다. `spring.cache.cache-names` 프로퍼티를 설정하여 시작 시 캐시를 생성할 수 있으며 다음 중 하나를 사용하여 표시된 순서대로 커스텀할 수 있다:

1. `spring.cache.caffeine.spec`에 정의된 캐시 사양
2. `com.github.benmanes.caffeine.cache.CaffeineSpec` 빈이 정의됐다.
3. `com.github.benmanes.caffeine.cache.Caffeine` 빈이 정의됐다.

예를 들어, 다음 구성은 최대 크기가 500이고 TTL(Time to Live)이 10분인 캐시1 및 캐시2 캐시를 생성한다.

`프로퍼티스(Properties)`
```
spring.cache.cache-names=cache1,cache2
spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s
```

`Yaml`
```yaml
spring:
  cache:
    cache-names: "cache1,cache2"
    caffeine:
      spec: "maximumSize=500,expireAfterAccess=600s"
```

`com.github.benmanes.caffeine.cache.CacheLoader` 빈이 정의되면 자동으로 카페인캐시매니저(CaffeineCacheManager)에 연결된다. 캐시로더(CacheLoader)는 캐시매니저가 관리하는 모든 캐시와 연결되므로 CacheLoader<Object, Object>로 정의해야 한다. 자동 구성은 다른 제네릭 타입을 무시한다.


#### 캐시2k(Cache2k)
캐시2k(Cache2k)는 인메모리 캐시다. 캐시2k 스프링 인테그레이션이 있는 경우 스프링캐시2k캐시매니저(SpringCache2kCacheManager)가 자동 구성된다.

`spring.cache.cache-names` 프로퍼티를 설정하여 시작 시 캐시를 생성할 수 있다. 캐시 기본값은 캐시2빌더커스터마이저(Cache2kBuilderCustomizer) 빈을 사용하여 커스텀할 수 있다. 다음 예제에서는 만료 시간이 5분인 캐시 용량을 항목 200개로 구성하는 커스터마이저를 보여준다.

`자바`
```java
import java.util.concurrent.TimeUnit;
import org.springframework.boot.autoconfigure.cache.Cache2kBuilderCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
public class MyCache2kDefaultsConfiguration {
    @Bean
    public Cache2kBuilderCustomizer myCache2kDefaultsCustomizer() {
        return (builder) -> builder.entryCapacity(200)
                .expireAfterWrite(5, TimeUnit.MINUTES);
    } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.autoconfigure.cache.Cache2kBuilderCustomizer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import java.util.concurrent.TimeUnit

@Configuration(proxyBeanMethods = false)
class MyCache2kDefaultsConfiguration {
    @Bean
    fun myCache2kDefaultsCustomizer(): Cache2kBuilderCustomizer {
        return Cache2kBuilderCustomizer { builder ->
            builder.entryCapacity(200)
            .expireAfterWrite(5, TimeUnit.MINUTES)
        } 
    }
}
```


#### 심플(Simple)
다른 프로바이더를 찾을 수 없으면 컨커런트해시맵(ConcurrentHashMap)을 캐시 저장소로 사용하는 간단한 구현이 구성된다. 애플리케이션에 캐싱 라이브러리가 없는 경우 이것이 기본값이다. 기본적으로 캐시는 필요에 따라 생성되지만,  cache-names 프로퍼티를 설정하여 사용 가능한 캐시 목록을 제한할 수 있다. 예를 들어, 캐시1 및 캐시2 캐시만 원하는 경우 cache-names 프로퍼티를 다음과 같이 설정한다.

`프로퍼티스(Properties)`
```
spring.cache.cache-names=cache1,cache2
```

`Yaml`
```yaml
spring:
  cache:
    cache-names: "cache1,cache2"
```

그렇게 하고 애플리케이션이 나열되지 않은 캐시를 사용하는 경우, 캐시가 필요할 때 런타임에서 실패하지만 시작 시에는 실패하지 않는다. 이는 선언되지 않은 캐시를 사용할 경우 "실제" 캐시 프로바이더가 작동하는 방식과 유사하다.


#### 없음(None)
`@EnableCaching`이 구성에 있으면 적절한 캐시 구성도 필요하다. 특정 환경에서 캐싱을 완전히 비활성화해야 하는 경우, 다음 예제와 같이 캐시 타입을 없음으로 강제 실행하여 무작동 구현(no-op)을 사용한다.


`프로퍼티스(Properties)`
```
spring.cache.type=none
```

`Yaml`
```yaml
spring:
  cache:
    type: "none"
```