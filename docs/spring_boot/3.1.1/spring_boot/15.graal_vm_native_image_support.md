---
layout: default
title: 15. GraalVM 네이티브 이미지 지원(GraalVM Native Image Support)
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 15
---

[원문 - GraalVM Native Image Support](https://docs.spring.io/spring-boot/docs/3.1.1/reference/html/native-image.html#native-image)

***

- 15. GraalVM 네이티브 이미지 지원(GraalVM Native Image Support)
  - 15.1. GraalVM 네이티브 이미지 소개(Introducing GraalVM Native Images)
    - 15.1.1. JVM 배포의 주요 차이점(Key Differences with JVM Deployments)
    - 15.1.2. 스프링 Ahead-of-Time 이해(Understanding Spring Ahead-of-Time Processing)
      - 소스 코드 생성(Source Code Generation)Source Code Generation
      - 힌트 파일 생성(Hint File Generation)
      - 프록시 클래스 생성(Proxy Class Generation)
  - 15.2. Developing Your First GraalVM Native Application
    - 15.2.1. Sample Application
    - 15.2.2. Building a Native Image Using Buildpacks
      - System Requirements
      - Using Maven
      - Using Gradle
      - Running the example
    - 15.2.3. Building a Native Image using Native Build Tools
      - Prerequisites
      - Using Maven
      - Using Gradle
      - Running the Example
    - 15.3. Testing GraalVM Native Images
      - 15.3.1. Testing Ahead-of-time Processing With the JVM
      - 15.3.2. Testing With Native Build Tools
        - Using Maven
        - Using Gradle
    - 15.4. Advanced Native Images Topics
      - 15.4.1. Nested Configuration Properties
      - 15.4.2. Converting a Spring Boot Executable Jar
        - Using Buildpacks
        - Using GraalVM native-image
      - 15.4.3. Using the Tracing Agent
        - Launch the Application Directly
      - 15.4.4. Custom Hints
        -  Testing custom hints
      - 15.4.5. Known Limitations
    - 15.5. What to Read Next

***


# 15. GraalVM 네이티브 이미지 지원(GraalVM Native Image Support)
GraalVM 네이티브 이미지는 컴파일된 자바 애플리케이션을 미리 처리하여 생성할 수 있는 독립형 실행 파일이다. 네이티브 이미지는 일반적으로 JVM 이미지보다 메모리 공간이 더 작고 더 빠르게 시작된다.


## 15.1. GraalVM 네이티브 이미지 소개(Introducing GraalVM Native Images)
GraalVM 네이티브 이미지는 자바 애플리케이션을 배포하고 실행하는 새로운 방법을 제공한다. 자바 버추얼 머신에 비해 네이티브 이미지는 더 작은 메모리 공간과 훨씬 더 빠른 시작 시간으로 실행될 수 있다.

이는 컨테이너 이미지를 사용하여 배포되는 애플리케이션에 매우 적합하며 FaaS(Function as a Service) 플랫폼과 결합할 때 특히 그렇다.

JVM용으로 작성된 기존 애플리케이션과 달리 GraalVM 네이티브 이미지 애플리케이션은 실행 파일을 생성하기 위해 사전 처리가 필요하다. 이러한 사전 처리에는 기본 진입점에서 애플리케이션 코드를 정적으로 분석하는 작업이 포함된다.

GraalVM 네이티브 이미지는 플랫폼별 실행 파일이다. 네이티브 이미지를 실행하기 위해 자바 버추얼 머신을 제공할 필요는 없다.

{: .note}
GraalVM을 시작하고 실험하고 싶다면 "첫 번째 GraalVM 네이티브 애플리케이션 개발" 장으로 건너뛰고 나중에 이 장으로 돌아올 수 있다.


### 15.1.1. JVM 배포의 주요 차이점(Key Differences with JVM Deployments)
GraalVM 네이티브 이미지가 미리 생성된다는 사실은 기본 애플리케이션과 JVM 기반 애플리케이션 간에 몇 가지 차이점이 있다. 차이점은 다음과 같습니다.

- 애플리케이션의 정적 분석은 빌드 시 기본 진입점에서 수행된다.
- 네이티브 이미지가 생성될 때 접근할 수 없는 코드는 제거되고 실행 파일의 일부가 되지 않는다.
- GraalVM은 코드의 동적 엘리먼트를 직접 인식하지 못하며 리플렉션, 리소스, 직렬화 및 동적 프록시에 대해 알려주어야 한다.
- 애플리케이션 클래스패스는 빌드 시 고정되며 변경할 수 없다.
- 레이지(lazy) 클래스 로딩이 없으며, 실행 파일에 포함된 모든 것이 시작 시 메모리에 로드된다.
- 완전히 지원되지 않는 자바 애플리케이션의 일부 기능은 몇 가지 제한사항이 있다.

{: .note}
GraalVM 레퍼런스 문서의 [네이티브 이미지 호환성 가이드](https://www.graalvm.org/22.3/reference-manual/native-image/metadata/Compatibility/)에서는 GraalVM 제한 사항에 대한 자세한 내용을 제공한다.


### 15.1.2. 스프링 Ahead-of-Time 이해(Understanding Spring Ahead-of-Time Processing)
일반적인 스프링 부트 애플리케이션은 매우 동적이며 구성은 런타임에 수행된다. 실제로 스프링 부트 자동 구성은 올바른 구성을 위해 런타임 상태 반응에 크게 의존한다.

애플리케이션의 이러한 동적 측면을 GraalVM에 알리는 것이 가능하더라도 그렇게 하면 정적 분석의 이점이 대부분 없어진다. 따라서 대신 스프링 부트를 사용하여 네이티브 이미지를 생성할 때는 닫힌 세계로 가정하고 애플리케이션의 동적 측면은 제한된다.

닫힌 세계 가정은 다음과 같은 제한 사항을 의미한다.
- 클래스패스는 고정되어 있으며 빌드 시 완전히 정의된다.
- 애플리케이션에 정의된 빈은 런타임 시 변경될 수 없다. 즉, 다음과 같다.
  - 스프링 `@Profile` 어노테이션과 프로필별 구성에는 제한이 있다.
  - 빈이 생성되면 변경되는 프로퍼티(예: `@ConditionalOnProperty` 및 `.enable` 프로퍼티스)은 지원되지 않다.

이러한 제한 사항이 적용되면 스프링이 빌드 시간 동안 전처리를 수행하고 GraalVM이 사용할 수 있는 추가 자산(asset)을 생성하는 것이 가능해진다. 스프링 AOT 처리 애플리케이션은 일반적으로 다음을 생성한다.
- 자바 소스 코드
- 바이드코드(다이나믹 프록시 등)
- GraalVM JSON 힌트 파일:
  - 리소스 힌트(resource-config.json)
  - 리플렉션 힌트(reflect-config.json)
  - 직렬화(Serialization) 힌트(serialization-config.json)
  - 자바 프록시 힌트(proxy-config.json)
  - JNI 힌트(jni-config.json)


#### 소스 코드 생성(Source Code Generation)
스프링 애플리케이션은 스프링 빈으로 구성된다. 내부적으로 스프링 프레임워크는 두 가지 별개의 개념을 사용하여 빈을 관리한다. 실제로 생성되어 다른 빈에 주입될 수 있는 빈 인스턴스가 있다. 빈의 애트리뷰트와 인스턴스 생성 방법을 정의하는 데 사용되는 빈 정의도 있다.

일반적인 `@Configuration` 클래스 사용 예제다.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
public class MyConfiguration {
  @Bean
  public MyBean myBean() {
    return new MyBean();
  }
}
```

빈 정의는 `@Configuration` 클래스를 파싱하여 `@Bean` 메소드를 찾아 생성한다. 위의 예제에서는 `myBean`이라는 싱글톤 빈에 대한 `BeanDefinition`을 정의한다. 또한 `MyConfiguration` 클래스 자체에 대한 `BeanDefinition`을 생성하고 있다.

`myBean` 인스턴스가 필요할 때 스프링은 `myBean()` 메서드를 호출하고 그 결과를 사용해야 한다는 것을 알고 있다. JVM에서 실행할 때 `@Configuration` 클래스 파싱은 애플리케이션이 시작되고 `@Bean` 메소드가 리플렉션을 사용하여 호출할 때 발생한다.

네이티브 이미지를 생성할 때 스프링은 다른 방식으로 작동한다. `@Configuration` 클래스를 파싱하고 런타임에 비 정의를 생성하는 대신 빌드 타임에 수행한다. 빈 정의가 검색되면 처리되어 GraalVM 컴파일러에서 분석할 수 있는 소스 코드로 변환된다.

스프링 AOT 프로세스는 위의 구성 클래스를 다음과 같은 코드로 변환한다.

```java
import org.springframework.beans.factory.aot.BeanInstanceSupplier;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.RootBeanDefinition;

/**
 * {@link MyConfiguration}에 대한 빈 정의다.
 */
public class MyConfiguration__BeanDefinitions {
  /**
    * 'myConfiguration'에 대한 빈 정의를 가져온다.
    */
  public static BeanDefinition getMyConfigurationBeanDefinition() {
      Class<?> beanType = MyConfiguration.class;
      RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);
      beanDefinition.setInstanceSupplier(MyConfiguration::new);
      return beanDefinition;
  }

  /**
    * 'myBean'에 대한 빈 인스턴스 공급자(supplier)를 가져온다.
    */
  private static BeanInstanceSupplier<MyBean> getMyBeanInstanceSupplier() {
      return BeanInstanceSupplier.<MyBean>forFactoryMethod(MyConfiguration.class, "myBean")
          .withGenerator((registeredBean) -> registeredBean.getBeanFactory().getBean(MyConfiguration.class).myBean());
  }

  /**
   * 'myBean'에 대한 빈 정의를 가져온다.
    */
  public static BeanDefinition getMyBeanBeanDefinition() {
    Class<?> beanType = MyBean.class;
    RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType);
    beanDefinition.setInstanceSupplier(getMyBeanInstanceSupplier());
    return beanDefinition;
  } 
}
```

{: .note}
생성된 정확한 코드는 빈 정의 특성에 따라 다를 수 있다.

위에서 생성된 코드는 `@Configuration` 클래스와 동등한 빈 정의를 생성하지만 GraalVM이 이해할 수 있는 직접적인 방식임을 볼 수 있다.

`myConfiguration` 빈에 대한 빈 정의와 `myBean`에 대한 정의가 있다. `myBean` 인스턴스가 필요할 때 `BeanInstanceSupplier`가 호출됩니다. 이 공급자(supplier)는 `myConfiguration` 빈에서 `myBean()` 메소드를 호출한다.

{: .note}
스프링 AOT 처리 중에 애플리케이션은 빈 정의가 사용 가능한 지점까지 시작된다. AOT 처리 단계에서는 빈 인스턴스가 생성되지 않는다.

스프링 AOT는 모든 빈 정의에 대해 이와 같은 코드를 생성한다. 또한 빈 사후 처리가 필요할 때(예: `@Autowired` 메소드 호출) 코드를 생성한다. AOT 처리된 애플리케이션이 실제로 실행될 때 스프링 부투에서 애플리케이션컨텍스트(ApplicationContext)를 초기화하는 데 사용되는 애플리케이션컨텍스트이니셜라이저(ApplicationContextInitializer)도 생성된다.

AOT에서 생성된 소스 코드는 장황할 수 있지만 읽기 쉽고 애플리케이션을 디버깅할 때 도움이 될 수 있다. 생성된 소스 파일은 메이븐을 사용하고 그레이들에서 `build/generated/aotSources`를 사용할 때 `target/spring-aot/main/sources`에서 찾을 수 있다.


#### 힌트 파일 생성(Hint File Generation)
소스 파일을 생성하는 것 외에도 스프링 AOT 엔진은 GraalVM에서 사용되는 힌트 파일도 생성한다. 힌트 파일에는 GraalVM이 코드를 직접 검사하여 이해할 수 없는 항목을 처리하는 방법을 설명하는 JSON 데이터가 포함되어 있다.

예를 들어, 프라이빗 메소드에 스프링 어노테이션을 사용할 수 있다. 스프링은 GraalVM에서도 프라이빗 메소드를 호출하기 위해 리플렉션을 사용해야 한다. 이러한 상황이 발생하면 스프링은 프라이빗 메서드가 직접 호출되지 않더라도 여전히 네이티브 이미지에서 사용할 수 있어야 함을 GraalVM이 알 수 있도록 리플렉션 힌트를 작성할 수 있다.

힌트 파일은 `META-INF/native-image` 아래에 생성되며 GraalVM에서 자동으로 선택된다.

{: .note}
생성된 힌트 파일은 메이븐을 사용하고 그레이들에서 `build/generated/aotResources`를 사용할 때 `target/spring-aot/main/resources`에서 찾을 수 있다.


#### 프록시 클래스 생성(Proxy Class Generation)
스프링은 때때로 추가 기능으로 작성한 코드를 향상시키기 위해 프록시 클래스를 생성해야 한다. 이를 위해 바이트코드를 직접 생성하는 `cglib` 라이브러리를 사용한다.

애플리케이션이 JVM에서 실행 중인 경우 애플리케이션이 실행될 때 프록시 클래스가 동적으로 생성된다. 네이티브 이미지를 생성할 때 이러한 프록시는 GraalVM에 포함될 수 있도록 빌드 시 생성되어야 한다.

{: .note}
소스 코드 생성과 달리 생성된 바이트코드는 애플리케이션을 디버깅할 때 특별히 도움이 되지 않는다. 그러나 `javap`와 같은 도구를 사용하여 `.class` 파일의 내용을 검사해야 하는 경우 메이븐은 `target/spring-aot/main/classes`에서, 그레이들은 `build/generated/aotClasses`에서 찾을 수 있다.
