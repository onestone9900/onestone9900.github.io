---
layout: default
title: 7. Core Features
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 7
---

# 7. Core Features
이 장에서는 스프링 부트 세부 사항을 자세히 살펴본다. 여기서는 사용하고 커스텀할 수 있는 주요 기능에 대해 알아볼 수 있다. "[Getting Started](https://onestone9900.github.io/docs/spring_boot/3.1.1/spring_boot/4.getting_started/#4-getting-started)" 및 "[Developing with Spring Boot](https://onestone9900.github.io/docs/spring_boot/3.1.1/spring_boot/6.developing_with_spring_boot/)"을 아직 읽지 않았다면 먼저 읽고 기본 사항에 대한 기초를 다지는 것이 좋다.


## 7.1. SpringApplication
`스프링애플리케이션(SpringApplication)` 클래스는 `main()` 메서드에서 시작되는 스프링 애플리케이션을 부트스트랩하는 편리한 방법을 제공한다. 다양한 상황에서 다음 예제와 같이 `static SpringApplication.run` 메서드에 위임할 수 있다:

`자바`
```java
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class MyApplication {
        public static void main(String[] args) {
            SpringApplication.run(MyApplication.class, args);
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.boot.runApplication

    @SpringBootApplication
    class MyApplication
    
    fun main(args: Array<String>) {
        runApplication<MyApplication>(*args)
    }
```

애플리케이션이 시작되면 다음 출력과 비슷한 내용이 표시된다:
```
 .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.1.1)
2023-06-22T12:08:14.396Z INFO 22973 --- [ main] o.s.b.d.f.s.MyApplication
: Starting MyApplication using Java 17.0.7 with PID 22973 (/opt/apps/myapp.jar started by myuser in /opt/apps/)
2023-06-22T12:08:14.413Z INFO 22973 --- [ main] o.s.b.d.f.s.MyApplication
: No active profile set, falling back to 1 default profile: "default" 2023-06-22T12:08:16.739Z INFO 22973 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)
2023-06-22T12:08:16.765Z INFO 22973 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2023-06-22T12:08:16.766Z INFO 22973 --- [ main] o.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/10.1.10]
2023-06-22T12:08:17.261Z INFO 22973 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext
2023-06-22T12:08:17.280Z INFO 22973 --- [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 2705 ms
2023-06-22T12:08:18.801Z INFO 22973 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ''
2023-06-22T12:08:18.840Z INFO 22973 --- [ main] o.s.b.d.f.s.MyApplication
: Started MyApplication in 5.871 seconds (process running for 7.263)
22T12:08:18.916Z INFO 22973 --- [ionShutdownHook] o.apache.catalina.core.StandardService : Stopping service [Tomcat]
```

기본적으로, 애플리케이션을 시작한 사용자와 같이, 일부 관련 시작 세부 정보를 포함한 `INFO` 로깅 메시지가 표시된다. `INFO` 이외의 로그 레벨이 필요한 경우 로그 레벨에 설명된 대로 설정할 수 있다. 애플리케이션 버전은 메인 애플리케이션 클래스 패키지의 구현 버전을 사용하여 결정된다. `spring.main.log-startup-info`를 `false`로 설정하면 시작 정보 로깅을 끌 수 있다. 그러면 애플리케이션의 활성 프로필에 대한 로깅도 꺼진다.

{: .note}
시작하는 동안 로깅을 추가하려면 `스프링애플리케이션(SpringApplication)`의 하위 클래스에서 `logStartupInfo(boolean)`을 오버라이드할 수 있다.


### 7.1.1. Startup Failure
애플리케이션이 시작되지 않으면 등록된 `페일러애널라이저(FailureAnalyzer)`가 전용 오류 메시지와 문제 해결을 위한 구체적인 조치사항를 제공한다. 예를 들어, 포트 `8080`에서 웹 애플리케이션을 시작했는데 해당 포트가 이미 사용 중이라면 다음 메시지와 비슷한 내용이 표시된다:
```
    ***************************
    APPLICATION FAILED TO START
    ***************************
    
    Description:
    
    Embedded servlet container failed to start. Port 8080 was already in use.
    
    Action:

    Identify and stop the process that is listening on port 8080 or configure this application to listen on another port.
```

{: .note}
스프링 부트는 다양한 `페일러애널라이저(FailureAnalyzer)` 구현체를 제공하며 사용자가 직접 추가할 수 있다.

페일러 애널라이저(failure analyzer)가 예외를 처리할 수 없는 경우에도 전체 상태를 표시하여 무엇이 잘못되었는지 잘 이해할 수 있다. 이렇게 하려면 `디버그(debug) 프로퍼티를 활성화`하거나 `org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener`에 대한 `DEBUG` 로깅을 활성화해야 한다.

예를 들어, `java -jar`을 사용하여 애플리케이션을 실행하는 경우 다음과 같이 디버그(debug) 프로퍼티을 활성화할 수 있다:
```
    $ java -jar myproject-0.0.1-SNAPSHOT.jar --debug
```


### 7.1.2. Lazy Initialization
`스프링애플리케이션(SpringApplication)`을 사용하면 애플리케이션을 느리게(lazily) 초기화할 수 있다. 지연 초기화(lazy initialization)가 활성화되면 애플리케이션 시작 중이 아닌 필요할 때 빈이 생성된다. 결과적으로 지연 초기화를 활성화하면 애플리케이션을 시작하는 데 걸리는 시간을 줄일 수 있다. 웹 애플리케이션에서 지연 초기화를 활성화하면 HTTP 요청이 수신될 때까지 많은 웹 관련 빈이 초기화되지 않는다.


지연 초기화의 단점은 애플리케이션의 문제 발견이 지연될 수 있다는 것이다. 잘못 구성된 빈이 느리게 초기화되면, 시작 중에는 실패가 발생하지 않으며 빈이 초기화될 때만 문제가 발생한다. 또한 JVM에 시작 중에 초기화되는 빈뿐만 아니라 모든 애플리케이션 빈을 수용할 수 있는 충분한 메모리가 있는지 확인해야 한다. 이러한 이유로 지연 초기화는 기본적으로 활성화되지 않으며 지연 초기화를 활성화하기 전에 JVM의 힙 크기를 조정하는 것이 좋다.

지연 초기화는 `스프링애플리케이션빌더(SpringApplicationBuilder)`의 `lazyInitialization` 메소드 또는 `스프링애플리케이션(SpringApplication)`의 `setLazyInitialization` 메소드를 사용하여 프로그래밍 방식으로 활성화할 수 있다. 또는 다음 예제와 같이 `spring.main.lazy-initialization` 프로퍼티을 사용하여 활성화할 수 있다:

`프로퍼티스(Properties)`
```
    spring.main.lazy-initialization=true
```

`Yaml`
```yaml
    spring:
        main:
            lazy-initialization: true
```

{: .note}
애플리케이션의 나머지 부분에 대한 지연 초기화를 사용하는 동안 특정 빈에 대한 지연 초기화를 비활성화하려는 경우 `@Lazy(false)` 어노테이션을 사용하여 해당 빈의 `lazy` 애트리뷰트를 `false`로 설정할 수 있다.


### 7.1.3. Customizing the Banner
시작할 때 인쇄되는 배너는 클래스패스에 `banner.txt` 파일을 추가하거나 `spring.banner.location` 프로퍼티를 해당 파일의 위치로 설정하여 변경할 수 있다. 파일에 UTF-8 이외의 인코딩이 있는 경우 `spring.banner.charset`을 설정할 수 있다.

`banner.txt` 파일 내에서, 환경변수에서 사용 가능한 모든 키와 다음의 자리표시자(placeholders)를 사용할 수 있다:

테이블 4. 배너 변수

|***변수***|***설명***|
|---|---|
|`${application.version}`|`MANIFEST.MF`에 선언된 애플리케이션의 버전이다. 예를 들어, `Implement-Version: 1.0`은 1.0으로 표시된다.|
|`${application.formatted-version}`|`MANIFEST.MF`에 선언되고 표시용 포맷으로 지정된 애플리케이션의 버전 번호이다(대괄호로 묶이고 접두사 v가 붙음). 예를 들어 `(v1.0)`.|
|`${spring-boot.version}`|사용 중인 스프링 부트 버전이다. 예를 들어 `3.1.1.`|
|`${spring-boot.formatted-version}`|사용 중인 스프링 부트 버전으로, 표시용으로 포맷이 지정됐다(대괄호로 묶이고 접두사 v가 붙음). 예를 들면 `(v3.1.1)`이다.|
|`${Ansi.NAME}(or ${AnsiColor.NAME}, ${AnsiBackground.NAME}, ${AnsiStyle.NAME})`|여기서 `NAME`은 ANSI 이스케이프 코드의 이름입니다. 자세한 내용은 [`AnsiPropertySource`](https://github.com/spring-projects/spring-boot/blob/v3.1.1/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java)를 참고하자.|
|`${application.title}`|`MANIFEST.MF`에 선언된 애플리케이션의 타이틀이다. 예를 들어 `Implement-Title: MyApp`은 `MyApp`로 표시된다.|

{: .note}
프로그래밍 방식으로 배너를 생성하려는 경우 `SpringApplication.setBanner(...)` 메서드를 사용할 수 있다. `org.springframework.boot.Banner` 인터페이스를 사용하고 자신만의 `printBanner()` 메소드를 구현해보자.

`spring.main.banner-mode` 프로퍼티을 사용하여 배너를 표시해야 하는지 결정할 수도 있다. `System.out`(`console`)에서 구성된 로거로 전송되거나(`log`) 전혀 생성되지 않는다(`off`).

표시된 배너는 `springBootBanner`이라는 명칭으로 싱글톤 빈이 등록된다.

{: .note}
${application.version} 및 ${application.formatted-version} 프로퍼티는 스프링 부트 런처(launchers)를 사용하는 경우에만 사용할 수 있다. 압축이 풀린 jar를 실행하고 `java -cp <classpath> <mainclass>`로 시작하는 경우 값이 확인되지 않는다.


### 7.1.4. Customizing SpringApplication
`스프링애플리케이션(SpringApplication)` 기본값이 마음에 들지 않으면 대신 로컬 인스턴스를 생성하고 커스텀할 수 있다. 예를 들어 배너를 끄려면 다음과 같이 작성할 수 있다:

`자바`
```java
    import org.springframework.boot.Banner;
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class MyApplication {
        public static void main(String[] args) {
            SpringApplication application = new SpringApplication(MyApplication.class);
            application.setBannerMode(Banner.Mode.OFF);
            application.run(args);
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.Banner
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.boot.runApplication

    @SpringBootApplication
    class MyApplication
    fun main(args: Array<String>) {
        runApplication<MyApplication>(*args) {
            setBannerMode(Banner.Mode.OFF)
        }
    }
```

{: .note}
`스프링애플리케이션(SpringApplication)`에 전달된 생성자 아규먼트는 스프링 빈의 구성 소스이다. 대부분의 경우 `@Configuration` 클래스에 대한 참조이지만 `@Component` 클래스를 직접 참조할 수도 있다.

`application.properties` 파일을 사용하여 `스프링애플리케이션(SpringApplication)`을 구성하는 것도 가능하다. 자세한 내용은 Externalized Configuration을 참고하자.

구성 옵션의 전체 목록은 [`스프링애플리케이션(SpringApplication)` Javadoc](https://docs.spring.io/spring-boot/docs/3.1.1/api/org/springframework/boot/SpringApplication.html)을 참고하자.


### 7.1.5. Fluent Builder API
`애플리케이션컨텍스트(ApplicationContext)` 계층 구조(상위/하위 관계가 있는 다중 컨텍스트)를 구축해야 하거나 "`플루언트(fluent)`" 빌더 API 사용을 선호하는 경우 `스프링애플리케이션빌더(SpringApplicationBuilder)`를 사용할 수 있다.

`스프링애플리케이션빌더(SpringApplicationBuilder)`를 사용하면 여러 메서드 호출을 연결할 수 있으며 다음 예제와 같이 계층 구조를 만들 수 있는 상위 및 하위 메서드가 포함되어 있다:

`자바`
```java
    new SpringApplicationBuilder().sources(Parent.class)
        .child(Application.class)
        .bannerMode(Banner.Mode.OFF)
        .run(args);
```

`코틀린`
```kotlin
    SpringApplicationBuilder()
        .sources(Parent::class.java)
        .child(Application::class.java)
        .bannerMode(Banner.Mode.OFF)
        .run(*args)
```

{: .note}
`애플리케이션컨텍스트(ApplicationContext)` 계층 구조를 생성할 때 몇 가지 제한 사항이 있다. 예를 들어 웹 컴포넌트는 하위 컨텍스트 내에 포함되어야 하며 상위 및 하위 컨텍스트 모두에 동일한 환경이 사용된다. 자세한 내용은 [`스프링애플리케이션빌더(SpringApplicationBuilder)` Javadoc](https://docs.spring.io/spring-boot/docs/3.1.1/api/org/springframework/boot/builder/SpringApplicationBuilder.html)을 참고하자.


### 7.1.6. Application Availability
플랫폼에 배포되면, 애플리케이션은 [쿠버네티스 프로브](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)와 같은 인프라를 사용하여 플랫폼에 가용성에 대한 정보를 제공할 수 있다. 스프링 부트에는 일반적으로 사용되는 "활성" 및 "준비성" 가용성 상태에 대한 지원이 있다. 스프링 부트의 "액추에이터"를 사용하는 경우 이러한 상태는 헬스(health) 엔드포인트 그룹으로 노출된다.

또한,` 애플리케이션어베일러빌리티(ApplicationAvailability)` 인터페이스를 자신의 빈에 삽입하여 가용성 상태를 얻을 수도 있다.


#### Liveness State
애플리케이션의 "활성(Liveness)" 상태는 애플리케이션이 올바르게 작동할 수 있는지, 아니면 현재 오류가 발생한 경우 자체적으로 복구할 수 있는지를 알려준다. 손상된 "활성" 상태는 애플리케이션이 복구할 수 없는 상태에 있으며 인프라가 애플리케이션을 재시작해야 함을 의미한다.

{: .note}
일반적으로, 헬스 체크가 확인하는 "활성" 상태는 외부 서버의 확인을 기반으로 해서는 안 된다. 만약 그렇다면, 외부 시스템(데이터베이스, 웹 API, 외부 캐시)의 실패로 인해 대규모 재시작이 발생하고 플랫폼 전체에 연속적인 오류가 발생하게 된다.

스프링 부트 애플리케이션의 내부 상태는 대부분 스프링 `애플리케이션컨텍스트(ApplicationContext)`로 표현된다. 애플리케이션 컨텍스트가 성공적으로 시작된 경우 스프링 부트는 애플리케이션이 유효한 상태에 있다고 가정한다. 컨텍스트가 새로 고쳐지는 즉시 애플리케이션은 라이브로 간주한다. 스프링 부트 애플리케이션 라이프사이클 및 관련 애플리케이션 이벤트를 참고하자.


#### Readiness State
애플리케이션의 "준비성" 상태는 애플리케이션이 트래픽을 처리할 준비가 되었는지 여부를 알려준다. 실패한 "준비성" 상태는 지금은 트래픽을 애플리케이션으로 라우팅해서는 안 된다는 것을 플랫폼에 알린다. 이는 일반적으로 `커맨드라인러너(CommandLineRunner)` 및 `애플리케이션러너(ApplicationRunner)` 컴포넌트가 시작하고 처리하는 동안 또는 애플리케이션이 추가 트래픽을 처리하기에는 너무 바쁘다고 판단하는 경우 언제든지 발생한다.

애플리케이션 및 커맨드라인 러너가 호출되자마자 애플리케이션은 준비된 것으로 간주된다. 스프링 부트 애플리케이션 라이프사이클 및 관련 애플리케이션 이벤트를 참고하자.

{: .note}
시작 중에 실행될 것으로 예상되는 작업은 `@PostConstruct`와 같은 스프링 컴포넌트 생명주기 콜백을 사용하는 대신 `커맨드라인러너(CommandLineRunner)` 및 `애플리케이션러너(ApplicationRunner)` 컴포넌트에 의해 실행되어야 한다.


#### Managing the Application Availability State
애플리케이션 컴포넌트는 `애플리케이션어베일러빌리티(ApplicationAvailability)` 인터페이스를 주입하고, 이에 대한 메소드를 호출하여 언제든지 현재 가용성 상태를 검색할 수 있다. 애플리케이션은 상태 업데이트를 수신하거나 애플리케이션 상태 업데이트를 하려는 경우가 많다.

예를 들어, 쿠버네티스 "exec Probe"가 이 파일을 볼 수 있도록 애플리케이션의 "준비성" 상태를 파일로 내보낼 수 있다:

`자바`
```java
    import org.springframework.boot.availability.AvailabilityChangeEvent;
    import org.springframework.boot.availability.ReadinessState;
    import org.springframework.context.event.EventListener;
    import org.springframework.stereotype.Component;

    @Component
    public class MyReadinessStateExporter {
        @EventListener
        public void onStateChange(AvailabilityChangeEvent<ReadinessState> event) {
            switch (event.getState()) {
                case ACCEPTING_TRAFFIC:
                    // /tmp/healthy 파일 생성
                    break;
                case REFUSING_TRAFFIC:
                    // /tmp/healthy 파일 제거
                    break;  
            }
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.availability.AvailabilityChangeEvent
    import org.springframework.boot.availability.ReadinessState
    import org.springframework.context.event.EventListener
    import org.springframework.stereotype.Component

    @Component
    class MyReadinessStateExporter {
        @EventListener
        fun onStateChange(event: AvailabilityChangeEvent<ReadinessState?>) {
            when (event.state) {
                ReadinessState.ACCEPTING_TRAFFIC -> {
                    // /tmp/healthy  파일 생성
                }
                ReadinessState.REFUSING_TRAFFIC -> {
                    // /tmp/healthy 파일 제거
                }
                else -> {
                    // ... 
                }
            } 
        }
    }
```

애플리케이션이 중단되어 복구할 수 없는 경우 애플리케이션 상태를 업데이트할 수도 있다:

`자바`
```java
    import org.springframework.boot.availability.AvailabilityChangeEvent;
    import org.springframework.boot.availability.LivenessState;
    import org.springframework.context.ApplicationEventPublisher;
    import org.springframework.stereotype.Component;
    
    @Component
    public class MyLocalCacheVerifier {
        private final ApplicationEventPublisher eventPublisher;
        public MyLocalCacheVerifier(ApplicationEventPublisher eventPublisher) {
            this.eventPublisher = eventPublisher;
        }

        public void checkLocalCache() {
            try {
                // ... 
            } catch (CacheCompletelyBrokenException ex) {
              AvailabilityChangeEvent.publish(this.eventPublisher, ex, LivenessState.BROKEN);
            }
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.availability.AvailabilityChangeEvent
    import org.springframework.boot.availability.LivenessState
    import org.springframework.context.ApplicationEventPublisher
    import org.springframework.stereotype.Component

    @Component
    class MyLocalCacheVerifier(private val eventPublisher: ApplicationEventPublisher) {
        fun checkLocalCache() {
            try {
                // ...
            } catch (ex: CacheCompletelyBrokenException) {
                AvailabilityChangeEvent.publish(eventPublisher, ex, LivenessState.BROKEN)
            }
        } 
    }
```

스프링 부트는 액츄에이터 헬스 엔드포인트를 통해 "활성" 및 "준비성"에 대한 쿠버네티스 HTTP 프로브를 제공한다. 다음 절에서 쿠버네티스에 스프링 부트 애플리케이션을 배포하는 방법에 대한 자세한 지침을 얻을 수 있다.


### 7.1.7. Application Events and Listeners
`컨텍스트리프레시이벤트(ContextRefreshedEvent)`와 같은 일반적인 스프링 프레임워크 이벤트 외에도 `스프링애플리케이션(SpringApplication)`은 몇 가지 추가 애플리케이션 이벤트를 보낸다.

***

`노트`

일부 이벤트는 실제로 `스프링애플리케이션(SpringApplication)`이 생성되기 전에 트리거되므로, 해당 이벤트에 대한 리스너를 `@Bean`으로 등록할 수 없다. `SpringApplication.addListeners(...)` 메소드 또는` SpringApplicationBuilder.listeners(...)` 메소드를 사용하여 등록할 수 있다.

애플리케이션 생성 방식에 관계없이 해당 리스너를 자동으로 등록하려면, 다음 예제처럼, 프로젝트에 `META-INF/spring.factories` 파일을 추가하고 `org.springframework.context.ApplicationListener` 키(key)를 사용하여 리스너를 참조할 수 있다:
```
    org.springframework.context.ApplicationListener=com.example.project.MyListener
```
***

애플리케이션이 실행될 때, 애플리케이션 이벤트는 다음 순서로 전송된다:
1. `애플리케이션스타팅이벤트(ApplicationStartingEvent)`는 실행 시작 시, 리스너 및 이니셜라이저(initializer) 등록을 제외한 모든 처리가 발생하기 전에 전송된다.
2. `애플리케이션인바이런먼트프리페어드이벤트(ApplicationEnvironmentPreparedEvent)`는 컨텍스트에서 사용할 환경이 알려졌지만 컨텍스트가 생성되기 전에 전송된다.
3. `애플리케이션컨텍스트이니셜라이즈이벤트(ApplicationContextInitializedEvent)`는 `애플리케이션컨텍스트(ApplicationContext)`가 준비되고 `애플리케이션컨텍스트이니셜라이저(ApplicationContextInitializers)`가 호출되었지만 빈 정의가 로드되기 전에 전송된다.
4. `애플리케이션프리페어드이벤트(ApplicationPreparedEvent)`는 새로고침(refresh)이 시작되기 직전 빈 정의가 로드된 후에 전송된다.
5. `애플리케이션스타트이벤트(ApplicationStartedEvent)`는 컨텍스트 새로고침 후 애플리케이션 및 커맨드라인 러너가 호출되기 전에 전송된다.
6. `LivenessState.CORRECT` 직후에 `어베일러빌리티체인지이벤트(AvailabilityChangeEvent)`가 전송되어 애플리케이션이 라이브로 간주됨을 나타낸다.
7. `애플리케이션레디이벤트(ApplicationReadyEvent)`는 애플리케이션 및 커맨드라인 러너가 호출된 후에 전송된다.
8. `어베일러빌리티체인지이벤트(AvailabilityChangeEvent)`는 `ReadinessState.ACCEPTING_TRAFFIC`과 함께 바로 전송되어 애플리케이션이 요청을 처리할 준비가 되었음을 나타낸다.
9. 시작 시 예외가 발생하면, `애플리케이션페일이벤트(ApplicationFailedEvent)`가 전송된다.

위 목록에는 `스프링애플리케이션(SpringApplication)`에 연결된 `스프링애플리케이션이벤트(SpringApplicationEvents)`만 포함되어 있다. 이 외에도 `애플리케이션프리페어드이벤트(ApplicationPreparedEvent)` 및 `애플리케이션스타트이벤트(ApplicationStartedEvent)` 다음 이벤트도 나타난다:

- `웹서버이니셜라이즈이벤트(WebServerInitializedEvent)`는 `웹서버(WebServer)`가 준비된 후 전송된다. `서블릿웹서버이니셜라이즈이벤트(ServletWebServerInitializedEvent)` 및 `리액티브웹서버이니셜라이즈이벤트(ReactiveWebServerInitializedEvent)`는 각각 서블릿 및 리액티브 변수다.
- `컨텍스트리프레시이벤트(ContextRefreshedEvent)`는 `애플리케이션컨텍스트(ApplicationContext)`가 새로고침(refreshed) 될 때 전송된다.

{: .note}
애플리케이션 이벤트를 사용할 필요가 없는 경우가 많지만 이벤트가 존재한다는 사실을 알아두면 편리할 수 있다. 내부적으로 스프링 부트는 이벤트를 사용하여 다양한 작업을 처리한다.

{: .note}
이벤트 리스너는 기본적으로 동일한 스레드에서 실행되므로 시간이 오래 걸릴 수 있는 작업을 실행해서는 안 된다. 대신 애플리케이션 및 커맨드라인 러너를 사용하자.

애플리케이션 이벤트는 스프링 프레임워크의 이벤트 퍼블리싱(publishing) 메커니즘을 사용하여 전송된다. 이 메커니즘의 일부는 하위 컨텍스트의 리스너에 퍼블리시된 이벤트가 모든 상위 컨텍스트의 리스너에도 퍼블리시되도록 보장한다. 결과적으로 애플리케이션이 스프링애플리케이션 인스턴스의 계층 구조를 사용하는 경우 리스너는 동일한 타입의 애플리케이션 이벤트에 대한 여러 인스턴스를 수신할 수 있다.

리스너가 컨텍스트에 대한 이벤트와 하위 컨텍스트에 대한 이벤트를 구별할 수 있도록 하려면, 애플리케이션 컨텍스트가 주입되도록 요청한 다음 주입된 컨텍스트를 이벤트 컨텍스트와 비교해야 한다. `애플리케이션컨텍스트어웨어(ApplicationContextAware)`를 구현하거나 리스너가 빈인 경우 `@Autowired`를 사용하여 컨텍스트를 주입할 수 있다.


### 7.1.8. Web Environment
`스프링애플리케이션(SpringApplication)`은 사용자를 대신하여 올바른 타입의 `애플리케이션컨텍스트(ApplicationContext)`를 생성하려고 시도한다. `웹어플리케이션타입(WebApplicationType)`을 결정하는 데 사용되는 알고리즘은 다음과 같다:
- 스프링 MVC가 존재하는 경우 `어노테이션컨피그서블릿웹서버애플리케이션컨텍스트(AnnotationConfigServletWebServerApplicationContext)`가 사용된다.
- 스프링 MVC가 없고 스프링 웹플럭스가 있는 경우 `어노테이션컨피그리액티브웹서버애플리케이션컨텍스트(AnnotationConfigReactiveWebServerApplicationContext)`가 사용된다.
- 그렇지 않으면, `어노테이션컨피그애플리케이션컨텍스트(AnnotationConfigApplicationContext)`가 사용된다.

이는 동일한 애플리케이션에서 스프링 MVC와 스프링 웹플럭스의 새로운 `웹클라이언트(WebClient)`를 사용하는 경우 기본적으로 스프링 MVC가 사용된다는 것을 의미한다. `setWebApplicationType(WebApplicationType)`을 호출하여 이를 쉽게 오버라이드할 수 있다.

`setApplicationContextFactory(...)`를 호출하여 사용되는 `애플리케이션컨텍스트(ApplicationContext)` 타입을 완전히 제어하는 ​​것도 가능하다.

{: .note}
JUnit 테스트에서 `스프링애플리케이션(SpringApplication)`을 사용할 때 `setWebApplicationType(WebApplicationType.NONE)`을 호출하는 것이 바람직한 경우가 있다.


### 7.1.9. Accessing Application Arguments
`SpringApplication.run(...)`에 전달된 애플리케이션 아규먼트에 접근해야 하는 경우 `org.springframework.boot.ApplicationArguments` 빈을 주입할 수 있다. 애플리케이션아규먼트(ApplicationArguments) 인터페이스는 다음 예제와 같이 `String[]` 아규먼트와 파싱된 `옵션` 및 `비옵션(non-option)` 아규먼트 모두에 대한 접근할 수 있다.

`자바`
```java
    import java.util.List;
    import org.springframework.boot.ApplicationArguments;
    import org.springframework.stereotype.Component;

    @Component
    public class MyBean {
        public MyBean(ApplicationArguments args) {
            boolean debug = args.containsOption("debug");
            List<String> files = args.getNonOptionArgs();

            if (debug) {
                System.out.println(files);
            }
            // "--debug logfile.txt"로 실행하면 ["logfile.txt"]가 표시된다.
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.ApplicationArguments
    import org.springframework.stereotype.Component

    @Component
    class MyBean(args: ApplicationArguments) {
        init {
            val debug = args.containsOption("debug")
            val files = args.nonOptionArgs
            if (debug) {
                println(files)
            }
            // "--debug logfile.txt"로 실행하면 ["logfile.txt"]가 표시된다.
        }
    }
```

{: .note}
스프링 부트는 또한 스프링 환경에 `커맨드라인프로퍼티소스(CommandLinePropertySource)`를 등록한다. 이를 통해 `@Value` 어노테이션을 사용하여 싱글 애플리케이션 아규먼트를 주입할 수도 있다.


### 7.1.10. Using the ApplicationRunner or CommandLineRunner
`스프링애플리케이션(SpringApplication)`이 시작된 후 특정 코드를 실행해야 하는 경우 `애플리케이션러너(ApplicationRunner)` 또는 `커맨드라인러너(CommandLineRunner)` 인터페이스를 구현할 수 있다. 두 인터페이스 모두 동일한 방식으로 작동하며 `SpringApplication.run(...)`이 완료되기 직전에 호출되는 `run` 메서드를 제공한다.

{: .note}
이 기능은 애플리케이션 시작 후 트래픽 수신을 시작하기 전에 실행해야 하는 작업에 매우 적합하다.

`커맨드라인러너(CommandLineRunner)` 인터페이스는 문자열 배열로 애플리케이션 아규먼트에 대한 접근를 제공하는 반면, `애플리케이션러너(ApplicationRunner)`는 앞에서 설명한 `애플리케이션아규먼트(ApplicationArguments)` 인터페이스를 사용한다. 다음 예에서는 `run` 메서드가 있는 `커맨드라인러너(CommandLineRunner)`를 보여준다:

`자바`
```java
    import org.springframework.boot.CommandLineRunner;
    import org.springframework.stereotype.Component;
    
    @Component
    public class MyCommandLineRunner implements CommandLineRunner {
        @Override
        public void run(String... args) {
            // 무엇인가 작동하는..
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.CommandLineRunner
    import org.springframework.stereotype.Component

    @Component
    class MyCommandLineRunner : CommandLineRunner {
        override fun run(vararg args: String) {
          // 무엇인가 작동하는..
        } 
    }
```

특정 순서로 호출되어야 하는 여러 `커맨드라인러너(CommandLineRunner)` 또는 `애플리케이션러너(ApplicationRunner)` 빈이 정의된 경우 `org.springframework.core.Ordered` 인터페이스를 추가로 구현하거나 `org.springframework.core.annotation.Order` 어노테이션을 사용할 수 있다.


### 7.1.11. Application Exit
각 `스프링애플리케이션(SpringApplication)`은 종료 시 `애플리케이션컨텍스트(ApplicationContext)`가 정상적(gracefully)으로 닫히도록 JVM에 종료 후크(hook)를 등록한다. 모든 표준 스프링 라이프사이클 콜백(예: DisposableBean 인터페이스 또는 @PreDestroy 어노테이션)을 사용할 수 있다.

게다가, `SpringApplication.exit()`가 호출될 때 특정 종료 코드를 반환하려는 경우, `org.springframework.boot.ExitCodeGenerator` 인터페이스를 구현할 수 있다. 그런 다음 이 종료 코드를 `System.exit()`에 전달하여 다음 예제와 같이 상태 코드로 반환할 수 있다:

```java
    import org.springframework.boot.ExitCodeGenerator;
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.context.annotation.Bean;

    @SpringBootApplication
    public class MyApplication {
        @Bean
        public ExitCodeGenerator exitCodeGenerator() {
            return () -> 42;
        }
      
        public static void main(String[] args) {
            System.exit(SpringApplication.exit(SpringApplication.run(MyApplication.class, args))); 
        }
    }
```

```kotlin
    import org.springframework.boot.ExitCodeGenerator
    import org.springframework.boot.SpringApplication
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.boot.runApplication
    import org.springframework.context.annotation.Bean
    import kotlin.system.exitProcess

    @SpringBootApplication
    class MyApplication {
        @Bean
        fun exitCodeGenerator() = ExitCodeGenerator { 42 }
    }
    
    fun main(args: Array<String>) {
        exitProcess(SpringApplication.exit(runApplication<MyApplication>(*args)))
    }
```

또한 `엑시트코드제너레이터(ExitCodeGenerator)` 인터페이스는 예외로 구현될 수 있다. 이러한 예외가 발생하면 스프링 부트는 구현된 `getExitCode()` 메서드에서 제공하는 종료 코드를 반환한다.

`엑시트코드제너레이터(ExitCodeGenerator)`가 두 개 이상인 경우 생성된 첫 번째의 0이 아닌 종료 코드가 사용된다. 제너레이터가 호출되는 순서를 제어하려면 `org.springframework.core.Ordered` 인터페이스를 추가로 구현하거나 `org.springframework.core.annotation.Order` 어노테이션을 사용하자.


### 7.1.12. Admin Features
`spring.application.admin.enabled` 프로퍼티를 지정하여 애플리케이션에 대한 관리 기능을 활성화할 수 있다. 이는 플랫폼 `MBeanServer`에 `SpringApplicationAdminMXBean`을 노출한다. 이 기능을 사용하여 스프링 부트 애플리케이션을 원격으로 관리할 수 있다. 이 기능은 모든 서비스 래퍼 구현에도 유용할 수 있다.

{: .note}
애플리케이션이 실행 중인 HTTP 포트를 알고 싶다면, `local.server.port` 키를 사용하여 프로퍼티를 가져오자.


### 7.1.13. Application Startup tracking
애플리케이션 시작 중에 `스프링애플리케이션(SpringApplication)`과 `애플리케이션컨텍스트(ApplicationContext)`는 애플리케이션 라이프사이클, 빈 라이프사이클 또는 심지어 애플리케이션 이벤트 처리와 관련된 많은 작업을 수행한다. `애플리케이션스타트업(ApplicationStartup)`을 사용하면 [스프링 프레임워크를 사용하여 `스타트업스텝(StartupStep)` 객체](https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-functionality-startup)를 사용하여 애플리케이션 시작 순서를 추적할 수 있다. 이 데이터는 프로필링 목적으로 수집되거나 애플리케이션 시작 프로세스를 더 잘 이해하기 위해 수집할 수 있다.

`스프링애플리케이션(SpringApplication)` 인스턴스를 설정할 때 `애플리케이션스타트업(ApplicationStartup)` 구현을 선택할 수 있다. 예를 들어 `버퍼링애플리케이션스타트업(BufferingApplicationStartup)`을 사용하려면 다음과 같이 작성할 수 있다:

`자바`
```java
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.boot.context.metrics.buffering.BufferingApplicationStartup;

    @SpringBootApplication
    public class MyApplication {
        public static void main(String[] args) {
            SpringApplication application = new SpringApplication(MyApplication.class);
            application.setApplicationStartup(new BufferingApplicationStartup(2048));
            application.run(args);
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.boot.context.metrics.buffering.BufferingApplicationStartup
    import org.springframework.boot.runApplication

    @SpringBootApplication
    class MyApplication

    fun main(args: Array<String>) {
        runApplication<MyApplication>(*args) {
            applicationStartup = BufferingApplicationStartup(2048)
        }
    }
```

사용 가능한 첫 번째 구현체인 `플라이트레코더애플리케이션스타트업(FlightRecorderApplicationStartup)`은 스프링 프레임워크에서 제공된다. 이는 자바 플라이트 레코더 절에 스프링 관련 시작 이벤트를 추가하며 애플리케이션을 프로파일링하고 스프링 컨텍스트 라이프사이클을 JVM 이벤트(할당, GC, 클래스 로딩 등)와 연관시키는 데 사용된다. 일단 구성되면 플라이트 레코더가 활성화된 상태에서 애플리케이션을 실행하여 데이터를 기록할 수 있다.

```
    $ java -XX:StartFlightRecording:filename=recording.jfr,duration=10s -jar demo.jar
```

스프링 부트는 `버퍼링애플리케이션스타트업(BufferingApplicationStartup)` 변수과 함께 제공된다. 이 구현체는 시작 단계를 버퍼링하고 이를 외부 측정 시스템으로 배출하기 위한 것이다. 애플리케이션은 모든 컴포넌트에서  `버퍼링애플리케이션스타트업(BufferingApplicationStartup)` 타입의 빈을 요청할 수 있다.


스프링 부트는 이 정보를 JSON 문서로 제공하는 [스타트업 엔드포인트](https://docs.spring.io/spring-boot/docs/3.1.1/actuator-api/htmlsingle/#startup)를 노출하도록 구성할 수도 있다.


## 7.2. Externalized Configuration
스프링 부트를 사용하면 구성을 외부화하여 다양한 환경에서 동일한 애플리케이션 코드로 작업할 수 있다. 자바 프로퍼티스 파일, YAML 파일, 환경 변수, 커맨드라인 아규먼트를 비롯한 다양한 외부 구성 소스를 사용할 수 있다.

프로퍼티 값은 `@Value` 어노테이션을 사용하여 빈에 직접 주입하거나 스프링의 환경 추상화를 통해 접근하거나 `@ConfigurationProperties`를 통해 구조화된 객체에 바인딩할 수 있다.

스프링 부트는 값 오버라이드를 허용하도록 설계된 특별한 `PropertySource` 순서를 사용한다. 이후 프로퍼티 소스는 이전 프로퍼티 소스에서 정의된 값을 오버라이드할 수 있다. 소스는 다음 순서를 고려한다:
1. 기본 프로퍼티(`SpringApplication.setDefaultProperties` 설정을 통해 지정).
2. `@Configuration` 클래스의 `@PropertySource` 어노테이션. 이러한 프로퍼티 소스는 애플리케이션 컨텍스트가 새로고침될 때까지 환경에 추가되지 않는다. 새로고침이 시작되기 전에 읽혀지는 `logging.*` 및 `spring.main.*`과 같은 특정 프로퍼티를을 구성하기에는 너무 늦다.
3. 구성 데이터(예: `application.properties` 파일)
4. `random.*` 프로퍼티을 갖는 `랜덤벨류프로퍼티소스(RandomValuePropertySource)`이다.
5. OS 환경 변수
6. 자바 시스템 프로퍼티스(`System.getProperties()`).
7. `java:comp/env`의 JNDI 애트리뷰트.
8. `서블릿컨텍스트(ServletContext)`의 초기화 파라미터.
9. `서블릿컨피그(ServletConfig)`의 초기화 파라미터.
10. `SPRING_APPLICATION_JSON` 프로퍼티의 (환경 변수 또는 시스템 프로퍼티에 포함된 인라인 JSON)
11. 커맨드라인 아규먼트
12. 테스트의 프로퍼티스 애트리뷰트. `@SpringBootTest` 및 애플리케이션의 특정 부분을 테스트하기 위한 테스트 어노테이션에서 사용할 수 있다.
13. 테스트의 `@DynamicPropertySource` 어노테이션.
14. 테스트의 `@TestPropertySource` 어노테이션.
15. `데브툴즈(devtools)`가 활성화된 경우 `$HOME/.config/spring-boot` 디렉터리에 있는 `Devtools` 글로벌 설정 프로퍼티.

구성 데이터 파일은 다음 순서를 고려한다:
1. jar 내부에 패키지된 애플리케이션 프로퍼티(`application.properties` 및 `YAML` 변수)
2. jar 내부에 패키지된 프로필(Profile)별 애플리케이션 프로퍼티스(`application-{profile}.properties` 및 `YAML` 변수)
3. 패키지된 jar 외부의 애플리케이션 프로퍼티스(`application.properties` 및 `YAML` 변수)
4. 패키지된 jar 외부의 프로필(Profile)별 애플리케이션 프로퍼티스(`application-{profile}.properties` 및 `YAML` 변수)

{: .note}
전체 애플리케이션에 대해 하나의 포맷을 사용하는 것이 좋다. `.properties` 및 `YAML` 포맷 모두 포함된 구성 파일이 동일한 위치에 있는 경우 `.properties`가 우선 적용된다.

{: .note}
시스템 프로퍼티 대신 환경 변수를 사용하는 경우, 대부분의 운영 체제에서는 마침표로 구분된 키 이름을 허용하지 않지만 대신 밑줄을 사용할 수 있다(예: `spring.config.name` 대신 `SPRING_CONFIG_NAME`). 자세한 내용은 환경 변수 바인딩을 참고하자.

{: .note}
애플리케이션이 서블릿 컨테이너 또는 애플리케이션 서버에서 실행되는 경우 JNDI 프로퍼티스(`java:comp/env`) 또는 서블릿 컨텍스트 초기화 파라미터를 환경 변수 또는 시스템 프로퍼티 대신 사용할 수 있다.

구체적인 예를 제공하기 위해 다음 예와 같이 `name` 프로퍼티을 사용하는 `@Component`를 개발한다고 가정한다:

`자바`
```java
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.stereotype.Component;

    @Component
    public class MyBean {
        @Value("${name}")
        private String name;

        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.beans.factory.annotation.Value
    import org.springframework.stereotype.Component
    
    @Component
    class MyBean {
        @Value("\${name}")
        private val name: String? = null
        // ... 
    }
```
애플리케이션 클래스 패스(예: jar 내부)에는 `name`에 대한 적절한 프로퍼티 값을 제공하는 `application.properties` 파일이 있다. 새 환경에서 실행할 때 이름을 오버라이드하는 jar 외부에 `application.properties` 파일을 제공할 수 있다. 일회성 테스트의 경우 특정 커맨드라인 스위치(예: `java -jar app.jar --name="Spring"`)를 사용하여 시작할 수 있다.

{: .note}
`env` 및 `configprops` 엔드포인트는 프로퍼티에 특정 값이 있는 이유를 확인하는 데 유용할 수 있다. 이러한 두 엔드포인트를 사용하여 예기치 않은 프로퍼티 값을 진단할 수 있다. 자세한 내용은 "Production ready features" 절을 참고하자.


### 7.2.1. Accessing Command Line Properties
기본적으로 `스프링애플리케이션(SpringApplication)`은 모든 커맨드라인 옵션 아규먼드(즉, `--server.port=9000`과 같이 `--`로 시작하는 아규먼트)를 프로퍼티로 변환하고 이를 스프링 환경에 추가한다. 앞에서 언급한 것처럼 커맨드라인 프로퍼티는 항상 파일 기반 프로퍼티 소스보다 우선한다.

환경에 커맨드라인 프로퍼티를 추가하지 않으려면 `SpringApplication.setAddCommandLineProperties(false)`를 사용하여 비활성화할 수 있다.


### 7.2.2. JSON Application Properties
환경 변수 및 시스템 프로퍼티에는 일부 프로퍼티명을 사용할 수 없는 제한이 있다. 이를 돕기 위해 스프링 부트를 사용하면 프로퍼티 블록을 싱글 JSON 구조로 인코딩할 수 있다.

애플리케이션이 시작되면 `spring.application.json` 또는 `SPRING_APPLICATION_JSON` 프로퍼티가 파싱되어 환경에 추가된다.

예를 들어, `SPRING_APPLICATION_JSON` 프로퍼티는 UN*X 셸의 커맨드라인에 환경 변수로 제공될 수 있다:
```sh
    $ SPRING_APPLICATION_JSON='{"my":{"name":"test"}}' java -jar myapp.jar
```

앞의 예에서는, 스프링 환경에서 `my.name=test`로 끝난다.

동일하게 JSON을 시스템 프로퍼티로 제공할 수도 있다:
```sh
    $ java -Dspring.application.json='{"my":{"name":"test"}}' -jar myapp.jar
```

또는 커맨드라인 아규먼트를 사용하여 JSON을 제공할 수 있다:
```sh
    $ java -jar myapp.jar --spring.application.json='{"my":{"name":"test"}}'
```

클래식 애플리케이션 서버(Application Server)에 배포하는 경우 `java:comp/env/spring.application.json`이라는 JNDI 변수를 사용할 수도 있다.

{: .note}
JSON의 `null` 값이 프로퍼티 소스에 추가되지만, `프로퍼티소스프로퍼티리졸버(PropertySourcesPropertyResolver)`는 `null` 프로퍼티를 누락된 값으로 처리한다. 이는 JSON이 `null` 값을 사용하여 하위 프로퍼티 소스의 프로퍼티를 오버라이드할 수 없음을 의미한다.


### 7.2.3. External Application Properties
스프링 부트는 애플리케이션이 시작될 때 아래 위치에서 `application.properties` 및 `application.yaml` 파일을 자동으로 찾아 로드한다:
1. 클래스패스
    1. 루트 클래스패스
    2. `/config` 패키지 클래스패스
2. 디렉토리
    1. 디렉토리
    2. 디렉토리의 `config/` 하위디렉토리 
    3. `config/` 하위 디렉터리의 바로 하위 디렉터리

목록은 우선 순위에 따라 정렬된다(낮은 항목의 값이 이전 항목보다 우선됨).
로드된 파일 문서는 스프링 환경에 `프로퍼티소스(PropertySource)`로 추가된다.

애플리케이션의 구성 파일명이 마음에 들지 않으면 `spring.config.name` 환경 프로퍼티를 지정하여 다른 파일명으로 전환할 수 있다. 예를 들어 `myproject.properties` 및 `myproject.yaml` 파일을 찾으려면 다음과 같이 애플리케이션을 실행할 수 있다:
```sh
    $ java -jar myproject.jar --spring.config.name=myproject
```

`spring.config.location` 환경 프로퍼티를 사용하여 위치를 참조할 수도 있다. 이 프로퍼티는 확인할 위치가 하나 이상일 경우 쉼표로 구분된 목록을 받을 수 있다.

다음 예에서는 두 개의 개별 파일을 지정하는 방법을 보여준다:
```sh
    $ java -jar myproject.jar --spring.config.location=\
        optional:classpath:/default.properties,\
        optional:classpath:/override.properties
```

{: .note}
`optional:` 접두사를 사용하기: 위치는 옵셔널이고 위치가 없어도 괜찮을 경우.

{: .warning}
`spring.config.name`, `spring.config.location` 및 `spring.config.additional-location`은 로드해야 할 파일을 결정하기 위해 초기에 사용된다. 이는 환경 프로퍼티(일반적으로 OS 환경 변수, 시스템 프로퍼티 또는 커맨드라인 아규먼트)으로 정의되어야 한다.

`spring.config.location`에 파일이 아닌 디렉터리가 포함되어 있으면 `/`로 끝나야 한다. 런타임 시 로드되기 전에 `spring.config.name`에서 생성된 이름이 추가된다. `spring.config.location`에 지정된 파일을 직접 가져온다.

{: .note}
프로필별(profile) 파일을 확인하기 위해 디렉터리 및 파일 위치 값도 모두 확장된다. 예를 들어 `classpath:myconfig.properties`의 `spring.config.location`이 있는 경우 적절한 `classpath:myconfig- <profile>.properties` 파일이 로드되는 것을 볼 수 있다.

대부분의 상황에서, 추가하는 각 `spring.config.location` 항목은 싱글 파일이나 디렉터리를 참조한다. 위치는 정의된 순서대로 처리되며, 이후 위치는 이전 위치의 값을 오버라이드할 수 있다.

위치 설정이 복잡하면서 프로필별 구성 파일을 사용하는 경우 스프링 부트가 그룹화 방법을 알 수 있도록 추가 힌트를 제공해야 할 수도 있다. 위치 그룹은 모두 동일한 레벨로 간주되는 위치 모음이다. 예를 들어 모든 클래스패스의 위치를 그룹화할 수 있다. 위치 그룹 내의 항목은 ;로 구분되어야 한다. 자세한 내용은 "프로필별 파일" 절의 예를 참고하자.

`spring.config.location`을 사용하여 구성된 위치는 기본 위치를 대체한다. 예를 들어, `spring.config.location`이 `optional:classpath:/custom-config/,optional:file:./custom-config/` 값으로 구성된 경우 고려되는 전체 위치 세트는 다음과 같다:
1. `optional:classpath:custom-config/`
2. `optional:file:./custom-config/`

위치를 바꾸는 대신 위치를 추가하려는 경우 `spring.config.additional-location`을 사용할 수 있다. 추가 위치에서 로드된 프로퍼티는 기본 위치의 프로퍼티를 오버라이드할 수 있다. 예를 들어, `spring.config.additional-location`이 `optional:classpath:/custom-config/,optional:file:./custom-config/` 값으로 구성된 경우 고려되는 전체 위치 세트는 다음과 같다:
1. `optional:classpath:/;optional:classpath:/config/`
2. `optional:file:./;optional:file:./config/;optional:file:./config/*/ `
3. `optional:classpath:custom-config/`
4. `optional:file:./custom-config/`

This search ordering lets you specify default values in one configuration file and then selectively override those values in another. You can provide default values for your application in application.properties (or whatever other basename you choose with spring.config.name) in one of the default locations. These default values can then be overridden at runtime with a different file located in one of the custom locations.

이 검색 순서를 사용하면 한 구성 파일에서 기본값을 지정한 다음 다른 구성 파일에서 해당 값을 선택적으로 오버라이드할 수 있다. 기본 위치 중 하나에 있는 `application.properties`(또는 `spring.config.name`으로 선택한 다른 이름)에 애플리케이션의 기본값을 제공할 수 있다. 그러면 이러한 기본값은 런타임 시 커스텀 위치 중 하나에 있는 다른 파일로 오버라이드될 수 있다.

#### Optional Locations
기본적으로, 지정된 구성 데이터 위치가 없으면 스프링 부트는 `컨피그데이터로케이션낫파운드익셉션(ConfigDataLocationNotFoundException)`을 발생시키고 애플리케이션이 시작되지 않는다.

위치를 지정하고 싶지만 위치가 항상 존재하지 않더라도 상관없는 경우 optional: 접두사를 사용할 수 있다. `spring.config.location` 및 `spring.config.additional-location` 프로퍼티는 물론 `spring.config.import` 선언과 함께 이 접두사를 사용할 수 있다.

예를 들어, `spring.config.import`에 `option:file:./myconfig.properties`를 할당하면 `myconfig.properties` 파일이 누락된 경우에도 애플리케이션을 시작할 수 있다.

모든 `컨피그데이터로케이션낫파운드익셉션(ConfigDataLocationNotFoundException)`을 무시하고 항상 애플리케이션을 계속 시작하려면 `spring.config.on-not-found` 프로퍼티를 사용할 수 있다. `SpringApplication.setDefaultProperties(...)`를 사용하거나 시스템/환경 변수를 사용하여 무시하도록 값을 설정한다.


#### Wildcard Locations
구성 파일 위치의 마지막 패스 세그먼트에 `*` 문자가 포함되어 있으면, 와일드카드 위치로 간주한다. 구성이 로드되면 와일드카드가 확장되어 하위 디렉터리도 검사한다. 와일드카드 위치는 구성 프로퍼티의 소스가 여러 개 있는 쿠버네이티스와 같은 환경에서 특히 유용하다.

예를 들어, 일부 레디스 구성과 일부 MySQL 구성이 있는 경우 두 구성 부분을 별도로 유지하면서 둘 다 `application.properties` 파일에 존재하도록 할 수 있다. 이로 인해 `/config/redis/application.properties` 및 `/config/mysql/application.properties`와 같은 서로 다른 위치에 두 개의 별도 `application.properties` 파일이 마운트될 수 있습니다. 이러한 경우 와일드카드 위치가 config/*/이면 두 파일이 모두 처리된다.

기본적으로, 스프링 부트는 기본 검색 위치에 `config/*/`를 포함한다. 이는 jar 외부의 `/config` 디렉토리의 모든 하위 디렉토리 검색을 의미한다.

`spring.config.location` 및 `spring.config.additional-location` 프로퍼티를 사용하여 와일드카드 위치를 직접 사용할 수 있다.

{: .note}
와일드카드 위치에는 `*` 하나만 포함되어야 하며, 디렉터리 검색 위치의 경우 `*/`로 끝나야 하고, 파일 검색 위치의 경우 `*/<filename>`으로 끝나야 한다. 와일드카드가 있는 위치는 절대 경로에서 알파벳순으로 정렬된다.

{: .note}
와일드카드 위치는 외부 디렉터리에서만 작동한다. `classpath:` 위치에는 와일드카드를 사용할 수 없다.


#### Profile Specific Files
애플리케이션 프로퍼티 파일뿐만 아니라, 스프링 부트는 명명 규칙 `application-{profile}`을 사용하여 프로필별 파일 로드를 시도한다. 예를 들어, 애플리케이션이 `prod`라는 프로필을 활성화하고, YAML 파일을 사용하는 경우 `application.yaml`과 `application-prod.yaml`이 모두 고려된다.

프로필별 프로퍼티는 표준 `application.properties`와 동일한 위치에서 로드되며, 프로필별 파일은 항상 특정되지 않은 파일보다 우선시 된다. 여러 프로필이 지정된 경우 최후 승리 전략(last-wins strategy)이 적용된다. 예를 들어 `prod`,`live` 프로필이 `spring.profiles.active` 프로퍼티에 의해 지정되면 `application-prod.properties`의 값은 `application-live.properties`의 값으로 오버라이드될 수 있다.

***
`노트`

최후 승리 전략은 위치(location) 그룹 레벨에서 적용된다. `classpath:/cfg/,classpath:/ext/`로 설정된 `spring.config.location`에는 `classpath:/cfg/;classpath:/ext/`과 같은 오버라이드 규칙이 없다.


예를 들어, 위의 `prod`,`live` 예제를 계속하면 다음 파일이 있을 수 있다:

```
    /cfg
        application-live.properties
    /ext
        application-live.properties
        application-prod.properties
```

`spring.config.location`이 `classpath:/cfg/,classpath:/ext/`인 경우 모든 `/ext` 파일보다 먼저 모든 `/cfg` 파일을 처리한다:
1. `/cfg/application-live.properties`
2. `/ext/application-prod.properties`
3. `/ext/application-live.properties`

대신 `classpath:/cfg/;classpath:/ext/`(`;` 구분 기호 사용)가 있는 경우 `/cfg` 및 `/ext`를 동일한 레벨에서 처리한다:
1. `/ext/application-prod.properties`
2. `/cfg/application-live.properties`
3. `/ext/application-live.properties`
***

환경에는 활성 프로필이 설정되지 않은 경우 사용되는 기본 프로필 세트(기본적으로 [default])가 있다. 즉, 명시적으로 활성화된 프로필이 없으면 `application-default`의 프로퍼티가 고려된다.

{: .note}
프로퍼티 파일은 한 번만 로드된다. 이미 프로필별 프로퍼티 파일을 직접 가져온 경우에는 두 번째로 가져오지 않는다.


#### Importing Additional Data
애플리케이션 프로퍼티는 `spring.config.import` 프로퍼티을 사용하여 다른 위치에서 추가 구성 데이터를 가져올 수 있다. 임포트(Imports)는 발견된 대로 처리되며, 임포트를 요청한 문서 바로 아래에 삽입될 추가 문서로 처리된다.

예를 들어, 클래스패스 `application.properties` 파일이 다음과 같다:

`프로퍼티스(Properties)`
``` 
    spring.application.name=myapp
    spring.config.import=optional:file:./dev.properties
```

`Yaml`
```yaml
    spring:
        application:
            name: "myapp"
        config:
            import: "optional:file:./dev.properties"
```

그러면 현재 디렉터리에 `dev.properties` 파일이 있는 경우 임포트가 트리거된다. 가져온 `dev.properties`의 값은 임포트를 요청하고 트리거한 파일보다 우선한다. 위의 예에서 `dev.properties`는 `spring.application.name`을 다른 값으로 오버라이드할 수 있다.

임포트는 선언 횟수에 상관없이 한 번만 가져와 진다. 임포트가 properties/yaml 파일 내에서 정의되는 순서는 중요하지 않다. 예를 들어, 아래 두 예는 동일한 결과를 보여준다:

`프로퍼티스(Properties)`
```
    spring.config.import=my.properties
    my.property=value
```

`Yaml`
```yaml
    spring:
        config:
            import: "my.properties"
    my:
        property: "value"
```

`프로퍼티스(Properties)`
``` 
    my.property=value
    spring.config.import=my.properties
```

`Yaml`
```yaml
    my:
        property: "value"
    spring:
        config:
            import: "my.properties"
```

위의 두 예제에서 `my.properties` 파일의 값은 해당 임포트를 트리거한 파일보다 우선시 된다.

단일 `spring.config.import` 키 아래에 여러 위치를 지정할 수 있다. 위치는 정의된 순서대로 처리되며 이후 임포트가 우선 적용됩니다.

{: .note}
해당하는 경우 프로필별 변수도 임포트 대상으로 고려된다. 위의 예에서는 `my.properties`와 `my-<profile>.properties` 변수를 모두 가져온다.

***

`TIP`

스프링 부트에는 다양한 위치를 지원할 수 있는 플러그형 API가 있다. 기본적으로 자바 프로퍼티스, YAML 및 "구성 트리"를 가져올 수 있다.

서드파티 jar는 추가 기술에 대한 지원을 한다. 예를 들어 `Consul`, 아파치 주키퍼(ZooKeepe)r 또는 넷플릭스 Archaius와 같은 외부 저장소의 구성 데이터를 상상할 수 있다.

커스텀 위치를 ​​지원하려면, `org.springframework.boot.context.config` 패키지의 `컨피그데이터로케이션리졸버(ConfigDataLocationResolver)` 및 `컨피스데이터로더(ConfigDataLoader)` 클래스를 참고하자.
***

#### Importing Extensionless Files
일부 클라우드 플랫폼은 볼륨 마운트 파일에 파일 확장자를 추가할 수 없다. 이러한 확장자가 없는 파일을 가져오려면 스프링 부트에 힌트를 제공하여 로드 방법을 알 수 있도록 해야 한다. 대괄호 안에 확장 힌트를 넣으면 된다.

예를 들어, yaml로 임포트하려는 `/etc/config/myconfig` 파일이 있다고 가정하자. 다음 예제의 `application.properties`에서 가져올 수 있다:

`프로퍼티스(Properties)`
``` 
    spring.config.import=file:/etc/config/myconfig[.yaml]
```

`Yaml`
```yaml
    spring:
        config:
            import: "file:/etc/config/myconfig[.yaml]"
```


####  Using Configuration Trees
클라우드 플랫폼(예: 쿠버네티스)에서 애플리케이션을 실행할 때 플랫폼이 제공하는 구성 값을 읽어야 하는 경우가 많다. 이러한 목적으로 환경 변수를 사용하는 것은 드문 일이 아니지만, 특히 값을 비밀로 유지해야 하는 경우에는 단점이 있을 수 있다.

환경 변수의 대안으로, 이제 많은 클라우드 플랫폼에서 구성을 탑재된 데이터 볼륨에 매핑할 수 있다. 예를 들어 쿠버네티스는 `컨피그맵(ConfigMap)`과 `시크릿(Secret)`을 모두 볼륨 마운트할 수 있다.

사용할 수 있는 두 가지 일반적인 볼륨 마운트 패턴이 있다:
1. 싱글 파일에는 전체 프로퍼티 세트(일반적으로 YAML로 작성됨)가 포함되어 있다.
2. 여러 파일이 디렉터리 트리에 기록되며, 파일 이름은 '키'가 되고 내용은 '값'이 된다.

첫 번째 경우, 위에서 설명한 대로 `spring.config.import`를 사용하여 YAML 또는 프로퍼티 파일을 직접 가져올 수 있다. 두 번째 경우에는 스프링 부트가 모든 파일을 프로퍼티로 노출해야 한다는 것을 알 수 있도록 `configtree:` 접두사를 사용해야 한다.

예를 들어 쿠버네티스가 다음 볼륨을 마운트했다고 가정해 보자.
```
    etc/ 
        config/
        myapp/
            username
            password
```
사용자명 파일의 내용은 컨피그 값(config value)이고 비밀번호의 내용은 시크릿(secret)이다.

이러한 프로퍼티를 가져오려면, `application.properties` 또는 `application.yaml` 파일에 다음 내용을 추가하면 된다.

`프로퍼티스(Properties)`
``` 
    spring.config.import=optional:configtree:/etc/config/
```

`Yaml`
```yaml
    spring:
        config:
            import: "optional:configtree:/etc/config/"
```

그런 다음 일반적인 방법으로 환경에서 `myapp.username` 및 `myapp.password` 프로퍼티스에 접하거나 주입할 수 있다.

{: .note}
구성 트리(Configuration tree) 아래의 폴더가 프로퍼티명을 형성한다. 위의 예에서 사용자 이름과 비밀번호로 프로퍼티에 접근하려면 `spring.config.import`를 `optional:configtree:/etc/config/myapp`으로 설정할 수 있다.

{: .note}
점 표기법이 있는 파일명도 올바르게 매핑된다. 예를 들어 위의 예제에서 `/etc/config`에 `myapp.username`이라는 파일이 있으면 환경에 `myapp.username` 프로퍼티가 생성된다.

{: .note}
구성 트리 값은 예상되는 내용에 따라 `String` 및 `byte[]` 타입 모두에 바인딩될 수 있다.

동일한 상위 폴더에서 가져올 구성 트리가 여러 개 있는 경우 와일드카드 단축키를 사용할 수 있다. `/*/`로 끝나는 모든 `configtree:` 위치는 모든 하위 항목을 구성 트리로 가져온다.

예를 들어 다음과 같은 볼륨이 있다고 가정하자:
```
    etc/ 
        config/
        dbconfig/
            db/
                username
                password
        mqconfig/
            mq/ 
                username
                password
```

`configtree:/etc/config/*/`를 임포트 위치로 사용할 수 있다.

`프로퍼티스(Properties)`
``` 
    spring.config.import=optional:configtree:/etc/config/*/
```

`Yaml`
```yaml
    spring:
        config:
            import: "optional:configtree:/etc/config/*/"
```

그러면 `db.username`, `db.password`, `mq.username` 및 `mq.password` 프로퍼티가 추가된다.

{: .note}
와일드카드를 사용하여 로드된 디렉터리는 알파벳순으로 정렬된다. 다른 순서가 필요한 경우 각 위치를 별도의 임포트로 나열해야 한다.

구성 트리는 도커 시크릿에도 사용할 수 있다. 도커 스웜(Swarm) 서비스에 시크릿에 대한 접근 권한이 부여되면 해당 시크릿이 컨테이너에 탑재된다. 예를 들어, `db.password`라는 시크릿이 `/run/secrets/` 위치에 마운트된 경우 다음 내용을 사용하여 스프링 환경에서 `db.password`를 사용할 수 있다:

`프로퍼티스(Properties)`
``` 
    spring.config.import=optional:configtree:/run/secrets/
```

`Yaml`
```yaml
    spring:
        config:
            import: "optional:configtree:/run/secrets/"
```

#### Property Placeholders
`application.properties` 및 `application.yaml`의 값은 사용 시 기존 환경을 통해 필터링되므로 이미 존재하는 값(예: 시스템 프로퍼티 또는 환경 변수)을 다시 참조할 수 있다. 표준 ${name} 프로퍼티-자리 표시자(placeholder) 문법은 값 내 어디에서나 사용할 수 있다. 프로퍼티 자리 표시자는 프로퍼티명에서 기본값을 구분하기 위해 :을 사용하여 기본값을 지정할 수도 있다(예: ${name:default}).

기본값이 있거나 없는 자리 표시자의 사용은 다음 예재에 나와 있다.

`프로퍼티스(Properties)`
``` 
    app.name=MyApp
    app.description=${app.name} is a Spring Boot application written by ${username:Unknown}
```

`Yaml`
```yaml
  app:
    name: "MyApp"
    description: "${app.name} is a Spring Boot application written by ${username:Unknown}"
```

`username` 프로퍼티가 다른 곳에서 설정되지 않았다고 가정하면 `app.description`의 값은 MyApp is a Spring Boot application written by Unknown이 된다.

***
`노트`

항상 표준 포맷(소문자만 사용하는 케밥 케이스)을 사용하여 자리 표시자에서 프로퍼티명을 참조해야 한다. 이렇게 하면 스프링 부트가 `@ConfigurationProperties` 바인딩할 때와 동일한 로직를 사용할 수 있다.

예를 들어 `${demo.item-price}`는 `application.properties` 파일에서 `demo.item-price` 및 `demo.itemPrice` 양식을 선택하고 시스템 환경에서 `DEMO_ITEMPRICE`를 선택한다. 대신 `${demo.itemPrice}`를 사용한 경우, `deco.item-price` 및 `DEMO_ITEMPRICE`는 고려되지 않는다.
***

{: .note}
또한 이 기술을 사용하여 기존 스프링 부트 프로퍼티의 "짧은" 변수을 만들 수도 있다. 자세한 내용은 '짧은' 커맨드라인 아규먼트 사용 방법을 참고하자.


#### Working With Multi-Document Files
스프링 부트를 사용하면 파일을 각각 독립적으로 추가되는 여러 논리적 문서로 분할할 수 있다. 문서는 위에서 아래로 순서대로 처리된다. 최신 문서는 이전 문서에서 정의된 프로퍼티를 오버라이드할 수 있다.

`application.yaml` 파일의 경우 표준 `YAML` 다중 문서 문법이 사용된다. 세 개의 연속된 하이픈은 한 문서의 끝과 다음 문서의 시작을 나타낸다.

예를 들어 다음 파일에는 두 개의 논리적 문서가 있다:
```yaml
spring:
    application:
        name: "MyApp"
---
spring:
    application:
        name: "MyCloudApp"
    config:
        activate:
            on-cloud-platform: "kubernetes"
```

`application.properties` 파일의 경우 특수 #--- 또는 !--- 주석을 사용하여 문서 분할을 표시한다.
```
spring.application.name=MyApp
#---
spring.application.name=MyCloudApp
spring.config.activate.on-cloud-platform=kubernetes
```

{: .note}
프로퍼티 파일 구분기호(separator)에는 선행 공백이 없어야 하며 정확히 3개의 하이픈 문자가 있어야 한다. 구분 기호 바로 앞과 뒤의 줄은 동일한 주석 접두사가 아니어야 한다.

{: .note}
다중 문서 프로퍼티 파일은 `spring.config.activate.on-profile`과 같은 `activation` 프로퍼티과 함께 사용되는 경우가 많다. 자세한 내용은 다음 절을 참고하자.

{: .warning}
`@PropertySource` 또는 `@TestPropertySource` 어노테이션을 사용하여 다중 문서 프로퍼티 파일을 로드할 수 없다.


#### Activation Properties
특정 조건이 충족될 때 특정 프로퍼티스 세트만 활성화하는 것이 유용한 경우가 있다. 예를 들어 특정 프로필이 활성화된 경우에만 관련된 프로퍼티가 있을 수 있다.

`spring.config.activate.*`를 사용하여 프로퍼티 문서를 조건부로 활성화할 수 있다.

다음 활성화 프로퍼티를 사용할 수 있다:

테이블 5. 활성화 프로퍼티스

|프로퍼티|설명|
|---|---|
|`on-profile`|문서가 활성화되려면 일치해야 하는 프로필 표현식이다.|
|`on-cloud-platform`|문서를 활성화하기 위해 클라우드플랫폼(CloudPlatform)을 감지해야 한다.|

예를 들어 다음은 쿠버네티스에서 실행될 때 두 번째 문서가 활성화되고, "prod" 또는 "staging" 프로필이 활성화될 때 활성화되도록 지정한다:

`프로퍼티스(Properties)`
``` 
    myprop=always-set
    #---
    spring.config.activate.on-cloud-platform=kubernetes
    spring.config.activate.on-profile=prod | staging
    myotherprop=sometimes-set
```

`Yaml`
```yaml
    myprop: "always-set"
    --- 
    spring:
        config:
            activate:
                on-cloud-platform: "kubernetes"
                on-profile: "prod | staging"
    myotherprop: "sometimes-set"
```


### 7.2.4. Encrypting Properties
스프링 부트는 프로퍼티 값 암호화에 대한 지원을 제공하지 않지만 스프링 `환경(Environment)`에 포함된 값을 수정하는 데 필요한 후크 포인트를 제공한다. `인바이런먼트포스트프로세서(EnvironmentPostProcessor)` 인터페이스를 사용하면 애플리케이션이 시작되기 전 `환경(Environment)`를 조작할 수 있다. 자세한 내용은 [Customize the Environment or ApplicationContext Before It Starts]()을 참고하자.

크리덴셜(credentials)과 비밀번호를 안전하게 저장하는 방법이 필요한 경우, 스프링 클라우드 볼트(Vault) 프로젝트는 하시코프 볼트(HashiCorp Vault)에 외부화된 구성을 저장하기 위한 지원을 제공한다.


### 7.2.5. Working With YAML
[YAML](https://yaml.org/)은 JSON의 상위 집합이므로 계층적 구성 데이터를 지정하는 데 편리한 포맷이다. 스프링애플리케이션(SpringApplication) 클래스는 클래스패스에 [`SnakeYAML`](https://github.com/snakeyaml/snakeyaml) 라이브러리가 있을 때 프로퍼티 대신 YAML을 자동으로 지원한다.

{: .note}
"Starters"를 사용하는 경우 `SnakeYAML`은 `spring-boot-starter`에 의해 자동 제공된다.


#### Mapping YAML to Properties
YAML 문서는 계층 포맷에서 스프링 환경과 함께 사용할 수 있는 플랫 구조(flat structure)로 변환되어야 한다. 예를 들어 다음 YAML 문서를 생각해보자:

```yaml
    environments:
        dev:
            url: "https://dev.example.com"
            name: "Developer Setup"
        prod:
            url: "https://another.example.com"
            name: "My Cool App"
```

환경에서 이러한 프로퍼티에 접근하려면 다음과 같이 플랫화 되어아한다:
```
    environments.dev.url=https://dev.example.com
    environments.dev.name=Developer Setup
    environments.prod.url=https://another.example.com
    environments.prod.name=My Cool App
```

마찬가지로, YAML 리스트도 플랫화해야 한다. [index] 역참조자를 사용하여 속성 키로 표시된다. 예를 들어 다음 YAML을 생각해보자:
```yaml
    my:
        servers:
            - "dev.example.com"
            - "another.example.com"
```

앞의 예는 다음 프로퍼티로 변환된다.
```
    my.servers[0]=dev.example.com
    my.servers[1]=another.example.com
```

{: .note}
[index] 표기법을 사용하는 프로퍼티는 스프링 부트의 `바인더(Binder)` 클래스를 사용하여 자바 리스트 또는 세트(Set) 객체에 바인딩될 수 있다. 자세한 내용은 아래의 "Type-safe Configuration Properties" 절을 참고하자.

{: .warning}
`@PropertySource` 또는 `@TestPropertySource` 어노테이션을 사용하여 YAML 파일을 로드할 수 없다. 따라서 이러한 방식으로 값을 로드해야 하는 경우 프로퍼티스 파일을 사용해야 합니다.


#### Directly Loading YAML
스프링 프레임워크는 YAML 문서를 로드하는 데 사용할 수 있는 두 가지 편리한 클래스를 제공한다. `Yaml프로퍼티스팩토리빈(YamlPropertiesFactoryBean)`은 YAML을 프로퍼티스로 로드하고 `Yaml맵팩토리빈(YamlMapFactoryBean)`은 YAML을 맵으로 로드한다.


YAML을 스프링 `프로퍼티소스(PropertySource)`로 로드하려는 경우 `Yaml프로퍼티소스로더(YamlPropertySourceLoader)` 클래스를 사용할 수도 있다.


### 7.2.6. Configuring Random Values
`랜덤벨류프로퍼티소스(RandomValuePropertySource)`는 랜덤 값을 주입하는 데 유용하다(예: 시크릿 또는 테스트). 다음 예제와 같이 정수, long, uuid 또는 string을 생성할 수 있다:

`프로퍼티스(Properties)`
``` 
    my.secret=${random.value}
    my.number=${random.int}
    my.bignumber=${random.long}
    my.uuid=${random.uuid}
    my.number-less-than-ten=${random.int(10)}
    my.number-in-range=${random.int[1024,65536]}
```

`Yaml`
```yaml
  my:
    secret: "${random.value}"
    number: "${random.int}"
    bignumber: "${random.long}"
    uuid: "${random.uuid}"
    number-less-than-ten: "${random.int(10)}"
    number-in-range: "${random.int[1024,65536]}"
```

`random.int*` 구문은 `OPEN value (,max) CLOSE`이다. 여기서 `OPEN,CLOSE`는 랜덤 문자이고 `value,max`는 정수이다. `max`가 제공되면 `value`는 최소값이고 `max`는 최대값(제외, 미만)입니다.


### 7.2.7. Configuring System Environment Properties
스프링 부트는 환경 프로퍼티에 대한 접두사 설정을 지원한다. 이는 구성 요구 사항이 서로 다른 여러 스프링 부트 애플리케이션에서 시스템 환경을 공유하는 경우 유용하다. 시스템 환경 프로퍼티의 접두사는 `스프링애플리케이션(SpringApplication)`에서 직접 설정할 수 있다.

예를 들어, 접두어를 `input`으로 설정하면 시스템 환경에서는 `remote.timeout`과 같은 프로퍼티도 `input.remote.timeout`으로 해석된다.


### 7.2.8. Type-safe Configuration Properties
`@Value("${property}")` 어노테이션을 사용하여 구성 프로퍼티를 주입하는 것은 때로 번거로울 수 있다. 특히 여러 프로퍼티로 작업하거나 데이터가 본질적으로 계층적인 경우에 더욱 그렇다. 스프링 부트는 강력한 타입의 빈이 애플리케이션 구성을 관리하고 유효성을 검사할 수 있도록 하는 프로퍼티를 사용하여 작업하는 대안 메소드를 제공한다.

{: .note}
`@Value`와 `type-safe configuration` 프로퍼티의 차이점도 참고하자.


#### JavaBean Properties Binding
다음 예제와 같이 표준 `자바빈(JavaBean)` 프로퍼티를 선언한 빈을 바인딩하는 것이 가능하다:

`자바`
```java
    import java.net.InetAddress;
    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.List;
    import org.springframework.boot.context.properties.ConfigurationProperties;
    
    @ConfigurationProperties("my.service")
    public class MyProperties {
        private boolean enabled;
        private InetAddress remoteAddress;
        private final Security security = new Security();

        public boolean isEnabled() {
            return this.enabled;
        }
        
        public void setEnabled(boolean enabled) {
            this.enabled = enabled;
        }
        
        public InetAddress getRemoteAddress() {
            return this.remoteAddress;
        }

        public void setRemoteAddress(InetAddress remoteAddress) {
            this.remoteAddress = remoteAddress;
        }
      
        public Security getSecurity() {
            return this.security;
        }

        public static class Security {
            private String username;
            private String password;
            private List<String> roles = new ArrayList<>(Collections.singleton("USER"));

            public String getUsername() {
                return this.username;
            }

            public void setUsername(String username) {
                this.username = username;
            }
        
            public String getPassword() {
                return this.password;
            }

            public void setPassword(String password) {
                this.password = password;
            }

            public List<String> getRoles() {
                return this.roles;
            }

            public void setRoles(List<String> roles) {
                this.roles = roles;
            }
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import java.net.InetAddress

    @ConfigurationProperties("my.service")
    class MyProperties {
        var isEnabled = false
        var remoteAddress: InetAddress? = null
        val security = Security()

        class Security {
            var username: String? = null
            var password: String? = null
            var roles: List<String> = ArrayList(setOf("USER"))
        } 
    }
```

앞의 POJO는 다음 프로퍼티를 정의한다:
- `my.service.enabled`, 기본값은 `false`
- `my.service.remote-address`, 문자열에서 강제 변환할 수 있는 타입.
- `my.service.security.username`, 프로퍼티명에 따라 이름이 결정되는 중첩된 "security" 객체가 있다. 이 타입은 전혀 사용되지 않으며 `시큐리티프로퍼티스(SecurityProperties)`일 수 있다.
- `my.service.security.password.`
- `my.service.security.roles`, 기본값이 USER인 문자열 컬렉션이다.

***
`NOTE`

프로퍼티스 파일, YAML 파일, 환경 변수 및 기타 메커니즘을 통해 구성되는 스프링 부트에서 `@ConfigurationProperties` 클래스에 매핑되는 프로퍼티는 공개 API이지만 클래스 자체의 접근자(getter/setter)는 공개 API가 아니다.

이러한 배열은 기본 빈 생성자에 의존하며 getter 및 setter는 일반적으로 필수다. 바인딩은 스프링 MVC에서와 마찬가지로 표준 자바 빈즈 프로퍼티 디스크립터(Java Beans property descriptors)를 통해 이루어지기 때문이다. 다음과 같은 경우에는 setter가 생략될 수 있다:

- 맵은, 초기화되면 getter가 필요하지만 바인더에 의해 변경될 수 있으므로 반드시 setter는 필요하지 않다.
- 컬렉션과 배열은 인덱스(일반적으로 YAML 사용)를 하거나, 쉼표로 구분된 단일 값(프로퍼티스)을 사용하여 접근할 수 있다. 후자의 경우 setter가 필수다. 이러한 타입에 대해서는 항상 setter를 추가하는 것이 좋다. 컬렉션을 초기화하는 경우 이전 예제와 같이 컬렉션이 변경 불가능하지 않은지 확인하자.
- 중첩된 POJO 프로퍼티스가 초기화되면(이전 예의 Security 필드와 같이) setter가 필요하지 않다. 바인더가 기본 생성자를 사용하여 즉시 인스턴스를 생성하도록 하려면 setter가 필요하다.

어떤 사람들은 `롬복(Lombok)`을 사용하여 getter와 setter를 자동으로 추가합니다. 객체를 인스턴스화하기 위해 컨테이너에서 자동으로 사용되므로 롬복이 이러한 타입에 대해 특정 생성자를 생성하지 않는지 확인해야 한다.

마지막으로, 표준 자바 빈 프로퍼티스만 고려되며, 스태틱 프로퍼티에 대한 바인딩은 지원되지 않는다.
***


#### Constructor Binding
이전 절의 예제는 다음 예제와 같이 불변(immutable) 방식으로 다시 작성할 수 있다:

`자바`
```java
    import java.net.InetAddress;
    import java.util.List;
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.boot.context.properties.bind.DefaultValue;

    @ConfigurationProperties("my.service")
    public class MyProperties {
        private final boolean enabled;
        private final InetAddress remoteAddress;
        private final Security security;

        public MyProperties(boolean enabled, InetAddress remoteAddress, Security security) {
          this.enabled = enabled;
          this.remoteAddress = remoteAddress;
          this.security = security;
        }

        public boolean isEnabled() {
            return this.enabled;
        }
        
        public InetAddress getRemoteAddress() {
            return this.remoteAddress;
        }
        
        public Security getSecurity() {
            return this.security;
        }
    
        public static class Security {
            private final String username;
            private final String password;
            private final List<String> roles;

            public Security(String username, String password, @DefaultValue("USER") List<String> roles) {
                this.username = username;
                this.password = password;
                this.roles = roles;
            }

            public String getUsername() {
                return this.username;
            }
            
            public String getPassword() {
                return this.password;
            }
            
            public List<String> getRoles() {
                return this.roles;
            }
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.boot.context.properties.bind.DefaultValue
    import java.net.InetAddress

    @ConfigurationProperties("my.service")
    class MyProperties(val enabled: Boolean, val remoteAddress: InetAddress, val security: Security) {
        class Security(val username: String, val password: String, @param:DefaultValue("USER") val roles: List<String>)
    }
```

이 설정에서 파라미터화된 생성자가 있다는 것은 생성자 바인딩을 사용해야 함을 의미한다. 이는 바인더가 바인딩하려는 파라미터가 있는 생성자를 찾는것을 의미한다. 클래스에 여러 생성자가 있는 경우 `@ConstructorBinding` 어노테이션을 사용하여 생성자 바인딩에 사용할 생성자를 지정할 수 있다. 단일 파라미터화된 생성자가 있는 클래스에 대한 생성자 바인딩을 선택 해제하려면 생성자에 `@Autowired` 어노테이션을 달아야 한다. 생성자 바인딩은 레코드와 함께 사용할 수 있다. 레코드에 생성자가 여러 개 있지 않으면 `@ConstructorBinding`을 사용할 필요가 없다.

생성자 바인딩 클래스(예: 위 예의 Security)의 중첩 멤버도 해당 생성자를 통해 바인딩된다.

기본값은 생성자 파라미터 및 레코드 컴포넌트에 `@DefaultValue`를 사용하여 지정할 수 있다. 어노테이션의 문자열 값을 누락된 프로퍼티의 대상 타입으로 강제 변환하기 위해 변환 서비스(conversion service)가 적용된다.

이전 예제를 참고하면 `Security`에 바인딩된 프로퍼티스가 없으면, `MyProperties` 인스턴스에는 `Security`을 위해 `null` 값이 포함된다. 바인딩된 프로퍼티스가 없는 경우에도 `Null`이 아닌 `Security` 인스턴스를 포함하려면(코틀린을 사용하는 경우 기본값이 없으므로 `Security`의 사용자 이름 및 비밀번호 파라미터를 `null` 허용으로 선언해야 함) 빈(empty) `@DefaultValue` 어노테이션 사용한다:

`자바`
```java
    public MyProperties(boolean enabled, InetAddress remoteAddress, @DefaultValue Security security) {
        this.enabled = enabled;
        this.remoteAddress = remoteAddress;
        this.security = security;
    }
```

`코틀린`
```kotlin
    class MyProperties(val enabled: Boolean, val remoteAddress: InetAddress, @DefaultValue val security: Security) {
        class Security(val username: String?, val password: String?, @param:DefaultValue("USER") val roles: List<String>)
    }
```

{: .note}
생성자 바인딩을 사용하려면 `@EnableConfigurationProperties` 또는 컨피규레이션 프로퍼티 스캐닝(configuration property scanning)을 사용하여 클래스를 활성화해야 한다. 일반 스프링 메커니즘으로 생성된 빈(예: `@Component Bean`, `@Bean` 메서드를 사용하여 생성된 `Bean` 또는 `@Import`를 사용하여 로드된 `Bean`)에는 생성자 바인딩을 사용할 수 없다.

{: .note}
네이티브 이미지에서 생성자 바인딩을 사용하려면 클래스를 `-parameters`로 컴파일해야 한다. 이는 스프링 부트의 그레이들 플러그인을 사용하거나 메이븐 및 `spring-boot-starter-parent`를 사용하는 경우 자동으로 동작한다.

{: .note}
`@ConfigurationProperties`와 함께 `java.util.Optional`을 사용하는 것은 주로 리턴 타입으로 사용하기 위한 것이므로 권장되지 않는다. 따라서 구성 프로퍼티 주입에는 적합하지 않다. 다른 타입의 프로퍼티와의 일관성을 위해 `옵셔널(Optional)` 프로퍼티를 선언했는데 값이 없으면 빈 `옵셔널(Optional)`이 아닌 `null`이 바인딩된다.


#### Enabling @ConfigurationProperties-annotated Types
스프링 부트는 `@ConfigurationProperties` 타입을 바인딩하고 이를 빈으로 등록하는 인프라스트럭처를 제공한다. 클래스별로 구성 프로퍼티를 활성화하거나 컴포넌트 스캐닝(component scanning)과 유사한 방식으로 작동하는 구성 프로퍼티 스캐닝(configuration property scanning)을 활성화할 수 있다.

때로는, `@ConfigurationProperties`로 어노테이션이 달린 클래스가 스캐닝에 적합하지 않을 수 있다. 예를 들어, 자체 자동 구성(auto-configuration)을 개발 중이거나 조건부로 활성화하려는 경우가 그렇다. 이러한 경우 `@EnableConfigurationProperties` 어노테이션을 사용하여 처리할 타입 목록을 지정한다. 다음 예제와 같이 모든 `@Configuration` 클래스에서 이 작업을 수행할 수 있다:

`자바`
```java
    import org.springframework.boot.context.properties.EnableConfigurationProperties;
    import org.springframework.context.annotation.Configuration;
  
    @Configuration(proxyBeanMethods = false)
    @EnableConfigurationProperties(SomeProperties.class)
    public class MyConfiguration { }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.EnableConfigurationProperties
    import org.springframework.context.annotation.Configuration

    @Configuration(proxyBeanMethods = false)
    @EnableConfigurationProperties(SomeProperties::class)
    class MyConfiguration
```

`자바`
```java
    import org.springframework.boot.context.properties.ConfigurationProperties;

    @ConfigurationProperties("some.properties")
    public class SomeProperties { }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
  
    @ConfigurationProperties("some.properties")
    class SomeProperties
```

컨피규레이션 프로퍼티 스캐닝(configuration property scanning)을 사용하려면, 애플리케이션에 `@ConfigurationPropertiesScan` 어노테이션을 추가하자. 일반적으로 `@SpringBootApplication`이라는 어노테이션이 달린 메인 애플리케이션 클래스에 추가되지만, 모든 `@Configuration` 클래스에 추가할 수 있다. 기본적으로, 스캐닝은 어노테이션을 선언하는 클래스의 패키지에서 동작한다. 스캔할 특정 패키지를 정의하려면, 다음 예제에 표시된 대로 수행할 수 있다:

`자바`
```java
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.boot.context.properties.ConfigurationPropertiesScan;
  
    @SpringBootApplication
    @ConfigurationPropertiesScan({ "com.example.app", "com.example.another" })
    public class MyApplication { }
```

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.boot.context.properties.ConfigurationPropertiesScan

    @SpringBootApplication
    @ConfigurationPropertiesScan("com.example.app", "com.example.another")
    class MyApplication
```
<br>

***
`Note`

`@ConfigurationProperties` 빈이 컨피규레이션 프로퍼티 스캐닝을 사용하거나 `@EnableConfigurationProperties`를 통해 등록되면 빈은 `<prefix>-<fqn>`이라는 일반적인 이름을 갖는다. 여기서 <prefix>는 `@ConfigurationProperties` 어노테이션에 지정된 환경 키 접두사이고 <fqn> 빈의 완전한 이름이다. 어노테이션이 접두사를 제공하지 않으면 빈의 이름만 사용한다.

`com.example.app` 패키지에 있다고 가정하면, 위 `SomeProperties` 예제의 빈 이름은 `some.properties-com.example.app.SomeProperties`이다.
***

`@ConfigurationProperties`는 환경에서만 처리하고 특히 컨텍스트에서 다른 빈을 주입하지 않는 것이 좋다. 특수한 경우에는 setter 주입을 사용하거나 프레임워크에서 제공하는 `*Aware` 인터페이스(예: 환경에 접근해야 하는 경우 `인바이런먼트어웨어(EnvironmentAware)`)를 사용할 수 있다. 생성자를 사용하여 다른 빈을 계속 주입하려면 구성 프로퍼티 빈에 `@Component`로 어노테이션을 달고 자바빈즈 기반 프로퍼티 바인딩을 사용해야 한다.


#### Using @ConfigurationProperties-annotated Types
이 구성 스타일은 다음 예제와 같이 `스프링어노테이션(SpringApplication)` 외부 YAML 구성과 특히 잘 작동한다:

```yaml
  my: 
    service:
      remote-address: 192.168.1.1
        security:
          username: "admin"
            roles:
            - "USER"
            - "ADMIN"
```

`@ConfigurationProperties` 빈을 사용하려면 다음 예제와 같이 다른 빈과 동일한 방식으로 이를 주입할 수 있다:

`자바`
```java
    import org.springframework.stereotype.Service;
  
    @Service
    public class MyService {

        private final MyProperties properties;
        
        public MyService(MyProperties properties) {
            this.properties = properties;
        }
      
        public void openConnection() {
            Server server = new Server(this.properties.getRemoteAddress());
            server.start();
            // ...
        }
        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.stereotype.Service

    @Service
    class MyService(val properties: MyProperties) {
    
        fun openConnection() {
            val server = Server(properties.remoteAddress)
            server.start()
            // ...
        }
        // ... 
    }
```

{: .note}
`@ConfigurationProperties`를 사용하면 IDE에서 자체 키에 대한 자동 완성 기능을 제공하는 데 사용할 수 있는 메타데이터 파일을 생성할 수도 있다. 자세한 내용은 부록을 참고하자.


#### Third-party Configuration
`@ConfigurationProperties`를 사용하여 클래스에 어노테이션을 달 수 있을 뿐만 아니라 퍼블릭(public) `@Bean` 메서드에서도 사용할 수 있다. 이렇게 하면 제어할 수 없는 서드 파티 컴포넌트에 프로퍼티스를 바인딩하려는 경우 특히 유용할 수 있다.

환경 프로퍼티스에서, 빈을 구성하려면 다음 예제와 같이 해당 빈 등록에 `@ConfigurationProperties`를 추가하자:

`자바`
```java
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;

    @Configuration(proxyBeanMethods = false)
    public class ThirdPartyConfiguration {

        @Bean
        @ConfigurationProperties(prefix = "another")
        public AnotherComponent anotherComponent() {
            return new AnotherComponent();
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.context.annotation.Bean
    import org.springframework.context.annotation.Configuration

    @Configuration(proxyBeanMethods = false)
    class ThirdPartyConfiguration {
        @Bean
        @ConfigurationProperties(prefix = "another")
        fun anotherComponent(): AnotherComponent = AnotherComponent()
    }
```

다른 접두사로 정의된 자바빈 프로퍼티는 이전 `SomeProperties` 예제와 유사한 방식으로 해당 `AnotherComponent` 빈에 매핑된다.


#### Relaxed Binding
스프링 부트는 환경 프로퍼티스를 `@ConfigurationProperties` 빈에 바인딩하기 위해 몇 가지 완화된(relaxed) 규칙을 사용하므로 환경(Environment) 프로퍼티스명과 빈 프로퍼티스명이 정확히 일치할 필요는 없다. 이것이 유용한 예시는 대시(-)로 구분된 환경 프로퍼티스(예: context-path가 contextPath에 바인딩됨) 및 대문자로 표시된 환경 프로퍼티스(예: PORT가 port에 바인딩됨)이 포함된다.

예를 들어 다음 `@ConfigurationProperties` 클래스를 생각해보자:

`자바`
```java
    import org.springframework.boot.context.properties.ConfigurationProperties;

    @ConfigurationProperties(prefix = "my.main-project.person")
    public class MyPersonProperties {
        private String firstName;

        public String getFirstName() {
            return this.firstName;
        }
      
        public void setFirstName(String firstName) {
            this.firstName = firstName;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties

    @ConfigurationProperties(prefix = "my.main-project.person")
    class MyPersonProperties {
        var firstName: String? = null
    }
```

앞의 코드에서는 다음 프로퍼티스명을 모두 사용할 수 있다:

테이블 6. 완화된 바인딩 정책

|프로퍼티|설명|
|---|---|
|`my.main-project.person.first-name`|.properties 및 YAML 파일에 사용하도록 권장되는 케밥(Kebab) 케이스다|
|`my.main-project.person.firstName`|표준 카멜 케이스 문법.|
|`my.main-project.person.first_name`|.properties 및 YAML 파일에 사용하기 위한 대체 형식인 밑줄 표기법이다.|
|`MY_MAINPROJECT_PERSON_FIRSTNAME`|시스템 환경 변수를 사용할 때 권장되는 대문자 형식이다.|

{: .note}
어노테이션의 접두사 값은 케밥 대소문자(my.main-project.person과 같이 소문자로 -로 구분됨)여야 한다.

프로퍼티 소스당 완화된 바인딩 규칙
테이블 7. relaxed binding rules per property source

|프로퍼티 소스|심플|리스트|
|---|---|---|
|프로퍼티스 파일(Properties Files)|카멜 케이스, 케밥 케이스 또는 밑줄 표기|[ ] 또는 쉼표로 구분된 값을 사용하는 표준 목록 구문|
|YAML 파일|카멜 케이스, 케밥 케이스 또는 밑줄 표기|표준 YAML 목록 구문 또는 쉼표(,)로 구분된 값|
|환경 변수|밑줄을 구분 기호로 사용하는 대문자 형식이다(환경 변수에서 바인딩 참조).|밑줄로 묶인 숫자 값(환경 변수에서 바인딩 참조)|
|시스템 프로퍼티스|카멜 케이스, 케밥 케이스 또는 밑줄 표기|[ ] 또는 쉼표로 구분된 값을 사용하는 표준 목록 구문|

{: .note}
가능하면 프로퍼티를 `my.person.first-name=Rod`와 같은 소문자 케밥 형식으로 저장하는 것이 좋다.
.

#### Binding Maps
`맵` 프로퍼티스에 바인딩할 때 원래 `키` 값이 유지되도록 특수 대괄호 표기법을 사용해야 할 수도 있다. 키가 `[]`로 묶이지 않은 경우 영숫자가 아닌 `문자` 또는 `-` 또는 `.`가 제거된다.

예를 들어, 다음 프로퍼티스를 `Map<String,String>`에 바인딩하는 것을 생각해보자:

`프로퍼티스(Properties)`
``` 
    my.map.[/key1]=value1
    my.map.[/key2]=value2
    my.map./key3=value3
```

`Yaml`
```yaml
  my: 
    map:
      "[/key1]": "value1"
      "[/key2]": "value2"
      "/key3": "value3"
```

{: .note}
YAML 파일의 경우, 키를 올바르게 파싱하려면 대괄호를 따옴표로 묶어야 한다.

위의 속성은 맵의 키로 `/key1`, `/key2` 및 `key3`을 사용하여 맵에 바인딩된다. 슬래시는 대괄호로 묶이지 않았기 때문에 key3에서 제거됐다.

스칼라 값에 바인딩할 때 `.`가 포함된 키는 `[]`로 묶을 필요가 없다. 스칼라 값에는 `오브젝트(Object)`를 제외한 `java.lang` 패키지의 모든 타입과 이넘(enum)이 포함된다. `a.b=c`를 `Map<String, String>`에 바인딩하면 키의 `.`가 유지되고 `{"a.b"="c"}` 항목이 포함된 맵(Map)이 반환된다. 다른 타입의 경우 키에 `.`가 포함되어 있으면 대괄호 표기법을 사용해야 한다. 예를 들어, `a.b=c`를 `Map<String, Object>`에 바인딩하면 `{"a"={"b"="c"}}` 항목이 포함된 Map이 반환된다. 반면 `[a.b]=c`는 `{"a.b"="c"}` 항목이 포함된 맵를 반환한다.


#### Binding From Environment Variables
대부분의 운영 체제는 환경 변수에 사용할 수 있는 이름에 대해 엄격한 규칙을 적용한다. 예를 들어 리눅스 셸 변수에는 문자(`a`~`z` 또는 `A`~`Z`), 숫자(`0`~`9`) 또는 밑줄 문자(`_`)만 포함될 수 있다. 관례적으로 유닉스 쉘 변수명도 대문자로 표시된다.

스프링 부트의 완화된 바인딩 규칙은 가능한 한 이러한 명명 제한 사항과 호환되도록 설계됐다.

표준 형식의 프로퍼티명을 환경 변수명으로 변환하려면 다음 규칙을 따르면 된다:
- 점(.)을 밑줄(_)로 바꾼다.
- 대시(-)를 제거하자. 
- 소문자로 변경하자.

예를 들어, 구성 프로퍼티 `spring.main.log-startup-info`는 `SPRING_MAIN_LOGSTARTUPINFO`라는 환경 변수가 된다.

객체 목록에 바인딩할 때, 환경 변수를 사용할 수도 있다. 목록에 바인딩하려면 변수명에서 엘리먼트 번호를 밑줄로 묶어야 한다.

예를 들어 `my.service[0].other` 구성 프로퍼티는 `MY_SERVICE_0_OTHER`라는 환경 변수를 사용한다.


#### Merging Complex Types
목록이 여러 위치에 구성된 경우 오버라이드는 전체 목록을 바꾸는 방식으로 작동한다.

예를 들어, 기본적으로 null인 `name` 및 `description` 애트리뷰트을 가진 `MyPojo` 객체를 가정해보자.
다음 예에서는 `MyProperties`의 `MyPojo` 객체 리스트를 노출한다:

`자바`
```java
    import java.util.ArrayList;
    import java.util.List;
    import org.springframework.boot.context.properties.ConfigurationProperties;

    @ConfigurationProperties("my")
    public class MyProperties {
        private final List<MyPojo> list = new ArrayList<>();

        public List<MyPojo> getList() {
            return this.list;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    
    @ConfigurationProperties("my")
    class MyProperties {
        val list: List<MyPojo> = ArrayList()
    }
```

다음 구성을 생각해보자:

`프로퍼티스(Properties)`
``` 
my.list[0].name=my name
my.list[0].description=my description
#---
spring.config.activate.on-profile=dev
my.list[0].name=my another name
```

`Yaml`
```yaml
my: 
  list:
   - name: "my name"
     description: "my description"
--- 
spring:
  config:
    activate:
      on-profile: "dev"
my:
  list:
  - name: "my another name"
```

`dev` 프로필이 활성화되지 않은 경우 `MyProperties.list`에는 이전에 정의된 대로 하나의 `MyPojo` 항목이 포함된다. 그러나 `dev` 프로필이 활성화된 경우에도 리스트에는 여전히 하나의 항목만 포함된다(`my another name`의 `name`과 `null`의`description` 포함). 이 구성은 두 번째 `MyPojo` 인스턴스를 목록에 추가하지 않으며 항목을 병합하지 않는다.

여러 프로필에 리스트가 지정되면 우선 순위가 가장 높은 프로필(해당 프로필만)이 사용된다. 다음 예를 생각해보자:

`프로퍼티스(Properties)`
``` 
my.list[0].name=my name
my.list[0].description=my description
my.list[1].name=another name
my.list[1].description=another description
#---
spring.config.activate.on-profile=dev
my.list[0].name=my another name
```

`Yaml`
```yaml
my: 
  list:
  - name: "my name"
    description: "my description"
  - name: "another name"
    description: "another description"
--- 
spring:
  config:
    activate:
      on-profile: "dev"
my:
  list:
  - name: "my another name"
```

앞의 예에서 `dev` 프로필이 활성화된 경우 `MyProperties.list`에는 하나의 `MyPojo` 항목(`my another name`의 `name`과 `null`의 `description` 포함)이 포함된다. YAML의 경우 쉼표로 구분된 목록과 YAML 목록을 모두 사용하여 목록 내용을 완전히 오버라이드할 수 있다.

맵 프로퍼티스의 경우, 여러 소스에서 가져온 프로퍼티 값과 바인딩할 수 있다. 그러나 여러 소스의 동일한 프로퍼티에 대해서는 우선순위가 가장 높은 프로퍼티가 사용된다. 다음 예에서는 `MyProperties`에서 `Map<String, MyPojo>`를 노출한다:

`자바`
```java
    import java.util.LinkedHashMap;
    import java.util.Map;
    import org.springframework.boot.context.properties.ConfigurationProperties;

    @ConfigurationProperties("my")
    public class MyProperties {
        private final Map<String, MyPojo> map = new LinkedHashMap<>();
        
        public Map<String, MyPojo> getMap() {
            return this.map;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties

    @ConfigurationProperties("my")
    class MyProperties {
        val map: Map<String, MyPojo> = LinkedHashMap()
    }
```

다음 구성을 생각해보자:

`프로퍼티스(Properties)`
``` 
my.map.key1.name=my name 1
my.map.key1.description=my description 1
#---
spring.config.activate.on-profile=dev
my.map.key1.name=dev name 1
my.map.key2.name=dev name 2
my.map.key2.description=dev description 2
```

`Yaml`
```yaml
my: 
  map:
    key1:
      name: "my name 1"
      description: "my description 1"
--- 
spring:
  config:
  activate:
    on-profile: "dev"
my:
  map: 
    key1:
      name: "dev name 1"
    key2:
      name: "dev name 2"
      description: "dev description 2"
```

`dev` 프로필이 활성화되지 않은 경우 `MyProperties.map`에는 키가 `key1`(`name`에 `my name 1`과 `description`에 `my description 1`)이 있는 하나의 항목이 포함된다. 그러나 `dev` 프로필이 활성화된 경우 맵에는 `key1`(`name`에 `dev name 1`과 `description`에 `my description 1`) 및 `key2`(`name`에 `dev name 2`과 `description`에 `dev description 2`)가 있는 두 개의 항목이 포함된다.

{: .note}
앞의 병합 규칙은 파일뿐만 아니라 모든 프로퍼티 소스의 프로프티스에 적용된다.


#### Properties Conversion
스프링 부트는 `@ConfigurationProperties` 빈에 바인딩될 때 외부 애플리케이션 프로퍼티스을 올바른 타입으로 강제 변환하려고 시도한다. 커스텀 타입 변환이 필요한 경우 `컨버젼서비스(ConversionService)` 빈(`conversionService`라는 빈 포함) 또는 커스텀 프로퍼티 에디터(`커스텀에디터컨피규어러(CustomEditorConfigurer)` 빈을 통해) 또는 커스텀 컨버터(`@ConfigurationPropertiesBinding` 어노테이션이 달린 빈 정의 포함)를 제공할 수 있다.

{: .note}
이 빈은 애플리케이션 라이프사이클 중 매우 초기에 요청되므로 `컨버젼서비스(ConversionService)`가 사용하는 의존성을 제한해야 한다. 일반적으로 필요한 의존성은 생성 시 완전히 초기화되지 않을 수 있다. 구성 키 강제 변환에 필요하지 않고 `@ConfigurationPropertiesBinding`으로 자격을 갖춘 커스텀 컨버터에만 의존하는 경우 커스텀 `컨버전서비스(ConversionService)`의 이름을 바꿀 수 있다.


#### Converting Durations
스프링 부트에는 기간(durations) 표현을 위한 전용 지원이 있다. `java.time.Duration` 프로퍼티를 노출하는 경우, 애플리케이션 프로퍼티스에서 다음 포맷을 사용할 수 있다:
- 일반적인 긴 표현(`@DurationUnit`이 지정되지 않은 한 기본 단위로 밀리초 사용)
- `java.time.Duration`에서 사용되는 표준 ISO-8601 형식
- 값(value)과 단위(unit)가 결합되어 더 읽기 쉬운 형식(10s는 10초를 의미함).

다음 예제를 생각해보자:

`자바`
```java
    import java.time.Duration;
    import java.time.temporal.ChronoUnit;
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.boot.convert.DurationUnit;

    @ConfigurationProperties("my")
    public class MyProperties {
        @DurationUnit(ChronoUnit.SECONDS)
        private Duration sessionTimeout = Duration.ofSeconds(30);
        private Duration readTimeout = Duration.ofMillis(1000);
        
        public Duration getSessionTimeout() {
          return this.sessionTimeout;
        }
      
        public void setSessionTimeout(Duration sessionTimeout) {
            this.sessionTimeout = sessionTimeout;
        }
      
        public Duration getReadTimeout() {
            return this.readTimeout;
        }
        
        public void setReadTimeout(Duration readTimeout) {
            this.readTimeout = readTimeout;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.boot.convert.DurationUnit
    import java.time.Duration
    import java.time.temporal.ChronoUnit

    @ConfigurationProperties("my")
    class MyProperties {

        @DurationUnit(ChronoUnit.SECONDS)
        var sessionTimeout = Duration.ofSeconds(30)
        var readTimeout = Duration.ofMillis(1000)
    }
```

세션 시간 초과를 30초로 지정하려면 30, PT30S 및 30s가 모두 동일하다. 500ms의 읽기 시간 제한은 500, PT0.5S 및 500ms 포맷으로 지정할 수 있다.

지원되는 단위를 사용할 수도 있다:
- `ns` for nanoseconds 
- `us` for microseconds
- `ms` for milliseconds 
- `s` for seconds
- `m` for minutes
- `h` for hours
- `d` for days

기본 단위는 밀리초(ms)이며, 위 샘플에 표시된 대로 `@DurationUnit`을 사용하여 오버라이드할 수 있다.

생성자 바인딩을 사용하려는 경우 다음 예제와 같이 동일한 프로퍼티스를 노출할 수 있다:

`자바`
```java
    import java.time.Duration;
    import java.time.temporal.ChronoUnit;
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.boot.context.properties.bind.DefaultValue;
    import org.springframework.boot.convert.DurationUnit;

    @ConfigurationProperties("my")
    public class MyProperties {
        private final Duration sessionTimeout;
        private final Duration readTimeout;
        
        public MyProperties(@DurationUnit(ChronoUnit.SECONDS) @DefaultValue("30s") Duration sessionTimeout, @DefaultValue("1000ms") Duration readTimeout) {
            this.sessionTimeout = sessionTimeout;
            this.readTimeout = readTimeout;
        }
        
        public Duration getSessionTimeout() {
            return this.sessionTimeout;
        }
        
        public Duration getReadTimeout() {
            return this.readTimeout;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.boot.context.properties.bind.DefaultValue
    import org.springframework.boot.convert.DurationUnit
    import java.time.Duration
    import java.time.temporal.ChronoUnit

    @ConfigurationProperties("my")
    class MyProperties(@param:DurationUnit(ChronoUnit.SECONDS) @param:DefaultValue("30s") val sessionTimeout: Duration, @param:DefaultValue("1000ms") val readTimeout: Duration)
```

{: .note}
`Long` 프로퍼티로 업그레이드하는 경우 밀리초가 아닌 경우 단위를 정의해야 한다(`@DurationUnit` 사용). 이렇게 하면 훨씬 더 풍부한 포맷을 지원하면서 투명한 업그레이드가 제공된다.


#### Converting Periods
기간(Durations) 외에도, 스프링 부트는 `java.time.Period` 타입에서도 작동할 수 있다. 애플리케이션 프로퍼티스에서는 다음 타입을 사용할 수 있다: 
- 일반 int 표현(`@PeriodUnit`이 지정되지 않은 한 일(days)을 기본 단위로 사용)
- `java.time.Period`에서 사용되는 표준 ISO-8601 형식
- 값과 단위 쌍이 결합되는 더 간단한 형식(1y3d는 1년 3일을 의미함)


단순 형식에서는 다음 단위가 지원된다:
- `y` for years
- `m` for months 
- `w` for weeks
- `d` for days

{: .note}
`java.time.Period` 타입은 실제로 주(weeks) 수를 저장하지 않으며, "7일"을 의미하는 단축어다.


#### Converting Data Sizes
스프링 프레임워크에는 크기를 바이트 단위로 표현하는 `데이터사이즈(DataSize)` 값 타입이 있다. 데이터사이즈(DataSize) 프로퍼티를 노출하는 경우 애플리케이션 프로퍼티에서 다음 타입을 사용할 수 있다:
- 일반적인 긴 표현(`@DataSizeUnit`이 지정되지 않은 한 바이트를 기본 단위로 사용)
- 값과 단위가 결합되어 더 읽기 쉬운 형식(10MB는 10MB를 의미함)

다음 예제를 생각해보자:

`자바`
```java
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.boot.convert.DataSizeUnit;
    import org.springframework.util.unit.DataSize;
    import org.springframework.util.unit.DataUnit;

    @ConfigurationProperties("my")
    public class MyProperties {
        @DataSizeUnit(DataUnit.MEGABYTES)
        private DataSize bufferSize = DataSize.ofMegabytes(2);

        private DataSize sizeThreshold = DataSize.ofBytes(512);

        public DataSize getBufferSize() {
            return this.bufferSize;
        }
        
        public void setBufferSize(DataSize bufferSize) {
            this.bufferSize = bufferSize;
        }
        
        public DataSize getSizeThreshold() {
            return this.sizeThreshold;
        }
        
        public void setSizeThreshold(DataSize sizeThreshold) {
            this.sizeThreshold = sizeThreshold;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.boot.convert.DataSizeUnit
    import org.springframework.util.unit.DataSize
    import org.springframework.util.unit.DataUnit

    @ConfigurationProperties("my")
    class MyProperties {
        @DataSizeUnit(DataUnit.MEGABYTES)
        var bufferSize = DataSize.ofMegabytes(2)
        var sizeThreshold = DataSize.ofBytes(512)
    }
```
10MB의 버퍼 크기를 지정하려면, 10과 10MB가 동일하다. 256바이트의 크기 임계값(threshold)은 256 또는 256B로 지정할 수 있다.

지원되는 단위를 사용할 수도 있다:
- `B` for bytes
- `KB` for kilobytes
- `MB` for megabytes
- `GB` for gigabytes
- `TB` for terabytes

기본 단위는 바이트이며 위 샘플에 표시된 대로 `@DataSizeUnit`을 사용하여 오버라이드할 수 있다.

생성자 바인딩을 사용하려는 경우 다음 예제와 같이 동일한 프로퍼티를 노출할 수 있다.

`자바`
```java
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.boot.context.properties.bind.DefaultValue;
    import org.springframework.boot.convert.DataSizeUnit;
    import org.springframework.util.unit.DataSize;
    import org.springframework.util.unit.DataUnit;

    @ConfigurationProperties("my")
    public class MyProperties {
        private final DataSize bufferSize;
        private final DataSize sizeThreshold;
        
        public MyProperties(@DataSizeUnit(DataUnit.MEGABYTES) @DefaultValue("2MB") DataSize bufferSize, @DefaultValue("512B") DataSize sizeThreshold) {
            this.bufferSize = bufferSize;
            this.sizeThreshold = sizeThreshold;
        }
        
        public DataSize getBufferSize() {
            return this.bufferSize;
        }
      
        public DataSize getSizeThreshold() {
            return this.sizeThreshold;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.boot.context.properties.bind.DefaultValue
    import org.springframework.boot.convert.DataSizeUnit
    import org.springframework.util.unit.DataSize
    import org.springframework.util.unit.DataUnit

    @ConfigurationProperties("my")
    class MyProperties(@param:DataSizeUnit(DataUnit.MEGABYTES) @param:DefaultValue("2MB") val bufferSize: DataSize, @param:DefaultValue("512B") val sizeThreshold: DataSize)
```

{: .note}
`Long` 프로퍼티를 업그레이드하는 경우, 바이트가 아닌 경우 단위를 정의해야 한다(`@DataSizeUnit` 사용). 이렇게 하면 훨씬 더 풍부한 포맷을 지원하면서 투명한 업그레이드가 제공된다.


#### @ConfigurationProperties Validation
스프링 부트는 스프링의 `@Validated` 어트리뷰트가 추가될 때마다, `@ConfigurationProperties` 클래스의 유효성을 검사하려고 시도한다. 구성 클래스에서 직접 `JSR-303 jakarta.validation` 제약 조건(constraint) 어노테이션을 사용할 수 있다. 이렇게 하려면, 다음 예제에 표시된 대로 호환 `JSR-303` 구현이 클래스패스에 있는지 확인한 후 필드에 제약 조건 어노테이션을 추가하자:

`자바`
```java
    import java.net.InetAddress;
    import jakarta.validation.constraints.NotNull;
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.validation.annotation.Validated;

    @ConfigurationProperties("my.service")
    @Validated
    public class MyProperties {
        @NotNull
        private InetAddress remoteAddress;
        public InetAddress getRemoteAddress() {
            return this.remoteAddress;
        }
      
        public void setRemoteAddress(InetAddress remoteAddress) {
            this.remoteAddress = remoteAddress;
        }
    }
```

`코틀린`
```kotlin
    import jakarta.validation.constraints.NotNull
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.validation.annotation.Validated
    import java.net.InetAddress

    @ConfigurationProperties("my.service")
    @Validated
    class MyProperties {
        var remoteAddress: @NotNull InetAddress? = null
    }
```

{: .note}
`@Validated`로 구성 프로퍼티스를 생성하는 `@Bean` 메서드에 어노테이션을 달아 유효성 검사를 트리거할 수도 있다.

프로퍼티가 발견되지 않은 경우에도, 중첩된 프로퍼티스에 대해 유효성 검사가 항상 트리거되도록 하려면, 연결된 필드에 `@Valid` 어노테이션을 달아야 한다. 다음 예제는 이전 `MyProperties` 예제를 기반으로 한다:

`자바`
```java
    import java.net.InetAddress;
    import jakarta.validation.Valid;
    import jakarta.validation.constraints.NotEmpty;
    import jakarta.validation.constraints.NotNull;
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.validation.annotation.Validated;
    
    @ConfigurationProperties("my.service")
    @Validated
    public class MyProperties {
        @NotNull
        private InetAddress remoteAddress;
        
        @Valid
        private final Security security = new Security();
        
        public InetAddress getRemoteAddress() {
            return this.remoteAddress;
        }
    
        public void setRemoteAddress(InetAddress remoteAddress) {
            this.remoteAddress = remoteAddress;
        }
    
        public Security getSecurity() {
            return this.security;
        }
        
        public static class Security {
            @NotEmpty
            private String username;
            
            public String getUsername() {
                return this.username;
            }
            
            public void setUsername(String username) {
                this.username = username;
            } 
        }
    }
```

`코틀린`
```kotlin
    import jakarta.validation.Valid
    import jakarta.validation.constraints.NotEmpty
    import jakarta.validation.constraints.NotNull
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.validation.annotation.Validated
    import java.net.InetAddress

    @ConfigurationProperties("my.service")
    @Validated
    class MyProperties {
        var remoteAddress: @NotNull InetAddress? = null
      
        @Valid
        val security = Security()
      
        class Security {
            @NotEmpty
            var username: String? = null
        } 
    }
```

`컨피규레이션프로퍼티스밸리데이터(ConfigurationPropertiesValidator)`라는 빈을 생성하여 커스텀 스프링 `밸리데이터(Validator)`를 추가할 수도 있다. `@Bean` 메소드는 스태틱으로 선언되어야 한다. 구성 프로퍼티스 밸리데이터는 애플리케이션 라이프사이클 초기에 생성되며 `@Bean` 메서드를 스태틱으로 선언하면 `@Configuration` 클래스를 인스턴스화하지 않고도 빈을 생성할 수 있다. 이렇게 하면 초기 인스턴스화로 인해 발생할 수 있는 문제를 피할 수 있다.

{: .note}
`spring-boot-actuator` 모듈에는 모든 `@ConfigurationProperties` 빈을 노출하는 엔드포인트가 포함되어 있다. 웹 브라우저에서 `/actuator/configprops`를 가리키거나 동등한 JMX 엔드포인트를 사용해보자. 자세한 내용은 "Production ready features" 절을 참고하자.


#### @ConfigurationProperties vs. @Value
`@Value` 어노테이션은 코어 컨테이너 기능이며 `타입 세이프한 구성 프로퍼티`와 동일한 기능을 제공하지 않는다. 다음 표에는 `@ConfigurationProperties` 및 `@Value`에서 지원되는 기능이 요약되어 있다:

|기능|`@ConfigurationProperties`|`@Value`|
|---|---|---|
|완화된 바인딩(Relaxed binding)|Yes|제한됨(아래 참고 참조)|
|메타데이터(Meta-data) 지원|Yes|No|
|SpEL evaluation|No|Yes|

{: .note}
>`@Value`를 사용하려면 표준 포맷(소문자만 사용하는 케밥 케이스)을 사용하여 프로퍼티명을 참조하는 것이 좋다. 이렇게 하면 스프링 부트가 `@ConfigurationProperties` 바인딩을 완화할 때(Relaxed)와 동일한 논리를 사용할 수 있다.

{: .note}
>예를 들어 `@Value("\${demo.item-price}")`는 `application.properties` 파일에서 `demo.item-price` 및 `demo.itemPrice` 포맷을 선택하고 시스템 환경에서 `DEMO_ITEMPRICE`를 선택한다. 대신 `@Value("\${demo.itemPrice}")`를 사용한 경우, `deco.item-price` 및 `DEMO_ITEMPRICE`는 고려하지 않는다.

자체 컴포넌트에 대한 구성 키 세트을 정의하는 경우 `@ConfigurationProperties` 어노테이션이 달린 POJO로 그룹화하는 것이 좋다. 그렇게 하면 자신의 빈에 주입할 수 있는 구조화되고 타입이 안전한 객체가 제공된다.


애플리케이션 특성 파일의 SpEL 표현식은 해당 파일을 파싱하고 환경을 채울 때 처리되지 않는다. 그러나 `@Value`에 `SpEL 표현식`을 작성할 수 있다. 애플리케이션 프로퍼티스 파일의 프로퍼티 값이 `SpEL` 표현식인 경우 `@Value`를 통해 사용될 때 평가된다.


## 7.3. Profiles
스프링 프로필(Profile)은 애플리케이션 구성의 일부를 분리하고 특정 환경에서만 사용할 수 있도록 한다. 다음 예제와 같이 `@Component`, `@Configuration` 또는 `@ConfigurationProperties`를 `@Profile`로 표시하여 로드 시 제한할 수 있다:

`자바`
```java
    import org.springframework.context.annotation.Configuration;
    import org.springframework.context.annotation.Profile;
    
    @Configuration(proxyBeanMethods = false)
    @Profile("production")
    public class ProductionConfiguration {
        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.context.annotation.Configuration
    import org.springframework.context.annotation.Profile
    
    @Configuration(proxyBeanMethods = false)
    @Profile("production")
    class ProductionConfiguration {
        // ... 
    }
```

{. :note}
`@ConfigurationProperties` 빈이 자동 스캐닝(automatic scannin) 대신 `@EnableConfigurationProperties`를 통해 등록된 경우, `@EnableConfigurationProperties` 어노테이션이 있는 `@Configuration` 클래스에 `@Profile` 어노테이션을 지정해야 한다. `@ConfigurationProperties`를 스캔하는 경우 `@ConfigurationProperties` 클래스 자체에 `@Profile`을 지정할 수 있다.


`spring.profiles.active` 환경 프로퍼티를 사용하여 활성할 프로필을 지정할 수 있다. 이 장의 앞부분에서 설명한 방법으로 프로퍼티를 지정할 수 있다. 예를 들어 다음 예제와 같이 이를 `application.properties`에 포함할 수 있다.

`프로퍼티스(Properties)`
```
    spring.profiles.active=dev,hsqldb
```

`Yaml`
```yaml
  spring:
    profiles:
      active: "dev,hsqldb"
```

다음 스위치를 사용하여 커맨드라인에서 이를 지정할 수도 있다: `--spring.profiles.active=dev,hsqldb`

활성화된 프로필이 없으면 기본 프로필이 활성화된다. 기본 프로필명은 `default`이며 다음 예제와 같이 `spring.profiles.default` 환경 프로퍼티를 사용하여 조정할 수 있다:

`프로퍼티스(Properties)`
```
spring.profiles.default=none
```

`Yaml`
```yaml
# 유효한 문서
spring:
  profiles:
    active: "prod"
---
# 유효하지 않은 문서
spring:
  config:
    activate:
      on-profile: "prod"
    profiles:
      active: "metrics"
```


### 7.3.1. Adding Active Profiles
`spring.profiles.active` 프로퍼티는 다른 프로퍼티와 동일한 순서 규칙을 따른다. 가장 높은 `프로퍼티소스(PropertySource)`가 우선이다. 즉, `application.properties`에서 활성(active) 프로필을 지정한 다음 커맨드라인 스위치를 사용하여 해당 프로필을 바꿀 수 있다.

경우에 따라 활성 프로필을 대체하는 대신 추가하는 프로퍼티를 갖는 것이 유용할 수 있다. `spring.profiles.include` 프로퍼티는 `spring.profiles.active` 프로퍼티에 의해 활성화된 프로필에 추가 프로필을 붙이는데 사용될 수 있다. `스프링애플리케이션(SpringApplication)` 엔드포인트에는 추가 프로필을 설정하기 위한 자바 API도 있다. [스프링애플리케이션](https://docs.spring.io/spring-boot/docs/3.1.1/api/org/springframework/boot/SpringApplication.html)의 `setAdditionalProfiles()` 메서드를 참고하자.


예를 들어, 다음 프로퍼티스를 가진 애플리케이션이 실행되면 `--spring.profiles.active` 스위치를 사용하여 실행 중에도 공통 및 로컬 프로필이 활성화된다:

`프로퍼티스(Properties)`
```
    spring.profiles.include[0]=common
    spring.profiles.include[1]=local
```

`Yaml`
```yaml
spring:
  profiles:
    include:
    - "common"
    - "local"
```

{: .warning}
`spring.profiles.active`와 유사하게 `spring.profiles.include`는 프로필이 아닌 특정 문서에서만 사용할 수 있다. 이는 `spring.config.activate.on-profile`에 의해 활성화된 프로필 특정 파일이나 문서에 포함될 수 없음을 의미한다.

다음 절에 설명된 프로필 그룹은 특정 프로필이 활성화된 경우 활성 프로필을 추가하는 데에도 사용할 수 있다.


### 7.3.2. Profile Groups
때때로 애플리케이션에서 정의하고 사용하는 프로필이 너무 세밀하여 사용하기 불편해지는 경우가 있다. 예를 들어, 데이터베이스 및 메시징 기능을 독립적으로 활성화하는 데 사용하는 `proddb` 및 `prodmq` 프로필이 있을 수 있다.

이를 돕기 위해 스프링 부트에서는 프로필 그룹을 정의할 수 있다. 프로필 그룹을 사용하면 관련 프로필 그룹에 대한 논리적 이름을 정의할 수 있다.

예를 들어, `proddb` 및 `prodmq` 프로필로 구성된 프로덕션 그룹을 만들 수 있다.

`프로퍼티스(Properties)`
```
spring.profiles.group.production[0]=proddb
spring.profiles.group.production[1]=prodmq
```

`Yaml`
```yaml
spring:
  profiles:
    group:
      production:
        - "proddb"
        - "prodmq"
```

이제 `--spring.profiles.active=production`을 사용하여 애플리케이션을 시작하여 프로덕션, `proddb` 및 `prodmq` 프로필을 한 번에 활성화할 수 있다.


### 7.3.3. Programmatically Setting Profiles
애플리케이션이 실행되기 전에 `SpringApplication.setAdditionalProfiles(...)`를 호출하여 프로그래밍 방식으로 활성 프로필을 설정할 수 있다. 스프링의 `컨피규러블인바이런먼트(ConfigurableEnvironment)` 인터페이스를 사용하여 프로필을 활성화하는 것도 가능하다.


### 7.3.4. Profile-specific Configuration Files
`application.properties`(또는 `application.yaml`)과 `@ConfigurationProperties`를 통해 참조되는 파일의 프로필별 변수는 파일로 간주되어 로드된다. 자세한 내용은 ["Profile Specific Files"]()을 참고하자.


## 7.4. Logging
스프링 부트는 모든 내부 로깅에 [커먼즈 로깅(Commons Logging)](https://commons.apache.org/proper/commons-logging/)을 사용하지만 기본 로그 구현은 열어 둔다. [`자바 유틸 로깅(Java Util Logging)`](https://docs.oracle.com/javase/17/docs/api/java/util/logging/package-summary.html), [`로그4j2(Log4j2)`](https://logging.apache.org/log4j/2.x/) 및 [`로그백(Logback)`](https://logback.qos.ch/)에 대한 기본 구성이 제공된다. 각 상황에 로거는 옵셔널하게 파일 출력도 사용할 수 있는 콘솔 출력을 사용하도록 사전 구성되어 있다.

기본적으로 "Starters"를 사용하면 로그백(Logback)이 로깅에 사용된다. 자바 유틸 로깅(Java Util Logging), 커먼즈 로깅(Commons Logging), 로그4J(Log4J) 또는 SLF4J를 사용하는 의존 라이브러리가 모두 올바르게 작동하도록 적절한 로그백 라우팅도 포함되어 있다.

{: .note}
자바에 사용할 수 있는 로깅 프레임워크는 많다. 위 내용이 혼란스러워 보이더라도 걱정하지 말자. 일반적으로 로깅 의존성을 변경할 필요가 없으며 스프링 부트는 기본값으로도 잘 작동한다.

{: .note}
애플리케이션을 서블릿 컨테이너 또는 애플리케이션 서버에 배포할 때 자바 유틸 로깅 API(Java Util Logging API)로 수행된 로깅은 애플리케이션의 로그로 라우팅되지 않는다. 이렇게 하면 컨테이너나 컨테이너에 배포된 다른 애플리케이션이 수행한 로깅이 애플리케이션 로그에 표시되지 않는다.


### 7.4.1. Log Format
스프링 부트의 기본 로그 출력은 다음 예제같다:
```
    2023-06-22T12:08:05.861Z  INFO 22768 --- [           main] o.s.b.d.f.s.MyApplication
    : Starting MyApplication using Java 17.0.7 with PID 22768 (/opt/apps/myapp.jar started by myuser in /opt/apps/)
    2023-06-22T12:08:05.872Z  INFO 22768 --- [           main] o.s.b.d.f.s.MyApplication
    : No active profile set, falling back to 1 default profile: "default"
    2023-06-22T12:08:09.854Z  INFO 22768 --- [           main]
    o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080(http)
    2023-06-22T12:08:09.892Z  INFO 22768 --- [           main]
    o.apache.catalina.core.StandardService   : Starting service [Tomcat]
    2023-06-22T12:08:09.892Z  INFO 22768 --- [           main]
    o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.10]
    2023-06-22T12:08:10.160Z  INFO 22768 --- [           main]
    o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
    2023-06-22T12:08:10.162Z  INFO 22768 --- [           main]
    w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 4038 ms
    2023-06-22T12:08:11.512Z  INFO 22768 --- [           main]
    o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
    2023-06-22T12:08:11.534Z  INFO 22768 --- [           main] o.s.b.d.f.s.MyApplication : Started MyApplication in 7.251 seconds (process running for 8.584)
```

다음 항목이 출력된다:
- 날짜 및 시간: 밀리초 단위의 정밀도로 쉽게 정렬할 수 있다.
- 로그 레벨: `ERROR`, `WARN`, `INFO`, `DEBUG`, or `TRACE`.
- 프로세스 ID.
- --- 실제 로그 메시지의 시작을 구분하는 구분 기호
- 스레드명(Thread name) : 대괄호로 묶는다(콘솔 출력의 경우 잘릴 수 있음).
- 로거명(Logger name): 이는 일반적으로 소스 클래스 이름이다(종종 축약됨).
- 로그 메세지.

{: .note}
로그백(Logback)에는 `FATAL` 레벨이 없다. `ERROR`에 매핑된다.


### 7.4.2. Console Output
기본 로그 구성은 메시지가 기록될 때 콘솔에 메시지를 표시한다. 기본적으로 `ERROR` 레벨, `WARN` 레벨 및 `INFO` 레벨 메시지가 기록된다. `--debug` 플래그로 애플리케이션을 시작하여 "debug" 모드를 활성화할 수도 있다.

```
    $ java -jar myapp.jar --debug
```

{: .note}
`application.properties`에 `debug=true`를 지정할 수도 있다.

디버그(debug) 모드가 활성화되면 코어 로거 선택(임베디드 컨테이너, 하이버네이트 및 스프링 부트)이 더 많은 정보를 출력하도록 구성한다. 디버그 모드를 활성화해도 DEBUG 레벨의 모든 메시지를 기록하도록 애플리케이션이 구성되지는 않는다.

또는, `--trace` 플래그(또는 `application.properties`의 `trace=true`)를 사용하여 애플리케이션을 시작하여 "trace" 모드를 활성화할 수 있다. 이렇게 하면 핵심 로거 선택(임베디드 컨테이너, 하이버네이트 스키마 생성 및 전체 스프링 포트폴리오(Spring portfolio))에 대한 추적 로깅이 가능해진다.


#### Color-coded Output
터미널이 ANSI를 지원하는 경우 가독성을 돕기 위해 컬러 출력이 사용된다. `spring.output.ansi.enabled`를 [지원되는 값](https://docs.spring.io/spring-boot/docs/3.1.1/api/org/springframework/boot/ansi/AnsiOutput.Enabled.html)으로 설정하여 자동 감지를 오버라이드 할 수 있다.

컬러 코딩은 `%clr` 변환 단어를 사용하여 구성된다. 가장 간단한 형태의 컨버터는 다음 예와 같이 로그 레벨에 따라 출력 색상을 지정한다:

```
    %clr(%5p)
```

다음 표에서는 로그 레벨과 색상의 매핑을 설명한다:

|Level|Color|
|---|---|
|`FATAL`|Red|
|`ERROR`|Red|
|`WARN`|Yellow|
|`INFO`|Green|
|`DEBUG`|Green|
|`TRACE`|Green|

또는 변환 옵션으로 제공하여 사용해야 하는 색상이나 스타일을 지정할 수 있다. 예를 들어 텍스트를 노란색으로 만들려면 다음 설정을 사용해보자:

``` 
    %clr(%d{yyyy-MM-dd'T'HH:mm:ss.SSSXXX}){yellow}
```

다음 색상과 스타일이 지원된다:
- `blue`
- `cyan`
- `faint`
- `green`
- `magenta`
- `red`
- `yellow`


### 7.4.3. File Output
기본적으로 스프링 부트는 콘솔에만 기록하고 로그 파일을 기록하지 않는다. 콘솔 출력 외에 로그 파일을 작성하려면 `login.file.name` 또는 `login.file.path` 프로퍼티(예: `application.properties`)을 설정해야 한다.

다음 표에서는 `logging.* properties`을 함께 사용할 수 있는 방법을 보여준다.

테이블 8. 로깅 프로퍼티즈

|`logging.file.name`|`logging.file.path`|예제|설명|
|---|---|---|---|
|(none)|(none)||오직 콘솔 로깅.|
|지정된 파일|(none)|`my.log`|지정된 로그 파일에 쓴다. 이름은 정확한 위치일 수도 있고 현재 디렉터리 기준일 수 있다.|
|(none)|지정된 디렉토리|`/var/log`|지정된 디렉터리에 `spring.log`를 쓴다. 이름은 정확한 위치일 수도 있고 현재 디렉터리 기준일 수 있다.|

로그 파일은 10MB에 도달하면 로테이션 처리되며, 콘솔 출력과 마찬가지로 `ERROR` 레벨, `WARN` 레벨 및 `INFO` 레벨 메시지가 기본적으로 기록된다.

{: .note}
로깅 프로퍼티는 실제 로깅 인프라와 독립적이다. 결과적으로 특정 구성 키(예: 로그백(Logback)의 `logback.configurationFile`)는 스프링 부트에서 관리되지 않는다.


### 7.4.4. File Rotation
로그백을 사용하는 경우 `application.properties` 또는 `application.yaml` 파일을 사용하여 로그 로테이션 설정을 미세 조정할 수 있다. 다른 모든 로깅 시스템의 경우 로테이션 설정을 직접 구성해야 한다(예를 들어 로그4j2(Log4j2)를 사용하는 경우 `log4j2.xml` 또는 `log4j2-spring.xml` 파일을 추가할 수 있음).


다음 로테이션 정책 프로퍼티스가 지원된다:

|명칭|설명|
|---|---|
|`logging.logback.rollingpolicy.file-name-pattern`|로그 압축파일를 생성하는 데 사용되는 파일 이름 패턴이다.|
|`logging.logback.rollingpolicy.clean-history-on-start`|애플리케이션이 시작될 때 로그 압축파일 정리가 발생해야 하는지 여부다.|
|`logging.logback.rollingpolicy.max-file-size`|압축되기 전 로그 파일의 최대 크기다.|
|`logging.logback.rollingpolicy.total-size-cap`|로그 압축파일이 삭제되기 전까지 도달할 수 있는 최대 크기다.|
|`logging.logback.rollingpolicy.max-history`|보관할 최대 보관 로그 파일 수(기본값은 7)다.|


### 7.4.5. Log Levels
지원되는 모든 로깅 시스템은 `log.level.<logger-name>=<level>`을 사용하여 스프링 환경(예: `application.properties`)에서 로거 레벨을 설정할 수 있다. 여기서 레벨은 TRACE, DEBUG, INFO, WARN, ERROR, FATAL 또는 OFF. `루트(root)` 로거는 `login.level.root`를 사용하여 구성할 수 있다.

다음 예에서는 `application.properties`의 잠재적인 로깅 설정을 보여준다:

`프로퍼티스(Properties)`
```
logging.level.root=warn
logging.level.org.springframework.web=debug
logging.level.org.hibernate=error
```

`Yaml`
```yaml
logging:
  level:
    root: "warn"
      org.springframework.web: "debug"
        org.hibernate: "error"
```

환경 변수를 사용하여 로깅 레벨을 설정할 수도 있습니다. 예를 들어 `LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_WEB=DEBUG`는 `org.springframework.web`을 `DEBUG`로 설정한다.

{: .note}
위의 접근 방식은 패키지 레벨 로깅에만 작동한다. 완화된 바인딩은 항상 환경 변수를 소문자로 변환하므로 이러한 방식으로 개별 클래스에 대한 로깅을 구성하는 것은 불가능하다. 클래스에 대한 로깅을 구성해야 하는 경우 `SPRING_APPLICATION_JSON` 변수를 사용할 수 있다.


### 7.4.6. Log Groups
관련 로거를 그룹화하여 동시에 구성할 수 있으면 유용한 경우가 많이 있다. 예를 들어 모든 톰캣 관련 로거에 대한 로깅 레벨을 공통적으로 변경할 수 있지만 최상위 레벨 패키지를 쉽게 기억할 수 없다.

이를 돕기 위해 스프링 부트를 사용하면 스프링 환경에서 로깅 그룹을 정의할 수 있다. 예를 들어, `application.properties`에 "tomcat" 그룹을 추가하여 정의하는 방법은 다음과 같다.

`프로퍼티스(Properties)`
```
logging.group.tomcat=org.apache.catalina,org.apache.coyote,org.apache.tomcat
```

`Yaml`
```yaml
logging:
  group:
    tomcat: "org.apache.catalina,org.apache.coyote,org.apache.tomcat"
```


정의한 후에, 한 줄로 그룹 내 모든 로거의 레벨을 변경할 수 있다:

`프로퍼티스(Properties)`
```
logging.level.tomcat=trace
```

`Yaml`
```yaml
logging:
  level:
    tomcat: "trace"
```

스프링 부트에는 즉시 사용할 수 있는 다음과 같은 사전 정의된 로깅 그룹이 포함되어 있다:

|명칭|로거(Loggers)|
|---|---|
|web|`org.springframework.core.codec`,<br> `org.springframework.http,org.springframework.web`,<br> `org.springframework.boot.actuate.endpoint.web`,<br> `org.springframework.boot.web.servlet.ServletContextInitializerBeans`|
|sql|`org.springframework.jdbc.core`,<br> `org.hibernate.SQL, org.jooq.tools.LoggerListener`|


### 7.4.7. Using a Log Shutdown Hook
애플리케이션이 종료될 때 로깅 리소스를 해제하기 위해 JVM이 종료될 때 로그 시스템 정리를 트리거하는 종료 후크가 제공된다. 이 종료 후크는 애플리케이션이 war 파일로 배포되지 않는 한 자동으로 등록된다. 애플리케이션에 복잡한 컨텍스트 계층 구조가 있는 경우 종료 후크가 요구 사항을 충족하지 못할 수 있다. 그렇지 않은 경우 종료 후크를 비활성화하고 기본 로깅 시스템에서 직접 제공하는 옵션을 조사해보자. 예를 들어 로그백은 각 로거(Logger)가 자체 컨텍스트에서 생성될 수 있도록 하는 컨텍스트 셀렉터를 제공한다. `login.register-shutdown-hook` 프로퍼티을 사용하여 종료 후크를 비활성화할 수 있다. `false`로 설정하면 등록이 비활성화된다. `application.properties` 또는 `application.yaml` 파일에서 프로퍼티를 설정할 수 있다:

`프로퍼티스(Properties)`
```
    logging.register-shutdown-hook=false
```

`Yaml`
```yaml
    logging:
        register-shutdown-hook: false
```


### 7.4.8. Custom Log Configuration
다양한 로깅 시스템은 클래스패스에 적절한 라이브러리를 포함하여 활성화할 수 있으며 클래스패스의 루트 또는 스프링 환경 프로퍼티인 `login.config`에 의해 지정된 위치에 적절한 구성 파일을 제공하여 추가로 커스텀할 수 있다.

`org.springframework.boot.logging.LoggingSystem` 시스템 프로퍼티을 사용하여 스프링 부트가 특정 로깅 시스템을 사용하도록 강제할 수 있다. 값은 `로깅시스템(LoggingSystem)` 구현체의 클래스 이름이어야 한다. `none` 값을 사용하여 스프링 부트의 로깅 구성을 완전히 비활성화할 수도 있다.

{: .note}
`애플리케이션컨텍스트(ApplicationContext)`가 생성되기 전에 로깅이 초기화되므로 스프링 `@Configuration` 파일의 `@PropertySources`에서 로깅을 제어하는 ​​것은 불가능하다. 로깅 시스템을 변경하거나 완전히 비활성화하는 유일한 방법은 시스템 프로퍼티를 이용하는 것이다.

로깅 시스템에 따라 다음 파일이 로드된다:

|로깅 시스템|커스텀 파일|
|---|---|
|`Logback`|`logback-spring.xml`, `logback-spring.groovy`, `logback.xml`, or `logback.groovy`
|`Log4j2`|`log4j2-spring.xml` or `log4j2.xml`|
|`JDK (Java Util Logging)`|`logging.properties`|

{: .note}
가능하다면 로깅 구성에 `-spring` 변수을 사용하는 것이 좋다(예: `logback.xml` 대신 `logback-spring.xml`). 표준 구성 위치를 사용하는 경우 스프링은 로그 초기화를 완전히 제어할 수 없다.

{: .warning}
`자바 유틸 로깅(Java Util Logging)`에는 '실행 가능한 jar'에서 실행할 때 문제를 일으키는 것으로 알려진 클래스 로딩 문제가 있다. 가능하다면 '실행 가능한 jar'에서 실행할 때는 이를 피하는 것이 좋다.

커스텀을 돕기 위해 다음 표에 설명된 대로 일부 다른 프로퍼티가 스프링 환경에서 시스템 프로퍼티로 전송된다:

|스프링 환경변수|시스템 프로퍼티|설명|
|---|---|---|
|`logging.exception-conversion-word`|`LOG_EXCEPTION_CONVERSION_WORD`|예외를 기록할 때 사용되는 변환 단어다.|
|`logging.file.name`|`LOG_FILE`|정의된 경우 기본 로그 구성에 사용된다.|
|`logging.file.path`|`LOG_PATH`|정의된 경우 기본 로그 구성에 사용된다.|
|`logging.pattern.console`|`CONSOLE_LOG_PATTERN`|콘솔(stdout)에서 사용할 로그 패턴이다.|
|`logging.pattern.dateformat`|`LOG_DATEFORMAT_PATTERN`|로그 날짜 형식에 대한 어펜더 패턴이다.|
|`logging.charset.console`|`CONSOLE_LOG_CHARSET`|콘솔 로깅에 사용할 문자 세트다.|
|`logging.threshold.console`|`CONSOLE_LOG_THRESHOLD`|콘솔 로깅에 사용할 로그 레벨 임계값(threshold)이다.|
|`logging.pattern.file`|`FILE_LOG_PATTERN`|파일에 사용할 로그 패턴이다(LOG_FILE이 활성화된 경우).|
|`logging.charset.file`|`FILE_LOG_CHARSET`|파일 로깅에 사용할 문자 세트이다(LOG_FILE이 활성화된 경우).|
|`logging.threshold.file`|`FILE_LOG_THRESHOLD`|파일 로깅에 사용할 로그 레벨 임계값입니다.|
|`logging.pattern.level`|`LOG_LEVEL_PATTERN`|로그 레벨을 렌더링할 때 사용할 형식(기본값 %5p)이다.|
|`PID`|`PID`|현재 프로세스 ID(발견되고 아직 OS 환경 변수로 정의되지 않은 경우).|


로그백을 사용하면 다음 프로퍼티스도 전달된다:

|스프링 환경변수|시스템 프로퍼티|설명|
|---|---|---|
|`logging.logback.rollingpolicy.file-name-pattern`|`LOGBACK_ROLLINGPOLICY_FILE_NAME_PATTERN`|롤오버(rolled-over)된 로그 파일 이름의 패턴(기본값 ${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz).|
|`logging.logback.rollingpolicy.clean-history-on-start`|`LOGBACK_ROLLINGPOLICY_CLEAN_HISTORY_ON_START`|시작 시 보관 로그 파일을 정리할지 여부다.|
|`logging.logback.rollingpolicy.max-file-size`|`LOGBACK_ROLLINGPOLICY_MAX_FILE_SIZE`|최대 로그 파일 사이즈이다.|
|`logging.logback.rollingpolicy.total-size-cap`|``LOGBACK_ROLLINGPOLICY_TOTAL_SIZE_CAP`|보관할 로그 백업의 총 크기다.|
|`logging.logback.rollingpolicy.max-history`|`LOGBACK_ROLLINGPOLICY_MAX_HISTORY`|보관할 최대 로그 파일 수다.|

지원되는 모든 로깅 시스템은 구성 파일을 파싱할 때 시스템 프로퍼티스을 참조할 수 있다. 예제는 `spring-boot.jar`의 기본 구성을 참고하자.
• [Logback](https://github.com/spring-projects/spring-boot/blob/v3.1.1/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml)
• [Log4j 2](https://github.com/spring-projects/spring-boot/blob/v3.1.1/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml)
• [Java Util logging](https://github.com/spring-projects/spring-boot/blob/v3.1.1/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties)

{: .note}
로깅 프로퍼티에서 자리 표시자(placeholder)를 사용하려면 기본 프레임워크의 문법이 아닌 스프링 부트의 문법을 사용해야 한다. 특히 로그백을 사용하는 경우 프로퍼티명과 기본값 사이의 구분 기호로 :를 사용해야 하며 :-를 사용하면 안 된다.

{: .note}
`LOG_LEVEL_PATTERN`(또는 로그벡으로 `login.pattern.level`)만 오버라이드하여 MDC 및 기타 임시 콘텐츠를 로그 줄에 추가할 수 있다. 예를 들어, `login.pattern.level=user:%X{user} %5p`를 사용하는 경우 다음 예에 표시된 대로 기본 로그 포맷은 "user"에 대한 MDC 항목이 있는 경우 포함된다.

```sh
    2019-08-30 12:30:04.031 user:someone INFO 22174 --- [  nio-8080-exec-0]
    demo.Controller
    Handling authenticated request
```


### 7.4.9. Logback Extensions
스프링 부트에는 고급 구성에 도움이 될 수 있는 로그백에 대한 다양한 확장이 포함되어 있다. `logback-spring.xml` 구성 파일에서 이러한 확장을 사용할 수 있다.

{: .note}
표준 `logback.xml` 구성 파일이 너무 일찍 로드되므로 해당 파일에서 확장을 사용할 수 없다. `logback-spring.xml`을 사용하거나 `login.config` 프로퍼티를 정의해야 한다.

{: .warning}
확장 기능은 로그백의 구성 스캐닝과 함께 사용할 수 없다. 그렇게 하려고 하면 구성 파일을 변경하면 다음 중 하나와 유사한 오류가 나타난다:
```
    ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for
    [springProperty], current ElementPath is [[configuration][springProperty]]
    ERROR in ch.qos.logback.core.joran.spi.Interpreter@4:71 - no applicable action for
    [springProfile], current ElementPath is [[configuration][springProfile]]
```


#### Profile-specific Configuration
`<springProfile>` 태그를 사용하면 활성 스프링 프로필을 기반으로 구성 섹션을 선택적으로 포함하거나 제외할 수 있다. 프로필 섹션은 `<configuration>` 엘리먼트 내 어디에서나 지원된다. 이름 애트리뷰트를 사용하여 구성 프로필을 지정합니다. `<springProfile>` 태그에는 프로필명(예: staging) 또는 프로필 표현식이 포함될 수 있다. 프로필 표현을 사용하면 `production & (eu-central | eu-west)`와 같이 더 복잡한 프로필 로직를 표현할 수 있다. 자세한 내용은 [스프링 프레임워크 레퍼런스 가이드](https://docs.spring.io/spring-framework/reference/core/beans/environment.html#beans-definition-profiles-java)를 확인하자. 다음은 세 가지 샘플 프로필을 보여준다:
```xml
    <springProfile name="staging">
        <!-- configuration to be enabled when the "staging" profile is active -->
    </springProfile>
    <springProfile name="dev | staging">
        <!-- configuration to be enabled when the "dev" or "staging" profiles are active-->
    </springProfile>
    <springProfile name="!production">
        <!-- configuration to be enabled when the "production" profile is not active -->
    </springProfile>
```


#### Environment Properties
`<springProperty>` 태그를 사용하면 로그백(Logback) 내에서 사용할 스프링 환경의 프로퍼티스를 노출할 수 있다. 이렇게 하면 로그백 구성의 `application.properties` 파일 값에 접근하는 경우 유용하다. 태그는 로그백의 표준 `<property>` 태그와 비슷한 방식으로 작동한다. 그러나 직접 값을 지정하는 대신 환경에서 프로퍼티 소스를 지정한다. 로컬 범위가 아닌 다른 곳에 프로퍼티을 저장해야 하는 경우 범위 특성을 사용할 수 있다. 대체 값이 필요한 경우(프로퍼티가 환경에 설정되지 않은 경우) `defaultValue` 프로퍼티를 사용할 수 있다. 다음 예에서는 로그백 내에서 사용할 프로퍼티를 노출하는 방법을 보여준다:

```xml
    <springProperty scope="context" name="fluentHost" source="myapp.fluentd.host" defaultValue="localhost"/>
    <appender name="FLUENT" class="ch.qos.logback.more.appenders.DataFluentAppender">
        <remoteHost>${fluentHost}</remoteHost>
        ...
    </appender>
```

{: .note}
소스는 케밥 형식(예: my.property-name)으로 지정해야 한다. 그러나 완화된 규칙(relaxed rules)을 사용하여 환경에 프로퍼티스를 추가할 수 있다.


### 7.4.10. Log4j2 Extensions
스프링 부트에는 고급 구성에 도움이 될 수 있는 로그4j2에 대한 다양한 확장이 포함되어 있다. 모든 `log4j2-spring.xml` 구성 파일에서 이러한 확장을 사용할 수 있다.

{: .note}
표준 `log4j2.xml` 구성 파일이 너무 일찍 로드되므로 해당 파일에서 확장을 사용할 수 없다. `log4j2-spring.xml`을 사용하거나 `login.config` 프로퍼티을 정의해야 한다.

{: .note}
확장은 Log4J에서 제공하는 스프링 부트 지원을 대체한다. 빌드에 `org.apache.logging.log4j:log4j-spring-boot` 모듈을 포함하지 않도록 해야 한다.


#### Profile-specific Configuration
`<SpringProfile>` 태그를 사용하면 활성 스프링 프로필을 기반으로 구성 섹션을 선택적으로 포함하거나 제외할 수 있다. 프로필 섹션은 `<Configuration>` 엘리먼트 내 어디에서나 지원된다. 이름 애트리뷰트를 사용하여 구성을 허용하는 프로필을 지정한다. `<SpringProfile>` 태그에는 프로필명(예: staging) 또는 프로필 표현식이 포함될 수 있다. 프로필 표현을 사용하면 `production & (eu-central | eu-west)`와 같이 더 복잡한 프로필 로직를 표현할 수 있다. 자세한 내용은 [스프링 프레임워크 레퍼런스 가이드](https://docs.spring.io/spring-framework/reference/core/beans/environment.html#beans-definition-profiles-java)를 확인하자. 다음은 세 가지 샘플 프로필을 보여준다:

```xml
    <SpringProfile name="staging">
        <!-- configuration to be enabled when the "staging" profile is active -->
    </SpringProfile>
    <SpringProfile name="dev | staging">
        <!-- configuration to be enabled when the "dev" or "staging" profiles are active-->
    </SpringProfile>
    <SpringProfile name="!production">
        <!-- configuration to be enabled when the "production" profile is not active -->
    </SpringProfile>
```


#### Environment Properties Lookup
Log4j2 구성 내에서 스프링 환경의 프로퍼티스를 참조하려면 `spring:` 접두사가 붙은 조회를 사용할 수 있다. 이렇게 하면 Log4j2 구성의 `application.properties` 파일 값에 접근하려는 경우 유용하다.

다음 예제에서는 스프링 환경에서 `spring.application.name`을 읽는 `applicationName`이라는 Log4j2 프로퍼티를 설정하는 방법을 보여준다.
The following example shows how to set a Log4j2 property named applicationName that reads spring.application.name from the Spring Environment:

```xml
<Properties>
    <Property name="applicationName">${spring:spring.application.name}</Property>
</Properties>
```

{: .note}
조회 키는 케밥 케이스(예: my.property-name)로 지정해야 한다.


#### Log4j2 System Properties
Log4j2는 다양한 항목을 구성하는 데 사용할 수 있는 다양한 시스템 프로퍼티스를 지원한다. 예를 들어 log4j2.skipJansi 시스템 프로퍼티스를 사용하면 `콘솔어펜더(ConsoleAppender)`가 윈도우에서 Jansi 출력 스트림을 사용할지를 구성할 수 있다. Log4j2 초기화 이후 로드되는 모든 시스템 프로퍼티스는 스프링 환경에서 얻을 수 있다. 예를 들어, 윈도우에서 `콘솔어펜더(ConsoleAppender)`가 Jansi를 사용하도록 하려면 `application.properties` 파일에 `log4j2.skipJansi=false`를 추가할 수 있다.

{: .note}
스프링 환경은 시스템 프로퍼티스와 OS 환경 변수에 로드되는 값이 포함되어 있지 않은 경우에만 고려된다.

{: warning}
>Log4j2 초기화 중에 로드된 시스템 프로퍼티스는 스프링 환경을 참조할 수 없다. 예를 들어 Log4j2가 기본 로그4j2 구현체를 사용하는 프로퍼티는 스프링 환경을 사용할 수 있기 전에 선택된다.


## 7.5. Internationalization
Spring Boot supports localized messages so that your application can cater to users of different language preferences. By default, Spring Boot looks for the presence of a messages resource bundle at the root of the classpath.

{: .note}
The auto-configuration applies when the default properties file for the configured resource bundle is available (messages.properties by default). If your resource bundle contains only language-specific properties files, you are required to add the default. If no properties file is found that matches any of the configured base
names, there will be no auto-configured MessageSource.

The basename of the resource bundle as well as several other attributes can be configured using
the spring.messages namespace, as shown in the following example:

`프로퍼티스(Properties)`
```
    spring.messages.basename=messages,config.i18n.messages
    spring.messages.fallback-to-system-locale=false
```

`Yaml`
```yaml
    spring:
        messages:
            basename: "messages,config.i18n.messages"
            fallback-to-system-locale: false    
```

{: .note}
spring.messages.basename supports comma-separated list of locations, either a package qualifier or a resource resolved from the classpath root.

See MessageSourceProperties for more supported options.


## 7.6. JSON
Spring Boot provides integration with three JSON mapping libraries:
- Gson
- Jackson
- JSON-B

Jackson is the preferred and default library.

### 7.6.1. Jackson
Auto-configuration for Jackson is provided and Jackson is part of spring-boot-starter-json. When Jackson is on the classpath an ObjectMapper bean is automatically configured. Several configuration properties are provided for customizing the configuration of the ObjectMapper.

#### Custom Serializers and Deserializers
If you use Jackson to serialize and deserialize JSON data, you might want to write your own JsonSerializer and JsonDeserializer classes. Custom serializers are usually registered with Jackson through a module, but Spring Boot provides an alternative @JsonComponent annotation that makes it easier to directly register Spring Beans.

You can use the @JsonComponent annotation directly on JsonSerializer, JsonDeserializer or KeyDeserializer implementations. You can also use it on classes that contain serializers/deserializers as inner classes, as shown in the following example:

`자바`
```java
    import java.io.IOException;
    import com.fasterxml.jackson.core.JsonGenerator;
    import com.fasterxml.jackson.core.JsonParser;
    import com.fasterxml.jackson.core.ObjectCodec;
    import com.fasterxml.jackson.databind.DeserializationContext;
    import com.fasterxml.jackson.databind.JsonDeserializer;
    import com.fasterxml.jackson.databind.JsonNode;
    import com.fasterxml.jackson.databind.JsonSerializer;
    import com.fasterxml.jackson.databind.SerializerProvider;
    import org.springframework.boot.jackson.JsonComponent;

    @JsonComponent
    public class MyJsonComponent {
        
        public static class Serializer extends JsonSerializer<MyObject> {
        
            @Override
            public void serialize(MyObject value, JsonGenerator jgen, SerializerProvider serializers) throws IOException {
                jgen.writeStartObject();
                jgen.writeStringField("name", value.getName());
                jgen.writeNumberField("age", value.getAge());
                jgen.writeEndObject();
            } 
        }
    
        public static class Deserializer extends JsonDeserializer<MyObject> {
            @Override
            public MyObject deserialize(JsonParser jsonParser, DeserializationContext ctxt) throws IOException {
                ObjectCodec codec = jsonParser.getCodec();
                JsonNode tree = codec.readTree(jsonParser);
                String name = tree.get("name").textValue();
                int age = tree.get("age").intValue();

                return new MyObject(name, age);
            } 
        }
    }
```

`코틀린`
```kotlin
    import com.fasterxml.jackson.core.JsonGenerator
    import com.fasterxml.jackson.core.JsonParser
    import com.fasterxml.jackson.core.JsonProcessingException
    import com.fasterxml.jackson.databind.DeserializationContext
    import com.fasterxml.jackson.databind.JsonDeserializer
    import com.fasterxml.jackson.databind.JsonNode
    import com.fasterxml.jackson.databind.JsonSerializer
    import com.fasterxml.jackson.databind.SerializerProvider
    import org.springframework.boot.jackson.JsonComponent
    import java.io.IOException
    
    @JsonComponent
    class MyJsonComponent {
        class Serializer : JsonSerializer<MyObject>() {
            @Throws(IOException::class)
            override fun serialize(value: MyObject, jgen: JsonGenerator, serializers: SerializerProvider) {
                jgen.writeStartObject()
                jgen.writeStringField("name", value.name)
                jgen.writeNumberField("age", value.age)
                jgen.writeEndObject()
            } 
        }
        
        class Deserializer : JsonDeserializer<MyObject>() {
            @Throws(IOException::class, JsonProcessingException::class)
            override fun deserialize(jsonParser: JsonParser, ctxt: DeserializationContext): MyObject {
                val codec = jsonParser.codec
                val tree = codec.readTree<JsonNode>(jsonParser)
                val name = tree["name"].textValue()
                val age = tree["age"].intValue()
              
              return MyObject(name, age)
            } 
        }
    }
```

All @JsonComponent beans in the ApplicationContext are automatically registered with Jackson. Because @JsonComponent is meta-annotated with @Component, the usual component-scanning rules apply.

Spring Boot also provides JsonObjectSerializer and JsonObjectDeserializer base classes that provide useful alternatives to the standard Jackson versions when serializing objects. See JsonObjectSerializer and JsonObjectDeserializer in the Javadoc for details.

The example above can be rewritten to use JsonObjectSerializer/JsonObjectDeserializer as follows:

`자바`
```java
    import java.io.IOException;
    import com.fasterxml.jackson.core.JsonGenerator;
    import com.fasterxml.jackson.core.JsonParser;
    import com.fasterxml.jackson.core.ObjectCodec;
    import com.fasterxml.jackson.databind.DeserializationContext;
    import com.fasterxml.jackson.databind.JsonNode;
    import com.fasterxml.jackson.databind.SerializerProvider;
    import org.springframework.boot.jackson.JsonComponent;
    import org.springframework.boot.jackson.JsonObjectDeserializer;
    import org.springframework.boot.jackson.JsonObjectSerializer;

    @JsonComponent
    public class MyJsonComponent {
        public static class Serializer extends JsonObjectSerializer<MyObject> {
            @Override
            protected void serializeObject(MyObject value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
                jgen.writeStringField("name", value.getName());
                jgen.writeNumberField("age", value.getAge());
            } 
        }
        
        public static class Deserializer extends JsonObjectDeserializer<MyObject> {
            @Override
            protected MyObject deserializeObject(JsonParser jsonParser, DeserializationContext context, ObjectCodec codec, JsonNode tree) throws IOException {
                String name = nullSafeValue(tree.get("name"), String.class);
                int age = nullSafeValue(tree.get("age"), Integer.class);
                return new MyObject(name, age);
            }
        }
    }
```

`코틀린`
```kotlin
    import com.fasterxml.jackson.core.JsonGenerator
    import com.fasterxml.jackson.core.JsonParser
    import com.fasterxml.jackson.core.ObjectCodec
    import com.fasterxml.jackson.databind.DeserializationContext
    import com.fasterxml.jackson.databind.JsonNode
    import com.fasterxml.jackson.databind.SerializerProvider
    import org.springframework.boot.jackson.JsonComponent
    import org.springframework.boot.jackson.JsonObjectDeserializer
    import org.springframework.boot.jackson.JsonObjectSerializer
    import java.io.IOException

    @JsonComponent
    class MyJsonComponent {
        class Serializer : JsonObjectSerializer<MyObject>() {
            @Throws(IOException::class)
            override fun serializeObject(value: MyObject, jgen: JsonGenerator, provider: SerializerProvider) {
                jgen.writeStringField("name", value.name)
                jgen.writeNumberField("age", value.age)
            }
        }
        
        class Deserializer : JsonObjectDeserializer<MyObject>() {
            @Throws(IOException::class)
            override fun deserializeObject(jsonParser: JsonParser, context: DeserializationContext, codec: ObjectCodec, tree: JsonNode): MyObject {
                val name = nullSafeValue(tree["name"], String::class.java)
                val age = nullSafeValue(tree["age"], Int::class.java)
                
                return MyObject(name, age)
            } 
        }
    }
```

#### Mixins
Jackson has support for mixins that can be used to mix additional annotations into those already declared on a target class. Spring Boot’s Jackson auto-configuration will scan your application’s packages for classes annotated with @JsonMixin and register them with the auto-configured ObjectMapper. The registration is performed by Spring Boot’s JsonMixinModule.


### 7.6.2. Gson
Auto-configuration for Gson is provided. When Gson is on the classpath a Gson bean is automatically configured. Several spring.gson.* configuration properties are provided for customizing the configuration. To take more control, one or more GsonBuilderCustomizer beans can be used.


### 7.6.3. JSON-B
Auto-configuration for JSON-B is provided. When the JSON-B API and an implementation are on the classpath a Jsonb bean will be automatically configured. The preferred JSON-B implementation is Eclipse Yasson for which dependency management is provided.


## 7.7. Task Execution and Scheduling
In the absence of an Executor bean in the context, Spring Boot auto-configures a ThreadPoolTaskExecutor with sensible defaults that can be automatically associated to asynchronous task execution (@EnableAsync) and Spring MVC asynchronous request processing.

{: .note}
If you have defined a custom Executor in the context, regular task execution (that is @EnableAsync) will use it transparently but the Spring MVC support will not be configured as it requires an AsyncTaskExecutor implementation (named applicationTaskExecutor). Depending on your target arrangement, you could change your Executor into a ThreadPoolTaskExecutor or define both a ThreadPoolTaskExecutor and an AsyncConfigurer wrapping your custom Executor.
The auto-configured TaskExecutorBuilder allows you to easily create instances that reproduce what the auto-configuration does by default.

The thread pool uses 8 core threads that can grow and shrink according to the load. Those default settings can be fine-tuned using the spring.task.execution namespace, as shown in the following example:


`프로퍼티스(Properties)`
```
    spring.task.execution.pool.max-size=16
    spring.task.execution.pool.queue-capacity=100
    spring.task.execution.pool.keep-alive=10s
```

`Yaml`
```yaml
    spring:
        task:
            execution:
                pool:
                    max-size: 16
                    queue-capacity: 100
                    keep-alive: "10s"
```

This changes the thread pool to use a bounded queue so that when the queue is full (100 tasks), the thread pool increases to maximum 16 threads. Shrinking of the pool is more aggressive as threads are reclaimed when they are idle for 10 seconds (rather than 60 seconds by default).

A ThreadPoolTaskScheduler can also be auto-configured if need to be associated to scheduled task execution (using @EnableScheduling for instance). The thread pool uses one thread by default and its settings can be fine-tuned using the spring.task.scheduling namespace, as shown in the following example:

`프로퍼티스(Properties)`
```
    spring.task.scheduling.thread-name-prefix=scheduling-
    spring.task.scheduling.pool.size=2
```

`Yaml`
```yaml
    spring:
        task:
            scheduling:
                thread-name-prefix: "scheduling-"
                pool:
                    size: 2
```

Both a TaskExecutorBuilder bean and a TaskSchedulerBuilder bean are made available in the context if a custom executor or scheduler needs to be created.


## 7.8. Testing
Spring Boot provides a number of utilities and annotations to help when testing your application. Test support is provided by two modules: spring-boot-test contains core items, and spring-boot- test-autoconfigure supports auto-configuration for tests.

Most developers use the spring-boot-starter-test “Starter”, which imports both Spring Boot test modules as well as JUnit Jupiter, AssertJ, Hamcrest, and a number of other useful libraries.

{: .note}
If you have tests that use JUnit 4, JUnit 5’s vintage engine can be used to run them. To use the vintage engine, add a dependency on junit-vintage-engine, as shown in the following example:

```
    <dependency>
        <groupId>org.junit.vintage</groupId>
        <artifactId>junit-vintage-engine</artifactId>
        <scope>test</scope> 
        <exclusions>
            <exclusion>
                <groupId>org.hamcrest</groupId>
                    <artifactId>hamcrest-core</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
```
hamcrest-core is excluded in favor of org.hamcrest:hamcrest that is part of spring-boot-starter-test.


### 7.8.1. Test Scope Dependencies
The spring-boot-starter-test “Starter” (in the test scope) contains the following provided libraries:
- JUnit 5: The de-facto standard for unit testing Java applications.
- Spring Test & Spring Boot Test: Utilities and integration test support for Spring Boot applications.
- AssertJ: A fluent assertion library.
- Hamcrest: A library of matcher objects (also known as constraints or predicates).
- Mockito: A Java mocking framework.
- JSONassert: An assertion library for JSON.
- JsonPath: XPath for JSON.
We generally find these common libraries to be useful when writing tests. If these libraries do not suit your needs, you can add additional test dependencies of your own.


### 7.8.2. Testing Spring Applications
One of the major advantages of dependency injection is that it should make your code easier to unit test. You can instantiate objects by using the new operator without even involving Spring. You can also use mock objects instead of real dependencies.

Often, you need to move beyond unit testing and start integration testing (with a Spring ApplicationContext). It is useful to be able to perform integration testing without requiring deployment of your application or needing to connect to other infrastructure.

The Spring Framework includes a dedicated test module for such integration testing. You can declare a dependency directly to org.springframework:spring-test or use the spring-boot-starter- test “Starter” to pull it in transitively.

If you have not used the spring-test module before, you should start by reading the relevant section of the Spring Framework reference documentation.


### 7.8.3. Testing Spring Boot Applications
A Spring Boot application is a Spring ApplicationContext, so nothing very special has to be done to test it beyond what you would normally do with a vanilla Spring context.

{: .note}
External properties, logging, and other features of Spring Boot are installed in the context by default only if you use SpringApplication to create it.

Spring Boot provides a @SpringBootTest annotation, which can be used as an alternative to the standard spring-test @ContextConfiguration annotation when you need Spring Boot features. The annotation works by creating the ApplicationContext used in your tests through SpringApplication. In addition to @SpringBootTest a number of other annotations are also provided for testing more specific slices of an application.

{: .note}
If you are using JUnit 4, do not forget to also add @RunWith(SpringRunner.class) to your test, otherwise the annotations will be ignored. If you are using JUnit 5, there is no need to add the equivalent @ExtendWith(SpringExtension.class) as @SpringBootTest and the other @...Test annotations are already annotated with it.

By default, @SpringBootTest will not start a server. You can use the webEnvironment attribute of @SpringBootTest to further refine how your tests run:

- MOCK(Default) : Loads a web ApplicationContext and provides a mock web environment. Embedded servers are not started when using this annotation. If a web environment is not available on your classpath, this mode transparently falls back to creating a regular non-web ApplicationContext. It can be used in conjunction with @AutoConfigureMockMvc or @AutoConfigureWebTestClient for mock-based testing of your web application.
- RANDOM_PORT: Loads a WebServerApplicationContext and provides a real web environment. Embedded servers are started and listen on a random port.
- DEFINED_PORT: Loads a WebServerApplicationContext and provides a real web environment. Embedded servers are started and listen on a defined port (from your application.properties) or on the default port of 8080.
- NONE: Loads an ApplicationContext by using SpringApplication but does not provide any web environment (mock or otherwise).

{: .note}
If your test is @Transactional, it rolls back the transaction at the end of each test method by default. However, as using this arrangement with either RANDOM_PORT or DEFINED_PORT implicitly provides a real servlet environment, the HTTP client and server run in separate threads and, thus, in separate transactions. Any transaction
initiated on the server does not roll back in this case.

{: .note}
@SpringBootTest with webEnvironment = WebEnvironment.RANDOM_PORT will also start the management server on a separate random port if your application uses a different port for the management server.


#### Detecting Web Application Type
If Spring MVC is available, a regular MVC-based application context is configured. If you have only Spring WebFlux, we will detect that and configure a WebFlux-based application context instead.

If both are present, Spring MVC takes precedence. If you want to test a reactive web application in this scenario, you must set the spring.main.web-application-type property:

`자바`
```java
    import org.springframework.boot.test.context.SpringBootTest;
  
    @SpringBootTest(properties = "spring.main.web-application-type=reactive")
    class MyWebFluxTests {
        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.context.SpringBootTest

    @SpringBootTest(properties = ["spring.main.web-application-type=reactive"])
    class MyWebFluxTests {
        // ... 
    }
```


#### Detecting Test Configuration
If you are familiar with the Spring Test Framework, you may be used to using @ContextConfiguration(classes=...) in order to specify which Spring @Configuration to load. Alternatively, you might have often used nested @Configuration classes within your test.

When testing Spring Boot applications, this is often not required. Spring Boot’s @*Test annotations search for your primary configuration automatically whenever you do not explicitly define one.

The search algorithm works up from the package that contains the test until it finds a class annotated with @SpringBootApplication or @SpringBootConfiguration. As long as you structured your code in a sensible way, your main configuration is usually found.

{: .note}
If you use a test annotation to test a more specific slice of your application, you should avoid adding configuration settings that are specific to a particular area on the main method’s application class.
The underlying component scan configuration of @SpringBootApplication defines exclude filters that are used to make sure slicing works as expected. If you are using an explicit @ComponentScan directive on your @SpringBootApplication-annotated class, be aware that those filters will be disabled. If you are using slicing, you should define them again.

If you want to customize the primary configuration, you can use a nested @TestConfiguration class. Unlike a nested @Configuration class, which would be used instead of your application’s primary configuration, a nested @TestConfiguration class is used in addition to your application’s primary configuration.

{: .note}
Spring’s test framework caches application contexts between tests. Therefore, as long as your tests share the same configuration (no matter how it is discovered), the potentially time-consuming process of loading the context happens only once.


####  Using the Test Configuration Main Method
Typically the test configuration discovered by @SpringBootTest will be your main @SpringBootApplication. In most well structured applications, this configuration class will also include the main method used to launch the application.

For example, the following is a very common code pattern for a typical Spring Boot application:

`자바`
```java
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
  
    @SpringBootApplication
    public class MyApplication {
        public static void main(String[] args) {
            SpringApplication.run(MyApplication.class, args);
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.boot.docs.using.structuringyourcode.locatingthemainclass.MyApplication
    import org.springframework.boot.runApplication
  
    @SpringBootApplication
    class MyApplication
    
    fun main(args: Array<String>) {
        runApplication<MyApplication>(*args)
    }
```

In the example above, the main method doesn’t do anything other than delegate to SpringApplication.run. It is, however, possible to have a more complex main method that applies customizations before calling SpringApplication.run.

For example, here is an application that changes the banner mode and sets additional profiles:

`자바`
```java
    import org.springframework.boot.Banner;
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class MyApplication {
        public static void main(String[] args) {
            SpringApplication application = new SpringApplication(MyApplication.class);
            application.setBannerMode(Banner.Mode.OFF);
            application.setAdditionalProfiles("myprofile");
            application.run(args);
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.Banner
    import org.springframework.boot.runApplication
    import org.springframework.boot.autoconfigure.SpringBootApplication

    @SpringBootApplication
    class MyApplication
    fun main(args: Array<String>) {
        runApplication<MyApplication>(*args) {
            setBannerMode(Banner.Mode.OFF)
            setAdditionalProfiles("myprofile");
        }
    }
```

Since customizations in the main method can affect the resulting ApplicationContext, it’s possible that you might also want to use the main method to create the ApplicationContext used in your tests. By default, @SpringBootTest will not call your main method, and instead the class itself is used directly to create the ApplicationContext

If you want to change this behavior, you can change the useMainMethod attribute of @SpringBootTest to UseMainMethod.ALWAYS or UseMainMethod.WHEN_AVAILABLE. When set to ALWAYS, the test will fail if no main method can be found. When set to WHEN_AVAILABLE the main method will be used if it is available, otherwise the standard loading mechanism will be used.

For example, the following test will invoke the main method of MyApplication in order to create the ApplicationContext. If the main method sets additional profiles then those will be active when the ApplicationContext starts.

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.boot.test.context.SpringBootTest.UseMainMethod;
  
    @SpringBootTest(useMainMethod = UseMainMethod.ALWAYS)
    class MyApplicationTests {
        @Test
        void exampleTest() {
            // ... 
        }
    }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.boot.test.context.SpringBootTest.UseMainMethod
    import org.springframework.context.annotation.Import

    @SpringBootTest(useMainMethod = UseMainMethod.ALWAYS)
    class MyApplicationTests {
        @Test
        fun exampleTest() {
            // ... 
        }
    }
```


#### Excluding Test Configuration
If your application uses component scanning (for example, if you use @SpringBootApplication or @ComponentScan), you may find top-level configuration classes that you created only for specific tests accidentally get picked up everywhere.

As we have seen earlier, @TestConfiguration can be used on an inner class of a test to customize the primary configuration. When placed on a top-level class, @TestConfiguration indicates that classes in src/test/java should not be picked up by scanning. You can then import that class explicitly where it is required, as shown in the following example:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.context.annotation.Import;

    @SpringBootTest
    @Import(MyTestsConfiguration.class)
    class MyTests {
        @Test
        void exampleTest() {
            // ... 
        }
    }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.context.annotation.Import

    @SpringBootTest
    @Import(MyTestsConfiguration::class)
    class MyTests {
        @Test
        fun exampleTest() {
            // ... 
        }
    }
```

{: .note}
If you directly use @ComponentScan (that is, not through @SpringBootApplication) you need to register the TypeExcludeFilter with it. See the Javadoc for details.


#### Using Application Arguments
If your application expects arguments, you can have @SpringBootTest inject them using the args attribute.
`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.ApplicationArguments;
    import org.springframework.boot.test.context.SpringBootTest;
    import static org.assertj.core.api.Assertions.assertThat;

    @SpringBootTest(args = "--app.test=one")
    class MyApplicationArgumentTests {
        @Test
        void applicationArgumentsPopulated(@Autowired ApplicationArguments args) {
            assertThat(args.getOptionNames()).containsOnly("app.test");
            assertThat(args.getOptionValues("app.test")).containsOnly("one");
        }
    }
```

`코틀린`
```kotlin
    import org.assertj.core.api.Assertions.assertThat
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.ApplicationArguments
    import org.springframework.boot.test.context.SpringBootTest

    @SpringBootTest(args = ["--app.test=one"])
    class MyApplicationArgumentTests {
        @Test
        fun applicationArgumentsPopulated(@Autowired args: ApplicationArguments) {
            assertThat(args.optionNames).containsOnly("app.test")
            assertThat(args.getOptionValues("app.test")).containsOnly("one")
        }
    }
```


####  Testing With a Mock Environment
By default, @SpringBootTest does not start the server but instead sets up a mock environment for testing web endpoints.

With Spring MVC, we can query our web endpoints using MockMvc or WebTestClient, as shown in the following example:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.test.web.reactive.server.WebTestClient;
    import org.springframework.test.web.servlet.MockMvc;
    import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
    import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
    import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
    
    @SpringBootTest
    @AutoConfigureMockMvc
    class MyMockMvcTests {
        @Test
        void testWithMockMvc(@Autowired MockMvc mvc) throws Exception {
            mvc.perform(get("/")).andExpect(status().isOk()).andExpect(content().string("Hello World"));
        }
        
        // If Spring WebFlux is on the classpath, you can drive MVC tests with a WebTestClient
        @Test
        void testWithWebTestClient(@Autowired WebTestClient webClient) {
            webClient
                .get().uri("/")
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class).isEqualTo("Hello World");
        } 
    }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.test.web.reactive.server.WebTestClient
    import org.springframework.test.web.reactive.server.expectBody
    import org.springframework.test.web.servlet.MockMvc
    import org.springframework.test.web.servlet.request.MockMvcRequestBuilders
    import org.springframework.test.web.servlet.result.MockMvcResultMatchers

    @SpringBootTest
    @AutoConfigureMockMvc
    class MyMockMvcTests {
        @Test
        fun testWithMockMvc(@Autowired mvc: MockMvc) {
            mvc.perform(MockMvcRequestBuilders.get("/")).andExpect(MockMvcResultMatchers.status().isOk)
                .andExpect(MockMvcResultMatchers.content().string("Hello World"))
        }
        // If Spring WebFlux is on the classpath, you can drive MVC tests with a WebTestClient
        
        @Test
        fun testWithWebTestClient(@Autowired webClient: WebTestClient) {
            webClient
                .get().uri("/")
                .exchange()
                .expectStatus().isOk
                .expectBody<String>().isEqualTo("Hello World")
        } 
    } 
```

{: .note}
If you want to focus only on the web layer and not start a complete ApplicationContext, consider using @WebMvcTest instead.

With Spring WebFlux endpoints, you can use WebTestClient as shown in the following example:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.test.web.reactive.server.WebTestClient;
    
    @SpringBootTest
    @AutoConfigureWebTestClient
    class MyMockWebTestClientTests {
        @Test
        void exampleTest(@Autowired WebTestClient webClient) {
            webClient
                .get().uri("/")
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class).isEqualTo("Hello World");
        } 
    }

```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.test.web.reactive.server.WebTestClient
    import org.springframework.test.web.reactive.server.expectBody

    @SpringBootTest
    @AutoConfigureWebTestClient
    class MyMockWebTestClientTests {
        @Test
        fun exampleTest(@Autowired webClient: WebTestClient) {
            webClient
                .get().uri("/")
                .exchange()
                .expectStatus().isOk
                .expectBody<String>().isEqualTo("Hello World")
        } 
    }
```

{: .note}
Testing within a mocked environment is usually faster than running with a full servlet container. However, since mocking occurs at the Spring MVC layer, code that relies on lower-level servlet container behavior cannot be directly tested with MockMvc.

{: .note}
For example, Spring Boot’s error handling is based on the “error page” support provided by the servlet container. This means that, whilst you can test your MVC layer throws and handles exceptions as expected, you cannot directly test that a specific custom error page is rendered. If you need to test these lower-level concerns, you can start a fully running server as described in the next section.


#### Testing With a Running Server
If you need to start a full running server, we recommend that you use random ports. If you use @SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT), an available port is picked at random each time your test runs.

The @LocalServerPort annotation can be used to inject the actual port used into your test. For convenience, tests that need to make REST calls to the started server can additionally @Autowire a WebTestClient, which resolves relative links to the running server and comes with a dedicated API for verifying responses, as shown in the following example:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
    import org.springframework.test.web.reactive.server.WebTestClient;

    @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
    class MyRandomPortWebTestClientTests {
        @Test
        void exampleTest(@Autowired WebTestClient webClient) {
            webClient
                .get().uri("/")
                .exchange()
                .expectStatus().isOk()
                .expectBody(String.class).isEqualTo("Hello World");
        } 
    }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.boot.test.context.SpringBootTest.WebEnvironment
    import org.springframework.test.web.reactive.server.WebTestClient
    import org.springframework.test.web.reactive.server.expectBody

    @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
    class MyRandomPortWebTestClientTests {
        @Test
        fun exampleTest(@Autowired webClient: WebTestClient) {
            webClient
                .get().uri("/")
                .exchange()
                .expectStatus().isOk
                .expectBody<String>().isEqualTo("Hello World")
        } 
    }
```

{: .note}
WebTestClient can be used against both live servers and mock environments.

This setup requires spring-webflux on the classpath. If you can not or will not add webflux, Spring Boot also provides a TestRestTemplate facility:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
    import org.springframework.boot.test.web.client.TestRestTemplate;
    import static org.assertj.core.api.Assertions.assertThat;

    @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
    class MyRandomPortTestRestTemplateTests {
        @Test
        void exampleTest(@Autowired TestRestTemplate restTemplate) {
            String body = restTemplate.getForObject("/", String.class);
            assertThat(body).isEqualTo("Hello World");
        }
    }
```

`코틀린`
```kotlin
    import org.assertj.core.api.Assertions.assertThat
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.boot.test.context.SpringBootTest.WebEnvironment
    import org.springframework.boot.test.web.client.TestRestTemplate

    @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
    class MyRandomPortTestRestTemplateTests {
        @Test
        fun exampleTest(@Autowired restTemplate: TestRestTemplate) {
            val body = restTemplate.getForObject("/", String::class.java)
            assertThat(body).isEqualTo("Hello World")
        }
    }
```


#### Customizing WebTestClient
To customize the WebTestClient bean, configure a WebTestClientBuilderCustomizer bean. Any such beans are called with the WebTestClient.Builder that is used to create the WebTestClient.


#### Using JMX
As the test context framework caches context, JMX is disabled by default to prevent identical components to register on the same domain. If such test needs access to an MBeanServer, consider marking it dirty as well:

`자바`
```java
    import javax.management.MBeanServer;
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.test.annotation.DirtiesContext;
    import static org.assertj.core.api.Assertions.assertThat;

    @SpringBootTest(properties = "spring.jmx.enabled=true")
    @DirtiesContext
    class MyJmxTests {
        @Autowired
        private MBeanServer mBeanServer;

        @Test
        void exampleTest() {
            assertThat(this.mBeanServer.getDomains()).contains("java.lang");
            // ... 
        }
    }
```

`코틀린`
```kotlin
    import javax.management.MBeanServer
    import org.assertj.core.api.Assertions.assertThat
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.test.annotation.DirtiesContext

    @SpringBootTest(properties = ["spring.jmx.enabled=true"])
    @DirtiesContext
    class MyJmxTests(@Autowired val mBeanServer: MBeanServer) {
        @Test
        fun exampleTest() {
            assertThat(mBeanServer.domains).contains("java.lang")
            // ... 
        }
    }
```


#### Using Metrics
Regardless of your classpath, meter registries, except the in-memory backed, are not auto- configured when using @SpringBootTest.

If you need to export metrics to a different backend as part of an integration test, annotate it with @AutoConfigureObservability.


#### Using Tracing
Regardless of your classpath, tracing is not auto-configured when using @SpringBootTest.

If you need tracing as part of an integration test, annotate it with @AutoConfigureObservability.


#### Mocking and Spying Beans
When running tests, it is sometimes necessary to mock certain components within your application context. For example, you may have a facade over some remote service that is unavailable during development. Mocking can also be useful when you want to simulate failures that might be hard to trigger in a real environment.

Spring Boot includes a @MockBean annotation that can be used to define a Mockito mock for a bean inside your ApplicationContext. You can use the annotation to add new beans or replace a single existing bean definition. The annotation can be used directly on test classes, on fields within your test, or on @Configuration classes and fields. When used on a field, the instance of the created mock is also injected. Mock beans are automatically reset after each test method.

{: .note}
If your test uses one of Spring Boot’s test annotations (such as @SpringBootTest), this feature is automatically enabled. To use this feature with a different arrangement, listeners must be explicitly added, as shown in the following example:

`자바`
```java
    import org.springframework.boot.test.mock.mockito.MockitoTestExecutionListener;
    import org.springframework.boot.test.mock.mockito.ResetMocksTestExecutionListener;
    import org.springframework.test.context.ContextConfiguration;
    import org.springframework.test.context.TestExecutionListeners;

    @ContextConfiguration(classes = MyConfig.class)
    @TestExecutionListeners({ MockitoTestExecutionListener.class,
    ResetMocksTestExecutionListener.class })
    class MyTests {
        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.mock.mockito.MockitoTestExecutionListener
    import org.springframework.boot.test.mock.mockito.ResetMocksTestExecutionListener
    import org.springframework.test.context.ContextConfiguration
    import org.springframework.test.context.TestExecutionListeners
              
    @ContextConfiguration(classes = [MyConfig::class])
    @TestExecutionListeners(
        MockitoTestExecutionListener::class,
        ResetMocksTestExecutionListener::class
    )
    class MyTests {
        // ...
    }
```

The following example replaces an existing RemoteService bean with a mock implementation:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.boot.test.mock.mockito.MockBean;
    import static org.assertj.core.api.Assertions.assertThat;
    import static org.mockito.BDDMockito.given;

    @SpringBootTest
    class MyTests {
        @Autowired
        private Reverser reverser;
        
        @MockBean
        private RemoteService remoteService;
    
        @Test
        void exampleTest() {
            given(this.remoteService.getValue()).willReturn("spring");
            String reverse = this.reverser.getReverseValue(); // Calls injected RemoteService
            assertThat(reverse).isEqualTo("gnirps");
        }
    }
```

`코틀린`
```kotlin
    import org.assertj.core.api.Assertions.assertThat
    import org.junit.jupiter.api.Test
    import org.mockito.BDDMockito.given
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.boot.test.mock.mockito.MockBean
    
    @SpringBootTest
    class MyTests(@Autowired val reverser: Reverser, @MockBean val remoteService: RemoteService) {
    
        @Test
        fun exampleTest() {
            given(remoteService.value).willReturn("spring")
            
            val reverse = reverser.reverseValue // Calls injected RemoteService
            assertThat(reverse).isEqualTo("gnirps")
        } 
    }
```

{: .note}
@MockBean cannot be used to mock the behavior of a bean that is exercised during application context refresh. By the time the test is executed, the application context refresh has completed and it is too late to configure the mocked behavior. We recommend using a @Bean method to create and configure the mock in this situation.

Additionally, you can use @SpyBean to wrap any existing bean with a Mockito spy. See the Javadoc for full details.

{: .note}
CGLib proxies, such as those created for scoped beans, declare the proxied methods as final. This stops Mockito from functioning correctly as it cannot mock or spy on final methods in its default configuration. If you want to mock or spy on such a bean, configure Mockito to use its inline mock maker by adding org.mockito:mockito-inline to your application’s test dependencies. This allows Mockito to mock and spy on final methods.


{: .note}
While Spring’s test framework caches application contexts between tests and reuses a context for tests sharing the same configuration, the use of @MockBean or @SpyBean influences the cache key, which will most likely increase the number of contexts.

{: .note}
If you are using @SpyBean to spy on a bean with @Cacheable methods that refer to parameters by name, your application must be compiled with -parameters. This ensures that the parameter names are available to the caching infrastructure once the bean has been spied upon.

{: .note}
When you are using @SpyBean to spy on a bean that is proxied by Spring, you may need to remove Spring’s proxy in some situations, for example when setting expectations using given or when. Use AopTestUtils.getTargetObject(yourProxiedSpy) to do so.


#### Auto-configured Tests
Spring Boot’s auto-configuration system works well for applications but can sometimes be a little too much for tests. It often helps to load only the parts of the configuration that are required to test a “slice” of your application. For example, you might want to test that Spring MVC controllers are mapping URLs correctly, and you do not want to involve database calls in those tests, or you might want to test JPA entities, and you are not interested in the web layer when those tests run.

The spring-boot-test-autoconfigure module includes a number of annotations that can be used to automatically configure such “slices”. Each of them works in a similar way, providing a @...Test annotation that loads the ApplicationContext and one or more @AutoConfigure... annotations that can be used to customize auto-configuration settings.

{: .note}
Each slice restricts component scan to appropriate components and loads a very restricted set of auto-configuration classes. If you need to exclude one of them, most @...Test annotations provide an excludeAutoConfiguration attribute. Alternatively, you can use @ImportAutoConfiguration#exclude.

{: .note}
Including multiple “slices” by using several @...Test annotations in one test is not supported. If you need multiple “slices”, pick one of the @...Test annotations and include the @AutoConfigure... annotations of the other “slices” by hand.

{: note}
It is also possible to use the @AutoConfigure... annotations with the standard @SpringBootTest annotation. You can use this combination if you are not interested in “slicing” your application but you want some of the auto-configured test beans.


#### Auto-configured JSON Tests
To test that object JSON serialization and deserialization is working as expected, you can use the @JsonTest annotation. @JsonTest auto-configures the available supported JSON mapper, which can be one of the following libraries:
- Jackson ObjectMapper, any @JsonComponent beans and any Jackson Modules 
- Gson
- Jsonb

{: .note}
A list of the auto-configurations that are enabled by @JsonTest can be found in the appendix.

If you need to configure elements of the auto-configuration, you can use the @AutoConfigureJsonTesters annotation.

Spring Boot includes AssertJ-based helpers that work with the JSONAssert and JsonPath libraries to check that JSON appears as expected. The JacksonTester, GsonTester, JsonbTester, and BasicJsonTester classes can be used for Jackson, Gson, Jsonb, and Strings respectively. Any helper fields on the test class can be @Autowired when using @JsonTest. The following example shows a test class for Jackson:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.json.JsonTest;
    import org.springframework.boot.test.json.JacksonTester;
    import static org.assertj.core.api.Assertions.assertThat;

    @JsonTest
    class MyJsonTests {
        @Autowired
        private JacksonTester<VehicleDetails> json;

        @Test
        void serialize() throws Exception {
            VehicleDetails details = new VehicleDetails("Honda", "Civic");
            // Assert against a `.json` file in the same package as the test
            assertThat(this.json.write(details)).isEqualToJson("expected.json");
            // Or use JSON path based assertions
            assertThat(this.json.write(details)).hasJsonPathStringValue("@.make");
            assertThat(this.json.write(details)).extractingJsonPathStringValue("@.make").isEqualTo("Honda");
        }
      
        @Test
        void deserialize() throws Exceptio  n {
            String content = "{\"make\":\"Ford\",\"model\":\"Focus\"}";
            assertThat(this.json.parse(content)).isEqualTo(new VehicleDetails("Ford", "Focus"));
            assertThat(this.json.parseObject(content).getMake()).isEqualTo("Ford");
        }
    }
```

`코틀린`
```kotlin
    import org.assertj.core.api.Assertions.assertThat
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.json.JsonTest
    import org.springframework.boot.test.json.JacksonTester

    @JsonTest
    class MyJsonTests(@Autowired val json: JacksonTester<VehicleDetails>) {
        @Test
        fun serialize() {
            val details = VehicleDetails("Honda", "Civic")
            // Assert against a `.json` file in the same package as the test
            assertThat(json.write(details)).isEqualToJson("expected.json")
            // Or use JSON path based assertions
            assertThat(json.write(details)).hasJsonPathStringValue("@.make")
            assertThat(json.write(details)).extractingJsonPathStringValue("@.make").isEqualTo("Honda")
        }
    
        @Test
        fun deserialize() {
            val content = "{\"make\":\"Ford\",\"model\":\"Focus\"}"
            assertThat(json.parse(content)).isEqualTo(VehicleDetails("Ford", "Focus"))
            assertThat(json.parseObject(content).make).isEqualTo("Ford")
        } 
    }
```

{: note}
JSON helper classes can also be used directly in standard unit tests. To do so, call the initFields method of the helper in your @Before method if you do not use @JsonTest.

If you use Spring Boot’s AssertJ-based helpers to assert on a number value at a given JSON path, you might not be able to use isEqualTo depending on the type. Instead, you can use AssertJ’s satisfies to assert that the value matches the given condition. For instance, the following example asserts that the actual number is a float value close to 0.15 within an offset of 0.01.

`자바`
```java
    @Test
    void someTest() throws Exception {
        SomeObject value = new SomeObject(0.152f);
        assertThat(this.json.write(value))
        .extractingJsonPathNumberValue("@.test.numberValue")
            .satisfies((number) -> 
                assertThat(number.floatValue()).isCloseTo(0.15f, within(0.01f))
            );
    }
```

`코틀린`
```kotlin
    @Test
    fun someTest() {
        val value = SomeObject(0.152f)
        assertThat(json.write(value))
        .extractingJsonPathNumberValue("@.test.numberValue")
            .satisfies(
                ThrowingConsumer { number -> 
                    assertThat(number.toFloat()).isCloseTo(0.15f, within(0.01f))
                }
            )
    }
```


#### Auto-configured Spring MVC Tests
To test whether Spring MVC controllers are working as expected, use the @WebMvcTest annotation. @WebMvcTest auto-configures the Spring MVC infrastructure and limits scanned beans to @Controller, @ControllerAdvice, @JsonComponent, Converter, GenericConverter, Filter, HandlerInterceptor, WebMvcConfigurer, WebMvcRegistrations, and HandlerMethodArgumentResolver. Regular @Component and @ConfigurationProperties beans are not scanned when the @WebMvcTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans.

{: .note}
A list of the auto-configuration settings that are enabled by @WebMvcTest can be found in the appendix.

{: .note}
If you need to register extra components, such as the Jackson Module, you can import additional configuration classes by using @Import on your test.

Often, @WebMvcTest is limited to a single controller and is used in combination with @MockBean to provide mock implementations for required collaborators.

@WebMvcTest also auto-configures MockMvc. Mock MVC offers a powerful way to quickly test MVC controllers without needing to start a full HTTP server.

{: .note}
You can also auto-configure MockMvc in a non-@WebMvcTest (such as @SpringBootTest) by annotating it with @AutoConfigureMockMvc. The following example uses MockMvc:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
    import org.springframework.boot.test.mock.mockito.MockBean;
    import org.springframework.http.MediaType;
    import org.springframework.test.web.servlet.MockMvc;
    import static org.mockito.BDDMockito.given;
    import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
    import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
    import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

    @WebMvcTest(UserVehicleController.class)
    class MyControllerTests {
        @Autowired
        private MockMvc mvc;
        
        @MockBean
        private UserVehicleService userVehicleService;
    
        @Test
        void testExample() throws Exception {
            given(this.userVehicleService.getVehicleDetails("sboot"))
                .willReturn(new VehicleDetails("Honda", "Civic"));
            this.mvc.perform(get("/sboot/vehicle").accept(MediaType.TEXT_PLAIN))
                .andExpect(status().isOk())
                .andExpect(content().string("Honda Civic"));
        } 
    }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.mockito.BDDMockito.given
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest
    import org.springframework.boot.test.mock.mockito.MockBean
    import org.springframework.http.MediaType
    import org.springframework.test.web.servlet.MockMvc
    import org.springframework.test.web.servlet.request.MockMvcRequestBuilders
    import org.springframework.test.web.servlet.result.MockMvcResultMatchers

    @WebMvcTest(UserVehicleController::class)
    class MyControllerTests(@Autowired val mvc: MockMvc) {
        @MockBean
        lateinit var userVehicleService: UserVehicleService
    
        @Test
        fun testExample() {
            given(userVehicleService.getVehicleDetails("sboot"))
                .willReturn(VehicleDetails("Honda", "Civic"))
            mvc.perform(MockMvcRequestBuilders.get("/sboot/vehicle").accept(MediaType.TEXT_PLAIN))
                .andExpect(MockMvcResultMatchers.status().isOk)
                .andExpect(MockMvcResultMatchers.content().string("Honda Civic"))
        } 
    }
```

{: .note}
If you need to configure elements of the auto-configuration (for example, when servlet filters should be applied) you can use attributes in the @AutoConfigureMockMvc annotation.

If you use HtmlUnit and Selenium, auto-configuration also provides an HtmlUnit WebClient bean and/or a Selenium WebDriver bean. The following example uses HtmlUnit:

`자바`
```java
    import com.gargoylesoftware.htmlunit.WebClient;
    import com.gargoylesoftware.htmlunit.html.HtmlPage;
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
    import org.springframework.boot.test.mock.mockito.MockBean;
    import static org.assertj.core.api.Assertions.assertThat;
    import static org.mockito.BDDMockito.given;

    @WebMvcTest(UserVehicleController.class)
    class MyHtmlUnitTests {
        @Autowired
        private WebClient webClient;
        
        @MockBean
        private UserVehicleService userVehicleService;
        
        @Test
        void testExample() throws Exception {
            given(this.userVehicleService.getVehicleDetails("sboot")).willReturn(new VehicleDetails("Honda", "Civic"));
            HtmlPage page = this.webClient.getPage("/sboot/vehicle.html");
            assertThat(page.getBody().getTextContent()).isEqualTo("Honda Civic");
        }
    }
```

`코틀린`
```kotlin
    import com.gargoylesoftware.htmlunit.WebClient
    import com.gargoylesoftware.htmlunit.html.HtmlPage
    import org.assertj.core.api.Assertions.assertThat
    import org.junit.jupiter.api.Test
    import org.mockito.BDDMockito.given
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest
    import org.springframework.boot.test.mock.mockito.MockBean

    @WebMvcTest(UserVehicleController::class)
    class MyHtmlUnitTests(@Autowired val webClient: WebClient) {
        @MockBean
        lateinit var userVehicleService: UserVehicleService

        @Test
        fun testExample() {
            given(userVehicleService.getVehicleDetails("sboot")).willReturn(VehicleDetails("Honda", "Civic"))
            val page = webClient.getPage<HtmlPage>("/sboot/vehicle.html")
            assertThat(page.body.textContent).isEqualTo("Honda Civic")
        }
    }
```

{: .note}
By default, Spring Boot puts WebDriver beans in a special “scope” to ensure that the driver exits after each test and that a new instance is injected. If you do not want this behavior, you can add @Scope("singleton") to your WebDriver @Bean definition.

{: .warning}
>The webDriver scope created by Spring Boot will replace any user defined scope of the same name. If you define your own webDriver scope you may find it stops
working when you use @WebMvcTest.

If you have Spring Security on the classpath, @WebMvcTest will also scan WebSecurityConfigurer beans. Instead of disabling security completely for such tests, you can use Spring Security’s test support. More details on how to use Spring Security’s MockMvc support can be found in this Testing With Spring Security how-to section.

{: .note}
Sometimes writing Spring MVC tests is not enough; Spring Boot can help you run full end-to-end tests with an actual server.


#### Auto-configured Spring WebFlux Tests
To test that Spring WebFlux controllers are working as expected, you can use the @WebFluxTest annotation. @WebFluxTest auto-configures the Spring WebFlux infrastructure and limits scanned beans to @Controller, @ControllerAdvice, @JsonComponent, Converter, GenericConverter, WebFilter, and WebFluxConfigurer. Regular @Component and @ConfigurationProperties beans are not scanned when the @WebFluxTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans.

{: .note}
A list of the auto-configurations that are enabled by @WebFluxTest can be found in the appendix.

{: .note}
If you need to register extra components, such as Jackson Module, you can import additional configuration classes using @Import on your test.

Often, @WebFluxTest is limited to a single controller and used in combination with the @MockBean annotation to provide mock implementations for required collaborators.

@WebFluxTest also auto-configures WebTestClient, which offers a powerful way to quickly test WebFlux controllers without needing to start a full HTTP server.

{: .note}
You can also auto-configure WebTestClient in a non-@WebFluxTest (such as @SpringBootTest) by annotating it with @AutoConfigureWebTestClient. The following
example shows a class that uses both @WebFluxTest and a WebTestClient:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
    import org.springframework.boot.test.mock.mockito.MockBean;
    import org.springframework.http.MediaType;
    import org.springframework.test.web.reactive.server.WebTestClient;
    import static org.mockito.BDDMockito.given;

    @WebFluxTest(UserVehicleController.class)
    class MyControllerTests {
        @Autowired
        private WebTestClient webClient;
        
        @MockBean
        private UserVehicleService userVehicleService;

        @Test
        void testExample() {
            given(this.userVehicleService.getVehicleDetails("sboot"))
                .willReturn(new VehicleDetails("Honda", "Civic"));
            this.webClient.get().uri("/sboot/vehicle").accept(MediaType.TEXT_PLAIN).exchange()
                .expectStatus().isOk()
                .expectBody(String.class).isEqualTo("Honda Civic");
        } 
    }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.mockito.BDDMockito.given
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest
    import org.springframework.boot.test.mock.mockito.MockBean
    import org.springframework.http.MediaType
    import org.springframework.test.web.reactive.server.WebTestClient
    import org.springframework.test.web.reactive.server.expectBody

    @WebFluxTest(UserVehicleController::class)
    class MyControllerTests(@Autowired val webClient: WebTestClient) {
        @MockBean
        lateinit var userVehicleService: UserVehicleService
        
        @Test
        fun testExample() {
            given(userVehicleService.getVehicleDetails("sboot"))
                .willReturn(VehicleDetails("Honda", "Civic"))
            webClient.get().uri("/sboot/vehicle").accept(MediaType.TEXT_PLAIN).exchange()
                .expectStatus().isOk
                .expectBody<String>().isEqualTo("Honda Civic")
        }
    }
```

{: .note}
This setup is only supported by WebFlux applications as using WebTestClient in a mocked web application only works with WebFlux at the moment.

{: .note}
@WebFluxTest cannot detect routes registered through the functional web framework. For testing RouterFunction beans in the context, consider importing
your RouterFunction yourself by using @Import or by using @SpringBootTest.

{: .note}
@WebFluxTest cannot detect custom security configuration registered as a @Bean of type SecurityWebFilterChain. To include that in your test, you will need to import the
configuration that registers the bean by using @Import or by using @SpringBootTest

{: .note}
Sometimes writing Spring WebFlux tests is not enough; Spring Boot can help you run full end-to-end tests with an actual server.


#### Auto-configured Spring GraphQL Tests
Spring GraphQL offers a dedicated testing support module; you’ll need to add it to your project:

`메이븐`
```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.graphql</groupId>
            <artifactId>spring-graphql-test</artifactId>
            <scope>test</scope>
        </dependency>
        <!-- Unless already present in the compile scope -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
```

`그레이들`
```groovy
    dependencies {
        testImplementation("org.springframework.graphql:spring-graphql-test")
        // Unless already present in the implementation configuration
        testImplementation("org.springframework.boot:spring-boot-starter-webflux")
    }
```

This testing module ships the GraphQlTester. The tester is heavily used in test, so be sure to become familiar with using it. There are GraphQlTester variants and Spring Boot will auto-configure them depending on the type of tests:

- the ExecutionGraphQlServiceTester performs tests on the server side, without a client nor a transport
- the HttpGraphQlTester performs tests with a client that connects to a server, with or without a live server

Spring Boot helps you to test your Spring GraphQL Controllers with the @GraphQlTest annotation. @GraphQlTest auto-configures the Spring GraphQL infrastructure, without any transport nor server being involved. This limits scanned beans to @Controller, RuntimeWiringConfigurer, JsonComponent, Converter, GenericConverter, DataFetcherExceptionResolver, Instrumentation and GraphQlSourceBuilderCustomizer. Regular @Component and @ConfigurationProperties beans are not scanned when the @GraphQlTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans.

{: .note}
A list of the auto-configurations that are enabled by @GraphQlTest can be found in the appendix.

Often, @GraphQlTest is limited to a set of controllers and used in combination with the @MockBean annotation to provide mock implementations for required collaborators.

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.docs.web.graphql.runtimewiring.GreetingController;
    import org.springframework.boot.test.autoconfigure.graphql.GraphQlTest;
    import org.springframework.graphql.test.tester.GraphQlTester;

    @GraphQlTest(GreetingController.class)
    class GreetingControllerTests {
        @Autowired
        private GraphQlTester graphQlTester;
        
        @Test
        void shouldGreetWithSpecificName() {
            this.graphQlTester.document("{ greeting(name: \"Alice\") } ")
                .execute()
                .path("greeting")
                .entity(String.class)
                .isEqualTo("Hello, Alice!");
        }

        @Test
        void shouldGreetWithDefaultName() {
            this.graphQlTester.document("{ greeting } ")
                .execute()
                .path("greeting")
                .entity(String.class)
                .isEqualTo("Hello, Spring!");
        } 
    }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.docs.web.graphql.runtimewiring.GreetingController
    import org.springframework.boot.test.autoconfigure.graphql.GraphQlTest
    import org.springframework.graphql.test.tester.GraphQlTester

    @GraphQlTest(GreetingController::class)
    internal class GreetingControllerTests {
        @Autowired
        lateinit var graphQlTester: GraphQlTester
      
        @Test
        fun shouldGreetWithSpecificName() {
            graphQlTester.document("{ greeting(name: \"Alice\") }")
                        .execute().path("greeting").entity(String::class.java)
                        .isEqualTo("Hello, Alice!")
        }

        @Test
        fun shouldGreetWithDefaultName() {
            graphQlTester.document("{ greeting }")
                        .execute().path("greeting").entity(String::class.java)
                        .isEqualTo("Hello, Spring!")
        }   
    }
```

@SpringBootTest tests are full integration tests and involve the entire application. When using a random or defined port, a live server is configured and an HttpGraphQlTester bean is contributed automatically so you can use it to test your server. When a MOCK environment is configured, you can also request an HttpGraphQlTester bean by annotating your test class with @AutoConfigureHttpGraphQlTester:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.graphql.tester.AutoConfigureHttpGraphQlTester;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.graphql.test.tester.HttpGraphQlTester;

    @AutoConfigureHttpGraphQlTester
    @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)
    class GraphQlIntegrationTests {
        @Test
        void shouldGreetWithSpecificName(@Autowired HttpGraphQlTester graphQlTester) {
            HttpGraphQlTester authenticatedTester = graphQlTester.mutate()
                .webTestClient((client) -> 
                    client.defaultHeaders((headers) ->
                        headers.setBasicAuth("admin", "ilovespring")
                    )
                ).build();

                authenticatedTester.document("{ greeting(name: \"Alice\") } ")
                                .execute()
                                .path("greeting")
                                .entity(String.class)
                                .isEqualTo("Hello, Alice!");
        } 
    }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.graphql.tester.AutoConfigureHttpGraphQlTester 
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.graphql.test.tester.HttpGraphQlTester
    import org.springframework.http.HttpHeaders
    import org.springframework.test.web.reactive.server.WebTestClient

    @AutoConfigureHttpGraphQlTester
    @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)
    class GraphQlIntegrationTests {
        @Test
        fun shouldGreetWithSpecificName(@Autowired graphQlTester: HttpGraphQlTester) {
            val authenticatedTester = graphQlTester.mutate()
                .webTestClient { client: WebTestClient.Builder ->
                    client.defaultHeaders { headers: HttpHeaders ->
                        headers.setBasicAuth("admin", "ilovespring")
                    } 
                }.build()
          
          authenticatedTester.document("{ greeting(name: \"Alice\") } ").execute()
              .path("greeting").entity(String::class.java).isEqualTo("Hello, Alice!")
        } 
    }
```


#### Auto-configured Data Cassandra Tests
You can use @DataCassandraTest to test Cassandra applications. By default, it configures a CassandraTemplate, scans for @Table classes, and configures Spring Data Cassandra repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataCassandraTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using Cassandra with Spring Boot, see " Cassandra".)


{: .note}
A list of the auto-configuration settings that are enabled by @DataCassandraTest can be found in the appendix.

The following example shows a typical setup for using Cassandra tests in Spring Boot:
`자바`
```java
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.data.cassandra.DataCassandraTest;
  
    @DataCassandraTest
    class MyDataCassandraTests {
        @Autowired
        private SomeRepository repository;
    }
```

`코틀린`
```kotlin
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.data.cassandra.DataCassandraTest

    @DataCassandraTest
    class MyDataCassandraTests(@Autowired val repository: SomeRepository)
```


#### Auto-configured Data Couchbase Tests
You can use @DataCouchbaseTest to test Couchbase applications. By default, it configures a CouchbaseTemplate or ReactiveCouchbaseTemplate, scans for @Document classes, and configures Spring Data Couchbase repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataCouchbaseTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using Couchbase with Spring Boot, see "Couchbase", earlier in this chapter.)


{: .note}
A list of the auto-configuration settings that are enabled by @DataCouchbaseTest can be found in the appendix.

The following example shows a typical setup for using Couchbase tests in Spring Boot:
`자바`
```java
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.data.couchbase.DataCouchbaseTest;
  
    @DataCouchbaseTest
    class MyDataCouchbaseTests {
        @Autowired
        private SomeRepository repository;
        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.data.couchbase.DataCouchbaseTest

    @DataCouchbaseTest
    class MyDataCouchbaseTests(@Autowired val repository: SomeRepository) {
        // ... 
    }
```


#### Auto-configured Data Elasticsearch Tests
You can use @DataElasticsearchTest to test Elasticsearch applications. By default, it configures an ElasticsearchRestTemplate, scans for @Document classes, and configures Spring Data Elasticsearch repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataElasticsearchTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using Elasticsearch with Spring Boot, see "Elasticsearch", earlier in this chapter.)

{: .note}
A list of the auto-configuration settings that are enabled by @DataElasticsearchTest can be found in the appendix.

The following example shows a typical setup for using Elasticsearch tests in Spring Boot:

`자바`
```java
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.data.elasticsearch.DataElasticsearchTest;
    
    @DataElasticsearchTest
    class MyDataElasticsearchTests {
        @Autowired
        private SomeRepository repository;
            // ... 
        }
```

`코틀린`
```kotlin
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.data.elasticsearch.DataElasticsearchTest
  
    @DataElasticsearchTest
    class MyDataElasticsearchTests(@Autowired val repository: SomeRepository) {
        // ... 
    }
```


#### Auto-configured Data JPA Tests
You can use the @DataJpaTest annotation to test JPA applications. By default, it scans for @Entity classes and configures Spring Data JPA repositories. If an embedded database is available on the classpath, it configures one as well. SQL queries are logged by default by setting the spring.jpa.show-sql property to true. This can be disabled using the showSql attribute of the annotation.

Regular @Component and @ConfigurationProperties beans are not scanned when the @DataJpaTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans.


{: .note}
A list of the auto-configuration settings that are enabled by @DataJpaTest can be found in the appendix.

By default, data JPA tests are transactional and roll back at the end of each test. See the relevant section in the Spring Framework Reference Documentation for more details. If that is not what you want, you can disable transaction management for a test or for the whole class as follows:

`자바`
```java
    import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
    import org.springframework.transaction.annotation.Propagation;
    import org.springframework.transaction.annotation.Transactional;
    @DataJpaTest
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    class MyNonTransactionalTests {
        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest
    import org.springframework.transaction.annotation.Propagation
    import org.springframework.transaction.annotation.Transactional

    @DataJpaTest
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    class MyNonTransactionalTests {
        // ... 
    }
```

Data JPA tests may also inject a TestEntityManager bean, which provides an alternative to the standard JPA EntityManager that is specifically designed for tests.

{: .note}
TestEntityManager can also be auto-configured to any of your Spring-based test class by adding @AutoConfigureTestEntityManager. When doing so, make sure that your test is running in a transaction, for instance by adding @Transactional on your test class or method.

A JdbcTemplate is also available if you need that. The following example shows the @DataJpaTest annotation in use:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
    import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;
    import static org.assertj.core.api.Assertions.assertThat;

    @DataJpaTest
    class MyRepositoryTests {
        @Autowired
        private TestEntityManager entityManager;

        @Autowired
        private UserRepository repository;

        @Test
        void testExample() {
            this.entityManager.persist(new User("sboot", "1234"));
            User user = this.repository.findByUsername("sboot");
            assertThat(user.getUsername()).isEqualTo("sboot");
            assertThat(user.getEmployeeNumber()).isEqualTo("1234");
        } 
    }
```

`코틀린`
```kotlin
    import org.assertj.core.api.Assertions.assertThat
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest
    import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager

    @DataJpaTest
    class MyRepositoryTests(@Autowired val entityManager: TestEntityManager, @Autowired val repository: UserRepository) {
        @Test
        fun testExample() {
            entityManager.persist(User("sboot", "1234"))
            val user = repository.findByUsername("sboot")
            assertThat(user?.username).isEqualTo("sboot")
            assertThat(user?.employeeNumber).isEqualTo("1234")
        } 
    }
```

In-memory embedded databases generally work well for tests, since they are fast and do not require any installation. If, however, you prefer to run tests against a real database you can use the @AutoConfigureTestDatabase annotation, as shown in the following example:

`자바`
```java
    import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase;
    import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase.Replace;
    import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
  
    @DataJpaTest
    @AutoConfigureTestDatabase(replace = Replace.NONE)
    class MyRepositoryTests {
        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.autoconfigure.jdbc.AutoConfigureTestDatabase
    import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest

    @DataJpaTest
    @AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
    class MyRepositoryTests {
        // ... 
    }
```


#### Auto-configured JDBC Tests
@JdbcTest is similar to @DataJpaTest but is for tests that only require a DataSource and do not use Spring Data JDBC. By default, it configures an in-memory embedded database and a JdbcTemplate. Regular @Component and @ConfigurationProperties beans are not scanned when the @JdbcTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans.

{: .note}
A list of the auto-configurations that are enabled by @JdbcTest can be found in the appendix.

By default, JDBC tests are transactional and roll back at the end of each test. See the relevant section in the Spring Framework Reference Documentation for more details. If that is not what you want, you can disable transaction management for a test or for the whole class, as follows:

`자바`
```java
    import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;
    import org.springframework.transaction.annotation.Propagation;
    import org.springframework.transaction.annotation.Transactional;

    @JdbcTest
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    class MyTransactionalTests { }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest
    import org.springframework.transaction.annotation.Propagation
    import org.springframework.transaction.annotation.Transactional
    
    @JdbcTest
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    class MyTransactionalTests
```

If you prefer your test to run against a real database, you can use the @AutoConfigureTestDatabase annotation in the same way as for DataJpaTest. (See "Auto-configured Data JPA Tests".)


#### Auto-configured Data JDBC Tests
@DataJdbcTest is similar to @JdbcTest but is for tests that use Spring Data JDBC repositories. By default, it configures an in-memory embedded database, a JdbcTemplate, and Spring Data JDBC repositories. Only AbstractJdbcConfiguration subclasses are scanned when the @DataJdbcTest annotation is used, regular @Component and @ConfigurationProperties beans are not scanned. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans.

{: .note}
A list of the auto-configurations that are enabled by @DataJdbcTest can be found in the appendix.

By default, Data JDBC tests are transactional and roll back at the end of each test. See the relevant section in the Spring Framework Reference Documentation for more details. If that is not what you want, you can disable transaction management for a test or for the whole test class as shown in the JDBC example.

If you prefer your test to run against a real database, you can use the @AutoConfigureTestDatabase annotation in the same way as for DataJpaTest. (See "Auto-configured Data JPA Tests".)


#### Auto-configured jOOQ Tests
You can use @JooqTest in a similar fashion as @JdbcTest but for jOOQ-related tests. As jOOQ relies heavily on a Java-based schema that corresponds with the database schema, the existing DataSource is used. If you want to replace it with an in-memory database, you can use @AutoConfigureTestDatabase to override those settings. (For more about using jOOQ with Spring Boot, see "Using jOOQ".) Regular @Component and @ConfigurationProperties beans are not scanned when the @JooqTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans.


{: .note}
A list of the auto-configurations that are enabled by @JooqTest can be found in the appendix.

@JooqTest configures a DSLContext. The following example shows the @JooqTest annotation in use:

`자바`
```java
    import org.jooq.DSLContext;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.jooq.JooqTest;
  
    @JooqTest
    class MyJooqTests {
        @Autowired
        private DSLContext dslContext;
        // ... 
    }
```

`코틀린`
```kotlin
    import org.jooq.DSLContext
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.jooq.JooqTest

    @JooqTest
    class MyJooqTests(@Autowired val dslContext: DSLContext) {
        // ... 
    }
```

JOOQ tests are transactional and roll back at the end of each test by default. If that is not what you want, you can disable transaction management for a test or for the whole test class as shown in the JDBC example.


#### Auto-configured Data MongoDB Tests
You can use @DataMongoTest to test MongoDB applications. By default, it configures a MongoTemplate, scans for @Document classes, and configures Spring Data MongoDB repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataMongoTest annotation is used.

@EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using MongoDB with Spring Boot, see "MongoDB".)

{: .note}
A list of the auto-configuration settings that are enabled by @DataMongoTest can be found in the appendix.

The following class shows the @DataMongoTest annotation in use:

`자바`
```java
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;
    import org.springframework.data.mongodb.core.MongoTemplate;

    @DataMongoTest
    class MyDataMongoDbTests {
        @Autowired
        private MongoTemplate mongoTemplate;
            // ... 
        }
```

`코틀린`
```kotlin
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest
    import org.springframework.data.mongodb.core.MongoTemplate

    @DataMongoTest
    class MyDataMongoDbTests(@Autowired val mongoTemplate: MongoTemplate) {
        // ... 
    }
```

#### Auto-configured Data Neo4j Tests
You can use @DataNeo4jTest to test Neo4j applications. By default, it scans for @Node classes, and configures Spring Data Neo4j repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataNeo4jTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using Neo4J with Spring Boot, see "Neo4j".)

{: .note}
A list of the auto-configuration settings that are enabled by @DataNeo4jTest can be found in the appendix.

The following example shows a typical setup for using Neo4J tests in Spring Boot:

`자바`
```java
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;
    
    @DataNeo4jTest
    class MyDataNeo4jTests {
        @Autowired
        private SomeRepository repository;
        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest

    @DataNeo4jTest
    class MyDataNeo4jTests(@Autowired val repository: SomeRepository) {
        // ... 
    }
```

By default, Data Neo4j tests are transactional and roll back at the end of each test. See the relevant section in the Spring Framework Reference Documentation for more details. If that is not what you want, you can disable transaction management for a test or for the whole class, as follows:

`자바`
```java
    import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;
    import org.springframework.transaction.annotation.Propagation;
    import org.springframework.transaction.annotation.Transactional;

    @DataNeo4jTest
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    class MyDataNeo4jTests { }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest
    import org.springframework.transaction.annotation.Propagation
    import org.springframework.transaction.annotation.Transactional
    
    @DataNeo4jTest
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    class MyDataNeo4jTests
```

{: .note}
Transactional tests are not supported with reactive access. If you are using this style, you must configure @DataNeo4jTest tests as described above.


#### Auto-configured Data Redis Tests
You can use @DataRedisTest to test Redis applications. By default, it scans for @RedisHash classes and configures Spring Data Redis repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataRedisTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using Redis with Spring Boot, see "Redis".)

{: .note}
A list of the auto-configuration settings that are enabled by @DataRedisTest can be found in the appendix.

The following example shows the @DataRedisTest annotation in use:

`자바`
```java
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;
    
    @DataRedisTest
    class MyDataRedisTests {
        @Autowired
        private SomeRepository repository;
            // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest

    @DataRedisTest
    class MyDataRedisTests(@Autowired val repository: SomeRepository) {
        // ... 
    }
```


#### Auto-configured Data LDAP Tests
You can use @DataLdapTest to test LDAP applications. By default, it configures an in-memory embedded LDAP (if available), configures an LdapTemplate, scans for @Entry classes, and configures Spring Data LDAP repositories. Regular @Component and @ConfigurationProperties beans are not scanned when the @DataLdapTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans. (For more about using LDAP with Spring Boot, see "LDAP".)


{: .note}
A list of the auto-configuration settings that are enabled by @DataLdapTest can be found in the appendix.

The following example shows the @DataLdapTest annotation in use:
`자바`
```java
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;
    import org.springframework.ldap.core.LdapTemplate;

    @DataLdapTest
    class MyDataLdapTests {
        @Autowired
        private LdapTemplate ldapTemplate;
            // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest
    import org.springframework.ldap.core.LdapTemplate

    @DataLdapTest
    class MyDataLdapTests(@Autowired val ldapTemplate: LdapTemplate) {
        // ... 
    }
```

In-memory embedded LDAP generally works well for tests, since it is fast and does not require any developer installation. If, however, you prefer to run tests against a real LDAP server, you should exclude the embedded LDAP auto-configuration, as shown in the following example:

`자바`
```java
    import org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration;
    import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;
    
    @DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)
    class MyDataLdapTests {
        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration
    import org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest
    @DataLdapTest(excludeAutoConfiguration = [EmbeddedLdapAutoConfiguration::class])
    class MyDataLdapTests {
        // ... 
    }
```


#### Auto-configured REST Clients
You can use the @RestClientTest annotation to test REST clients. By default, it auto-configures Jackson, GSON, and Jsonb support, configures a RestTemplateBuilder, and adds support for MockRestServiceServer. Regular @Component and @ConfigurationProperties beans are not scanned when the @RestClientTest annotation is used. @EnableConfigurationProperties can be used to include @ConfigurationProperties beans.

{: .note}
A list of the auto-configuration settings that are enabled by @RestClientTest can be found in the appendix.

The specific beans that you want to test should be specified by using the value or components attribute of @RestClientTest, as shown in the following example:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.web.client.RestClientTest;
    import org.springframework.http.MediaType;
    import org.springframework.test.web.client.MockRestServiceServer;
    import static org.assertj.core.api.Assertions.assertThat;
    import static org.springframework.test.web.client.match.MockRestRequestMatchers.requestTo;
    import static org.springframework.test.web.client.response.MockRestResponseCreators.withSuccess;
    
    @RestClientTest(RemoteVehicleDetailsService.class)
    class MyRestClientTests {
        @Autowired
        private RemoteVehicleDetailsService service;

        @Autowired
        private MockRestServiceServer server;

        @Test
        void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails() {
            this.server.expect(requestTo("/greet/details")).andRespond(withSuccess("hello", MediaType.TEXT_PLAIN));
            String greeting = this.service.callRestService();
            assertThat(greeting).isEqualTo("hello");
        }
    }
```

`코틀린`
```kotlin
    import org.assertj.core.api.Assertions.assertThat
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.web.client.RestClientTest
    import org.springframework.http.MediaType
    import org.springframework.test.web.client.MockRestServiceServer
    import org.springframework.test.web.client.match.MockRestRequestMatchers
    import org.springframework.test.web.client.response.MockRestResponseCreators
    
    @RestClientTest(RemoteVehicleDetailsService::class)
    class MyRestClientTests(
        @Autowired val service: RemoteVehicleDetailsService,
        @Autowired val server: MockRestServiceServer) {
        
        @Test
        fun getVehicleDetailsWhenResultIsSuccessShouldReturnDetails(): Unit {
            server.expect(MockRestRequestMatchers.requestTo("/greet/details"))
                .andRespond(MockRestResponseCreators.withSuccess("hello",MediaType.TEXT_PLAIN))
            val greeting = service.callRestService()
            assertThat(greeting).isEqualTo("hello")
        } 
    }
```


#### Auto-configured Spring REST Docs Tests
You can use the @AutoConfigureRestDocs annotation to use Spring REST Docs in your tests with Mock MVC, REST Assured, or WebTestClient. It removes the need for the JUnit extension in Spring REST Docs.

@AutoConfigureRestDocs can be used to override the default output directory (target/generated- snippets if you are using Maven or build/generated-snippets if you are using Gradle). It can also be used to configure the host, scheme, and port that appears in any documented URIs.


#### Auto-configured Spring REST Docs Tests With Mock MVC
@AutoConfigureRestDocs customizes the MockMvc bean to use Spring REST Docs when testing servlet- based web applications. You can inject it by using @Autowired and use it in your tests as you normally would when using Mock MVC and Spring REST Docs, as shown in the following example:
`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;
    import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
    import org.springframework.http.MediaType;
    import org.springframework.test.web.servlet.MockMvc;
    import static org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;
    import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
    import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
    
    @WebMvcTest(UserController.class)
    @AutoConfigureRestDocs
    class MyUserDocumentationTests {
        @Autowired
        private MockMvc mvc;
    
        @Test
        void listUsers() throws Exception {
            this.mvc.perform(get("/users").accept(MediaType.TEXT_PLAIN))
                .andExpect(status().isOk())
                .andDo(document("list-users"));
        } 
    }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs
    import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest
    import org.springframework.http.MediaType
    import org.springframework.restdocs.mockmvc.MockMvcRestDocumentation
    import org.springframework.test.web.servlet.MockMvc
    import org.springframework.test.web.servlet.request.MockMvcRequestBuilders
    import org.springframework.test.web.servlet.result.MockMvcResultMatchers

    @WebMvcTest(UserController::class)
    @AutoConfigureRestDocs
    class MyUserDocumentationTests(@Autowired val mvc: MockMvc) {
        @Test
        fun listUsers() {
            mvc.perform(MockMvcRequestBuilders.get("/users").accept(MediaType.TEXT_PLAIN))
                .andExpect(MockMvcResultMatchers.status().isOk)
                .andDo(MockMvcRestDocumentation.document("list-users"))
        } 
    }
```

If you require more control over Spring REST Docs configuration than offered by the attributes of @AutoConfigureRestDocs, you can use a RestDocsMockMvcConfigurationCustomizer bean, as shown in the following example:

`자바`
```java
    import org.springframework.boot.test.autoconfigure.restdocs.RestDocsMockMvcConfigurationCustomizer;
    import org.springframework.boot.test.context.TestConfiguration;
    import org.springframework.restdocs.mockmvc.MockMvcRestDocumentationConfigurer;
    import org.springframework.restdocs.templates.TemplateFormats;

    @TestConfiguration(proxyBeanMethods = false)
    public class MyRestDocsConfiguration implements RestDocsMockMvcConfigurationCustomizer {
        @Override
        public void customize(MockMvcRestDocumentationConfigurer configurer) {
            configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.autoconfigure.restdocs.RestDocsMockMvcConfigurationCustomizer
    import org.springframework.boot.test.context.TestConfiguration
    import org.springframework.restdocs.mockmvc.MockMvcRestDocumentationConfigurer
    import org.springframework.restdocs.templates.TemplateFormats

    @TestConfiguration(proxyBeanMethods = false)
    class MyRestDocsConfiguration : RestDocsMockMvcConfigurationCustomizer {
        override fun customize(configurer: MockMvcRestDocumentationConfigurer) {
            configurer.snippets().withTemplateFormat(TemplateFormats.markdown())
        } 
    }
```

If you want to make use of Spring REST Docs support for a parameterized output directory, you can create a RestDocumentationResultHandler bean. The auto-configuration calls alwaysDo with this result handler, thereby causing each MockMvc call to automatically generate the default snippets. The following example shows a RestDocumentationResultHandler being defined:

`자바`
```java
    import org.springframework.boot.test.context.TestConfiguration;
    import org.springframework.context.annotation.Bean;
    import org.springframework.restdocs.mockmvc.MockMvcRestDocumentation;
    import org.springframework.restdocs.mockmvc.RestDocumentationResultHandler;

    @TestConfiguration(proxyBeanMethods = false)
    public class MyResultHandlerConfiguration {
        @Bean
        public RestDocumentationResultHandler restDocumentation() {
            return MockMvcRestDocumentation.document("{method-name}");
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.context.TestConfiguration
    import org.springframework.context.annotation.Bean
    import org.springframework.restdocs.mockmvc.MockMvcRestDocumentation
    import org.springframework.restdocs.mockmvc.RestDocumentationResultHandler

    @TestConfiguration(proxyBeanMethods = false)
    class MyResultHandlerConfiguration {
        @Bean
        fun restDocumentation(): RestDocumentationResultHandler {
            return MockMvcRestDocumentation.document("{method-name}")
        }
    }
```


#### Auto-configured Spring REST Docs Tests With WebTestClient
@AutoConfigureRestDocs can also be used with WebTestClient when testing reactive web applications. You can inject it by using @Autowired and use it in your tests as you normally would when using @WebFluxTest and Spring REST Docs, as shown in the following example:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;
    import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;
    import org.springframework.test.web.reactive.server.WebTestClient;
    import static org.springframework.restdocs.webtestclient.WebTestClientRestDocumentation.document;
    
    @WebFluxTest
    @AutoConfigureRestDocs
    class MyUsersDocumentationTests {
        @Autowired
        private WebTestClient webTestClient;
        
        @Test
        void listUsers() {
            this.webTestClient.get().uri("/")
                .exchange()
                .expectStatus().isOk()
                .expectBody().consumeWith(document("list-users"));
        }
    }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs
    import org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest
    import org.springframework.restdocs.webtestclient.WebTestClientRestDocumentation
    import org.springframework.test.web.reactive.server.WebTestClient

    @WebFluxTest
    @AutoConfigureRestDocs
    class MyUsersDocumentationTests(@Autowired val webTestClient: WebTestClient) {
        @Test
        fun listUsers() {
            webTestClient.get().uri("/")
                .exchange()
                .expectStatus().isOk
                .expectBody()
                .consumeWith(WebTestClientRestDocumentation.document("list-users"))
        } 
    }
```

If you require more control over Spring REST Docs configuration than offered by the attributes of @AutoConfigureRestDocs, you can use a RestDocsWebTestClientConfigurationCustomizer bean, as shown in the following example:

`자바`
```java
    import org.springframework.boot.test.autoconfigure.restdocs.RestDocsWebTestClientConfigurationCustomizer;
    import org.springframework.boot.test.context.TestConfiguration;
    import org.springframework.restdocs.webtestclient.WebTestClientRestDocumentationConfigurer;
    
    @TestConfiguration(proxyBeanMethods = false)
    public class MyRestDocsConfiguration implements RestDocsWebTestClientConfigurationCustomizer {
        @Override
        public void customize(WebTestClientRestDocumentationConfigurer configurer) {
            configurer.snippets().withEncoding("UTF-8");
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.autoconfigure.restdocs.RestDocsWebTestClientConfigurationCustomizer
    import org.springframework.boot.test.context.TestConfiguration
    import org.springframework.restdocs.webtestclient.WebTestClientRestDocumentationConfigurer
    
    @TestConfiguration(proxyBeanMethods = false)
    class MyRestDocsConfiguration : RestDocsWebTestClientConfigurationCustomizer {
        override fun customize(configurer: WebTestClientRestDocumentationConfigurer) {
            configurer.snippets().withEncoding("UTF-8")
        } 
    }
```

If you want to make use of Spring REST Docs support for a parameterized output directory, you can use a WebTestClientBuilderCustomizer to configure a consumer for every entity exchange result. The following example shows such a WebTestClientBuilderCustomizer being defined:

`자바`
```java
    import org.springframework.boot.test.context.TestConfiguration;
    import org.springframework.boot.test.web.reactive.server.WebTestClientBuilderCustomizer;
    import org.springframework.context.annotation.Bean;
    import static org.springframework.restdocs.webtestclient.WebTestClientRestDocumentation.document;
    
    @TestConfiguration(proxyBeanMethods = false)
    public class MyWebTestClientBuilderCustomizerConfiguration {
        @Bean
        public WebTestClientBuilderCustomizer restDocumentation() {
            return (builder) -> builder.entityExchangeResultConsumer(document("{method-name}"));
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.context.TestConfiguration
    import org.springframework.boot.test.web.reactive.server.WebTestClientBuilderCustomizer
    import org.springframework.context.annotation.Bean
    import org.springframework.restdocs.webtestclient.WebTestClientRestDocumentation
    import org.springframework.test.web.reactive.server.WebTestClient
    
    @TestConfiguration(proxyBeanMethods = false)
    class MyWebTestClientBuilderCustomizerConfiguration {
        @Bean
        fun restDocumentation(): WebTestClientBuilderCustomizer {
            return WebTestClientBuilderCustomizer { builder: WebTestClient.Builder ->
                builder.entityExchangeResultConsumer(
                    WebTestClientRestDocumentation.document("{method-name}")
                )
            } 
        }
    }
```

#### Auto-configured Spring REST Docs Tests With REST Assured
@AutoConfigureRestDocs makes a RequestSpecification bean, preconfigured to use Spring REST Docs, available to your tests. You can inject it by using @Autowired and use it in your tests as you normally would when using REST Assured and Spring REST Docs, as shown in the following example:

`자바`
```java
    import io.restassured.specification.RequestSpecification;
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
    import org.springframework.boot.test.web.server.LocalServerPort;
    import static io.restassured.RestAssured.given;
    import static org.hamcrest.Matchers.is;
    import static org.springframework.restdocs.restassured.RestAssuredRestDocumentation.document;
    
    @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
    @AutoConfigureRestDocs
    class MyUserDocumentationTests {

        @Test
        void listUsers(@Autowired RequestSpecification documentationSpec, @LocalServerPort int port) {
            given(documentationSpec)
                .filter(document("list-users"))
            .when()
                .port(port)
                .get("/")
            .then().assertThat()
                .statusCode(is(200));
        } 
    }
```

`코틀린`
```kotlin
    import io.restassured.RestAssured
    import io.restassured.specification.RequestSpecification
    import org.hamcrest.Matchers
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.boot.test.context.SpringBootTest.WebEnvironment
    import org.springframework.boot.test.web.server.LocalServerPort
    import org.springframework.restdocs.restassured.RestAssuredRestDocumentation

    @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
    @AutoConfigureRestDocs
    class MyUserDocumentationTests {
    
        @Test
        fun listUsers(@Autowired documentationSpec: RequestSpecification?, @LocalServerPort port: Int) {
            RestAssured.given(documentationSpec)
                .filter(RestAssuredRestDocumentation.document("list-users"))
                .`when`()
                .port(port)["/"]
                .then().assertThat()
                .statusCode(Matchers.`is`(200))
        } 
    }
```

If you require more control over Spring REST Docs configuration than offered by the attributes of @AutoConfigureRestDocs, a RestDocsRestAssuredConfigurationCustomizer bean can be used, as shown in the following example:

`자바`
```java
    import org.springframework.boot.test.autoconfigure.restdocs.RestDocsRestAssuredConfigurationCustomizer;
    import org.springframework.boot.test.context.TestConfiguration;
    import org.springframework.restdocs.restassured.RestAssuredRestDocumentationConfigurer;
    import org.springframework.restdocs.templates.TemplateFormats;
    
    @TestConfiguration(proxyBeanMethods = false)
    public class MyRestDocsConfiguration implements RestDocsRestAssuredConfigurationCustomizer {
        @Override
        public void customize(RestAssuredRestDocumentationConfigurer configurer) {
            configurer.snippets().withTemplateFormat(TemplateFormats.markdown());
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.autoconfigure.restdocs.RestDocsRestAssuredConfigurationCustomizer
    import org.springframework.boot.test.context.TestConfiguration
    import org.springframework.restdocs.restassured.RestAssuredRestDocumentationConfigurer
    import org.springframework.restdocs.templates.TemplateFormats
    
    @TestConfiguration(proxyBeanMethods = false)
    class MyRestDocsConfiguration : RestDocsRestAssuredConfigurationCustomizer {
        override fun customize(configurer: RestAssuredRestDocumentationConfigurer) {
            configurer.snippets().withTemplateFormat(TemplateFormats.markdown())
        } 
    }
```


#### Auto-configured Spring Web Services Tests


##### Auto-configured Spring Web Services Client Tests
You can use @WebServiceClientTest to test applications that call web services using the Spring Web Services project. By default, it configures a mock WebServiceServer bean and automatically customizes your WebServiceTemplateBuilder. (For more about using Web Services with Spring Boot, see "Web Services".)

{: .note}
A list of the auto-configuration settings that are enabled by @WebServiceClientTest can be found in the appendix.

The following example shows the @WebServiceClientTest annotation in use:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.webservices.client.WebServiceClientTest;
    import org.springframework.ws.test.client.MockWebServiceServer;
    import org.springframework.xml.transform.StringSource;
    import static org.assertj.core.api.Assertions.assertThat;
    import static org.springframework.ws.test.client.RequestMatchers.payload;
    import static org.springframework.ws.test.client.ResponseCreators.withPayload;

    @WebServiceClientTest(SomeWebService.class)
    class MyWebServiceClientTests {
        @Autowired
        private MockWebServiceServer server;

        @Autowired
        private SomeWebService someWebService;

        @Test
        void mockServerCall() {
            this.server
                .expect(payload(new StringSource("<request/>")))
                .andRespond(withPayload(new StringSource("<response><status>200</status></response>")));
            
            assertThat(this.someWebService.test())
            .extracting(Response::getStatus)
            .isEqualTo(200);
        } 
    }
```

`코틀린`
```kotlin
    import org.assertj.core.api.Assertions.assertThat
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.webservices.client.WebServiceClientTest
    import org.springframework.ws.test.client.MockWebServiceServer
    import org.springframework.ws.test.client.RequestMatchers
    import org.springframework.ws.test.client.ResponseCreators
    import org.springframework.xml.transform.StringSource

    @WebServiceClientTest(SomeWebService::class)
    class MyWebServiceClientTests(@Autowired val server: MockWebServiceServer, @Autowired
        val someWebService: SomeWebService) {
        
        @Test
        fun mockServerCall() {
            server
                .expect(RequestMatchers.payload(StringSource("<request/>")))
                .andRespond(ResponseCreators.withPayload(StringSource("<response><status>200</status></response>")))
            assertThat(this.someWebService.test()).extracting(Response::status).isEqualTo(200)
        }
}
```


##### Auto-configured Spring Web Services Server Tests
You can use @WebServiceServerTest to test applications that implement web services using the Spring Web Services project. By default, it configures a MockWebServiceClient bean that can be used to call your web service endpoints. (For more about using Web Services with Spring Boot, see "Web Services".)

{: .note}
A list of the auto-configuration settings that are enabled by @WebServiceServerTest can be found in the appendix.

The following example shows the @WebServiceServerTest annotation in use:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.autoconfigure.webservices.server.WebServiceServerTest;
    import org.springframework.ws.test.server.MockWebServiceClient;
    import org.springframework.ws.test.server.RequestCreators;
    import org.springframework.ws.test.server.ResponseMatchers;
    import org.springframework.xml.transform.StringSource;

    @WebServiceServerTest(ExampleEndpoint.class)
    class MyWebServiceServerTests {
        @Autowired
        private MockWebServiceClient client;

        @Test
        void mockServerCall() {
            this.client
                .sendRequest(RequestCreators.withPayload(newStringSource("<ExampleRequest/>")))
                .andExpect(ResponseMatchers.payload(new StringSource("<ExampleResponse>42</ExampleResponse>")));
        }
    }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.autoconfigure.webservices.server.WebServiceServerTest
    import org.springframework.ws.test.server.MockWebServiceClient
    import org.springframework.ws.test.server.RequestCreators
    import org.springframework.ws.test.server.ResponseMatchers
    import org.springframework.xml.transform.StringSource

    @WebServiceServerTest(ExampleEndpoint::class)
    class MyWebServiceServerTests(@Autowired val client: MockWebServiceClient) {
        @Test
        fun mockServerCall() {  
            client
                .sendRequest(RequestCreators.withPayload(StringSource("<ExampleRequest/>")))
                .andExpect(ResponseMatchers.payload(StringSource("<ExampleResponse>42</ExampleResponse>")))
        } 
    }
```

##### Additional Auto-configuration and Slicing
Each slice provides one or more @AutoConfigure... annotations that namely defines the auto- configurations that should be included as part of a slice. Additional auto-configurations can be added on a test-by-test basis by creating a custom @AutoConfigure... annotation or by adding @ImportAutoConfiguration to the test as shown in the following example:
`자바`
```java
    import org.springframework.boot.autoconfigure.ImportAutoConfiguration;
    import org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration;
    import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;
    
    @JdbcTest
    @ImportAutoConfiguration(IntegrationAutoConfiguration.class)
    class MyJdbcTests { }
```

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.ImportAutoConfiguration
    import org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration
    import org.springframework.boot.test.autoconfigure.jdbc.JdbcTest

    @JdbcTest
    @ImportAutoConfiguration(IntegrationAutoConfiguration::class)
    class MyJdbcTests
```

{: .note}
Make sure to not use the regular @Import annotation to import auto-configurations as they are handled in a specific way by Spring Boot.

Alternatively, additional auto-configurations can be added for any use of a slice annotation by registering them in a file stored in META-INF/spring as shown in the following example:

*META-INF/spring/org.springframework.boot.test.autoconfigure.jdbc.JdbcTest.imports*
```
    com.example.IntegrationAutoConfiguration
```

In this example, the com.example.IntegrationAutoConfiguration is enabled on every test annotated with @JdbcTest.

{: .note}
You can use comments with # in this file.

{: .note}
A slice or @AutoConfigure... annotation can be customized this way as long as it is meta- annotated with @ImportAutoConfiguration.


#### User Configuration and Slicing
If you structure your code in a sensible way, your @SpringBootApplication class is used by default as the configuration of your tests.

It then becomes important not to litter the application’s main class with configuration settings that are specific to a particular area of its functionality.

Assume that you are using Spring Data MongoDB, you rely on the auto-configuration for it, and you have enabled auditing. You could define your @SpringBootApplication as follows:

`자바`
```java
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.data.mongodb.config.EnableMongoAuditing;
  
    @SpringBootApplication
    @EnableMongoAuditing
    public class MyApplication {
        // ... 
    }

```

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.data.mongodb.config.EnableMongoAuditing
    
    @SpringBootApplication
    @EnableMongoAuditing
    class MyApplication {
        // ... 
    }
```

Because this class is the source configuration for the test, any slice test actually tries to enable Mongo auditing, which is definitely not what you want to do. A recommended approach is to move that area-specific configuration to a separate @Configuration class at the same level as your application, as shown in the following example:

`자바`
```java
    import org.springframework.context.annotation.Configuration;
    import org.springframework.data.mongodb.config.EnableMongoAuditing;
    
    @Configuration(proxyBeanMethods = false)
    @EnableMongoAuditing
    public class MyMongoConfiguration {
        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.context.annotation.Configuration
    import org.springframework.data.mongodb.config.EnableMongoAuditing;
    
    @Configuration(proxyBeanMethods = false)
    @EnableMongoAuditing
    class MyMongoConfiguration {
        // ... 
    }
```

{: .note}
Depending on the complexity of your application, you may either have a single @Configuration class for your customizations or one class per domain area. The latter approach lets you enable it in one of your tests, if necessary, with the @Import annotation. See this how-to section for more details on when you might want to enable specific @Configuration classes for slice tests

Test slices exclude @Configuration classes from scanning. For example, for a @WebMvcTest, the following configuration will not include the given WebMvcConfigurer bean in the application context loaded by the test slice:

`자바`
```java
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

    @Configuration(proxyBeanMethods = false)
    public class MyWebConfiguration {
        @Bean
        public WebMvcConfigurer testConfigurer() {
            return new WebMvcConfigurer() {
                // ...
            };
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.context.annotation.Bean
    import org.springframework.context.annotation.Configuration
    import org.springframework.web.servlet.config.annotation.WebMvcConfigurer

    @Configuration(proxyBeanMethods = false)
    class MyWebConfiguration {
        @Bean
        fun testConfigurer(): WebMvcConfigurer {
            return object : WebMvcConfigurer {
                // ...
            } 
        }
    }
```

The configuration below will, however, cause the custom WebMvcConfigurer to be loaded by the test slice.

`자바`
```java
    import org.springframework.stereotype.Component;
    import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
  
    @Component
    public class MyWebMvcConfigurer implements WebMvcConfigurer {
        // ... 
    }

```

`코틀린`
```kotlin
    import org.springframework.stereotype.Component
    import org.springframework.web.servlet.config.annotation.WebMvcConfigurer
  
    @Component
    class MyWebMvcConfigurer : WebMvcConfigurer {
        // ... 
    }
```

Another source of confusion is classpath scanning. Assume that, while you structured your code in a sensible way, you need to scan an additional package. Your application may resemble the following code:

`자바`
```java
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.context.annotation.ComponentScan;
    
    @SpringBootApplication
    @ComponentScan({ "com.example.app", "com.example.another" })
    public class MyApplication {
        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.context.annotation.ComponentScan

    @SpringBootApplication
    @ComponentScan("com.example.app", "com.example.another")
    class MyApplication {
        // ... 
    }
```

Doing so effectively overrides the default component scan directive with the side effect of scanning those two packages regardless of the slice that you chose. For instance, a @DataJpaTest seems to suddenly scan components and user configurations of your application. Again, moving the custom directive to a separate class is a good way to fix this issue.

{: .note}
If this is not an option for you, you can create a @SpringBootConfiguration somewhere in the hierarchy of your test so that it is used instead. Alternatively, you can specify a
source for your test, which disables the behavior of finding a default one.


#### Using Spock to Test Spring Boot Applications
Spock 2.2 or later can be used to test a Spring Boot application. To do so, add a dependency on a -groovy-4.0 version of Spock’s spock-spring module to your application’s build. spock-spring integrates Spring’s test framework into Spock. See the documentation for Spock’s Spring module for further details.


### 7.8.4. Testcontainers
The Testcontainers library provides a way to manage services running inside Docker containers. It integrates with JUnit, allowing you to write a test class that can start up a container before any of the tests run. Testcontainers is especially useful for writing integration tests that talk to a real backend service such as MySQL, MongoDB, Cassandra and others.

Testcontainers can be used in a Spring Boot test as follows:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.testcontainers.containers.Neo4jContainer;
    import org.testcontainers.junit.jupiter.Container;
    import org.testcontainers.junit.jupiter.Testcontainers;
    import org.springframework.boot.test.context.SpringBootTest;

    @Testcontainers
    @SpringBootTest

    class MyIntegrationTests {
        @Container
        static Neo4jContainer<?> neo4j = new Neo4jContainer<>("neo4j:5");
      
        @Test
        void myTest() {
            // ... 
        }
    }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.boot.test.context.SpringBootTest
    import org.testcontainers.containers.Neo4jContainer
    import org.testcontainers.junit.jupiter.Container
    import org.testcontainers.junit.jupiter.Testcontainers

    @Testcontainers
    @SpringBootTest
    class MyIntegrationTests {
        @Test
        fun myTest() {
            // ... 
        }
        
        companion object {
            @Container
            val neo4j = Neo4jContainer("neo4j:5")
        }
    }
```

This will start up a docker container running Neo4j (if Docker is running locally) before any of the tests are run. In most cases, you will need to configure the application to connect to the service running in the container.


#### Service Connections
A service connection is a connection to any remote service. Spring Boot’s auto-configuration can consume the details of a service connection and use them to establish a connection to a remote service. When doing so, the connection details take precedence over any connection-related configuration properties.

When using Testcontainers, connection details can be automatically created for a service running in a container by annotating the container field in the test class.

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.testcontainers.containers.Neo4jContainer;
    import org.testcontainers.junit.jupiter.Container;
    import org.testcontainers.junit.jupiter.Testcontainers;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.boot.testcontainers.service.connection.ServiceConnection;

    @Testcontainers
    @SpringBootTest
    class MyIntegrationTests {
        @Container
        @ServiceConnection
        static Neo4jContainer<?> neo4j = new Neo4jContainer<>("neo4j:5");
      
        @Test
        void myTest() {
            // ... 
        }
}
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.boot.testcontainers.service.connection.ServiceConnection
    import org.testcontainers.containers.Neo4jContainer
    import org.testcontainers.junit.jupiter.Container
    import org.testcontainers.junit.jupiter.Testcontainers

    @Testcontainers
    @SpringBootTest
    class MyIntegrationTests {
        @Test
        fun myTest() {
            // ... 
        }
        
        companion object {
            @Container
            @ServiceConnection
            val neo4j = Neo4jContainer("neo4j:5")
        } 
    }
```

Thanks to @ServiceConnection, the above configuration allows Neo4j-related beans in the application to communicate with Neo4j running inside the Testcontainers-managed Docker container. This is done by automatically defining a Neo4jConnectionDetails bean which is then used by the Neo4j auto-configuration, overriding any connection-related configuration properties.

{: .note}
You’ll need to add the spring-boot-testcontainers module as a test dependency in order to use service connections with Testcontainers.

Service connection annotations are processed by ContainerConnectionDetailsFactory classes registered with spring.factories. A ContainerConnectionDetailsFactory can create a ConnectionDetails bean based on a specific Container subclass, or the Docker image name.

The following service connection factories are provided in the spring-boot-testcontainers jar:

|Connection Details|Matched on|
|---|---|
|CassandraConnectionDetails|Containers of type CassandraContainer|
|CouchbaseConnectionDetails|Containers of type CouchbaseContainer|
|ElasticsearchConnectionDetails|Containers of type ElasticsearchContainer|
|FlywayConnectionDetails|Containers of type JdbcDatabaseContainer|
|JdbcConnectionDetails|Containers of type JdbcDatabaseContainer|
|KafkaConnectionDetails|Containers of type KafkaContainer or RedpandaContainer|
|LiquibaseConnectionDetails|Containers of type JdbcDatabaseContainer|
|MongoConnectionDetails|Containers of type MongoDBContainer|
|Neo4jConnectionDetails|Containers of type Neo4jContainer|
|R2dbcConnectionDetails|Containers of type MariaDBContainer, MSSQLServerContainer, MySQLContainer, OracleContainer, or PostgreSQLContainer|
|RabbitConnectionDetails|Containers of type RabbitMQContainer|
|RedisConnectionDetails|Containers named "redis"|
|ZipkinConnectionDetails|Containers named "openzipkin/zipkin"|

{: .note}
By default all applicable connection details beans will be created for a given Container. For example, a PostgreSQLContainer will create both JdbcConnectionDetails and R2dbcConnectionDetails.

{: .note}
If you want to create only a subset of the applicable types, you can use the type attribute of @ServiceConnection.

By default Container.getDockerImageName() is used to obtain the name used to find connection details. If you are using a custom docker image, you can use the name attribute of @ServiceConnection to override it.

For example, if you have a GenericContainer using a Docker image of registry.mycompany.com/mirror/myredis, you’d use @ServiceConnection(name="redis") to ensure RedisConnectionDetails are created.


#### Dynamic Properties
A slightly more verbose but also more flexible alternative to service connections is @DynamicPropertySource. A static @DynamicPropertySource method allows adding dynamic property values to the Spring Environment.

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.testcontainers.containers.Neo4jContainer;
    import org.testcontainers.junit.jupiter.Container;
    import org.testcontainers.junit.jupiter.Testcontainers;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.test.context.DynamicPropertyRegistry;
    import org.springframework.test.context.DynamicPropertySource;

    @Testcontainers
    @SpringBootTest
    class MyIntegrationTests {
        @Container
        static Neo4jContainer<?> neo4j = new Neo4jContainer<>("neo4j:5");
        
        @Test
        void myTest() {
            // ... 
        }
        
        @DynamicPropertySource
        static void neo4jProperties(DynamicPropertyRegistry registry) {
            registry.add("spring.neo4j.uri", neo4j::getBoltUrl);
        }
    }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.test.context.DynamicPropertyRegistry
    import org.springframework.test.context.DynamicPropertySource
    import org.testcontainers.containers.Neo4jContainer
    import org.testcontainers.junit.jupiter.Container
    import org.testcontainers.junit.jupiter.Testcontainers

    @Testcontainers
    @SpringBootTest
    class MyIntegrationTests {
        @Test
        fun myTest() {
            // ... 
        }
        companion object {
            @Container
            val neo4j = Neo4jContainer("neo4j:5")

            @DynamicPropertySource
            fun neo4jProperties(registry: DynamicPropertyRegistry) {
                registry.add("spring.neo4j.uri") { neo4j.boltUrl }
            }
        } 
    }
```

The above configuration allows Neo4j-related beans in the application to communicate with Neo4j running inside the Testcontainers-managed Docker container.


#### Using Testcontainers at Development Time
As well as using Testcontainers for integration testing, it’s also possible to use them at development time. This approach allows developers to quickly start containers for the services that the application depends on, removing the need to manually provision things like database servers. Using Testcontainers in this way provides functionality similar to Docker Compose, except that your container configuration is in Java rather than YAML.

To use Testcontainers at development time you need to launch your application using your “test” classpath rather than “main”. This will allow you to access all declared test dependencies and give you a natural place to write your test configuration.

To create a test launchable version of your application you should create an “Application” class in the src/test directory. For example, if your main application is in src/main/java/com/example/MyApplication.java, you should create src/test/java/com/example/TestMyApplication.java

The TestMyApplication class can use the SpringApplication.from(...) method to launch the real application:

`자바`
```java
  import org.springframework.boot.SpringApplication;

    public class TestMyApplication {
        public static void main(String[] args) {
            SpringApplication.from(MyApplication::main).run(args);
        } 
    }

```

`코틀린`
```kotlin
    import org.springframework.boot.fromApplication
  
    fun main(args: Array<String>) {
        fromApplication<MyApplication>().run(*args)
    }
```

You’ll also need to define the Container instances that you want to start along with your application. To do this, you need to make sure that the spring-boot-testcontainers module has been added as a test dependency. Once that has been done, you can create a @TestConfiguration class that declares @Bean methods for the containers you want to start.

You can also annotate your @Bean methods with @ServiceConnection in order to create ConnectionDetails beans. See the service connections section above for details of the supported technologies.

A typical Testcontainers configuration would look like this:

`자바`
```java
    import org.testcontainers.containers.Neo4jContainer;
    import org.springframework.boot.test.context.TestConfiguration;
    import org.springframework.boot.testcontainers.service.connection.ServiceConnection;
    import org.springframework.context.annotation.Bean;

    @TestConfiguration(proxyBeanMethods = false)
    public class MyContainersConfiguration {
        @Bean
        @ServiceConnection
        public Neo4jContainer<?> neo4jContainer() {
            return new Neo4jContainer<>("neo4j:5");
        }
    }
```

`코틀린`
```kotlin
    import org.testcontainers.containers.Neo4jContainer
    import org.springframework.boot.test.context.TestConfiguration
    import org.springframework.boot.testcontainers.service.connection.ServiceConnection
    import org.springframework.context.annotation.Bean;

    @TestConfiguration(proxyBeanMethods = false)
    class MyContainersConfiguration {
        @Bean
        @ServiceConnection
        fun neo4jContainer(): Neo4jContainer<*> {
            return Neo4jContainer("neo4j:5")
        }
    }
```

{: .note}
The lifecycle of Container beans is automatically managed by Spring Boot. Containers will be started and stopped automatically.

Once you have defined your test configuration, you can use the with(...) method to attach it to your test launcher:

`자바`
```java
    import org.springframework.boot.SpringApplication;
    public class TestMyApplication {
        public static void main(String[] args) {
            SpringApplication.from(MyApplication::main).with(MyContainersConfiguration.class).run(args);
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.fromApplication
    import org.springframework.boot.with

    fun main(args: Array<String>) {
        fromApplication<MyApplication>().with(MyContainersConfiguration::class).run(*args)
    }
```

You can now launch TestMyApplication as you would any regular Java main method application to start your application and the containers that it needs to run.

{: .note}
You can use the Maven goal spring-boot:test-run or the Gradle task bootTestRun to do this from the command line.


#### Contributing Dynamic Properties at Development Time
If you want to contribute dynamic properties at development time from your Container @Bean methods, you can do so by injecting a DynamicPropertyRegistry. This works in a similar way to the @DynamicPropertySource annotation that you can use in your tests. It allows you to add properties that will become available once your container has started.

A typical configuration would look like this:
`자바`
```java
    import org.testcontainers.containers.MongoDBContainer;
    import org.springframework.boot.test.context.TestConfiguration;
    import org.springframework.context.annotation.Bean;
    import org.springframework.test.context.DynamicPropertyRegistry;

    @TestConfiguration(proxyBeanMethods = false)
    public class MyContainersConfiguration {
        @Bean
        public MongoDBContainer monogDbContainer(DynamicPropertyRegistry properties) {
            MongoDBContainer container = new MongoDBContainer("mongo:5.0");
            properties.add("spring.data.mongodb.host", container::getHost);
            properties.add("spring.data.mongodb.port", container::getFirstMappedPort);
            return container;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.context.TestConfiguration
    import org.springframework.context.annotation.Bean;
    import org.springframework.test.context.DynamicPropertyRegistry
    import org.testcontainers.containers.MongoDBContainer

    @TestConfiguration(proxyBeanMethods = false)
    class MyContainersConfiguration {
        @Bean
        fun monogDbContainer(properties: DynamicPropertyRegistry): MongoDBContainer {
            var container = MongoDBContainer("mongo:5.0")
            properties.add("spring.data.mongodb.host", container::getHost);
            properties.add("spring.data.mongodb.port", container::getFirstMappedPort);
            return container
        } 
    }
```

{: .note}
Using a @ServiceConnection is recommended whenever possible, however, dynamic properties can be a useful fallback for technologies that don’t yet have @ServiceConnection support.


#### Importing Testcontainer Declaration Classes
A common pattern when using Testcontainers is to declare Container instances as static fields. Often these fields are defined directly on the test class. They can also be declared on a parent class or on an interface that the test implements.

For example, the following MyContainers interface declares mongo and neo4j containers:

```java
    import org.testcontainers.containers.MongoDBContainer;
    import org.testcontainers.containers.Neo4jContainer;
    import org.testcontainers.junit.jupiter.Container;
    
    public interface MyContainers {
        @Container
        MongoDBContainer mongoContainer = new MongoDBContainer("mongo:5.0");

        @Container
        Neo4jContainer<?> neo4jContainer = new Neo4jContainer<>("neo4j:5");
    }
```

If you already have containers defined in this way, or you just prefer this style, you can import these declaration classes rather than defining you containers as @Bean methods. To do so, add the @ImportTestcontainers annotation to your test configuration class:

`자바`
```java
    import org.springframework.boot.test.context.TestConfiguration;
    import org.springframework.boot.testcontainers.context.ImportTestcontainers;
  
    @TestConfiguration(proxyBeanMethods = false)
    @ImportTestcontainers(MyContainers.class)
    public class MyContainersConfiguration { }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.context.TestConfiguration
    import org.springframework.boot.testcontainers.context.ImportTestcontainers
    @TestConfiguration(proxyBeanMethods = false)
    @ImportTestcontainers(MyContainers::class)
    class MyContainersConfiguration { }
```

{: .note}
You can use the @ServiceConnection annotation on Container fields to establish service connections. You can also add @DynamicPropertySource annotated methods to your
declaration class.


#### Using DevTools with Testcontainers at Development Time
When using devtools, you can annotate beans and bean methods with @RestartScope. Such beans won’t be recreated when the devtools restart the application. This is especially useful for Testcontainer Container beans, as they keep their state despite the application restart.

`자바`
```java
    import org.testcontainers.containers.MongoDBContainer;
    import org.springframework.boot.devtools.restart.RestartScope;
    import org.springframework.boot.test.context.TestConfiguration;
    import org.springframework.context.annotation.Bean;

    @TestConfiguration(proxyBeanMethods = false)
    public class MyContainersConfiguration {
        @Bean
        @RestartScope
        public MongoDBContainer monogDbContainer() {
            return new MongoDBContainer("mongo:5.0");
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.devtools.restart.RestartScope
    import org.springframework.boot.test.context.TestConfiguration
    import org.springframework.context.annotation.Bean
    import org.testcontainers.containers.MongoDBContainer

    @TestConfiguration(proxyBeanMethods = false)
    class MyContainersConfiguration {
        @Bean
        @RestartScope
        fun monogDbContainer(): MongoDBContainer {
            return MongoDBContainer("mongo:5.0")
        }
    }
```

{: .warning}
If you’re using Gradle and want to use this feature, you need to change the configuration of the spring-boot-devtools dependency from developmentOnly to testImplementation. With the default scope of developmentOnly, the bootTestRun task will not pick up changes in your code, as the devtools are not active.


### 7.8.5. Test Utilities
A few test utility classes that are generally useful when testing your application are packaged as part of spring-boot.


#### ConfigDataApplicationContextInitializer
ConfigDataApplicationContextInitializer is an ApplicationContextInitializer that you can apply to your tests to load Spring Boot application.properties files. You can use it when you do not need the full set of features provided by @SpringBootTest, as shown in the following example:

`자바`
```java
    import org.springframework.boot.test.context.ConfigDataApplicationContextInitializer;
    import org.springframework.test.context.ContextConfiguration;
    
    @ContextConfiguration(classes = Config.class, initializers = ConfigDataApplicationContextInitializer.class)
    class MyConfigFileTests {
        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.test.context.ConfigDataApplicationContextInitializer
    import org.springframework.test.context.ContextConfiguration
  
    @ContextConfiguration(classes = [Config::class], initializers = [ConfigDataApplicationContextInitializer::class])
    class MyConfigFileTests {
        // ... 
    }
```

{: .note}
Using ConfigDataApplicationContextInitializer alone does not provide support for @Value("${...}") injection. Its only job is to ensure that application.properties files  are loaded into Spring’s Environment. For @Value support, you need to either additionally configure a PropertySourcesPlaceholderConfigurer or use @SpringBootTest, which auto-configures one for you.


#### TestPropertyValues
TestPropertyValues lets you quickly add properties to a ConfigurableEnvironment or ConfigurableApplicationContext. You can call it with key=value strings, as follows:
`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.boot.test.util.TestPropertyValues;
    import org.springframework.mock.env.MockEnvironment;
    import static org.assertj.core.api.Assertions.assertThat;

    class MyEnvironmentTests {
        @Test
        void testPropertySources() {
            MockEnvironment environment = new MockEnvironment();
            TestPropertyValues.of("org=Spring", "name=Boot").applyTo(environment);
            assertThat(environment.getProperty("name")).isEqualTo("Boot");
        } 
    }
```

`코틀린`
```kotlin
    import org.assertj.core.api.Assertions.assertThat
    import org.junit.jupiter.api.Test
    import org.springframework.boot.test.util.TestPropertyValues
    import org.springframework.mock.env.MockEnvironment

    class MyEnvironmentTests {
        @Test
        fun testPropertySources() {
            val environment = MockEnvironment()
            TestPropertyValues.of("org=Spring", "name=Boot").applyTo(environment)
            assertThat(environment.getProperty("name")).isEqualTo("Boot")
        } 
    }
```


#### OutputCapture
OutputCapture is a JUnit Extension that you can use to capture System.out and System.err output. To use it, add @ExtendWith(OutputCaptureExtension.class) and inject CapturedOutput as an argument to your test class constructor or test method as follows:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.junit.jupiter.api.extension.ExtendWith;
    import org.springframework.boot.test.system.CapturedOutput;
    import org.springframework.boot.test.system.OutputCaptureExtension;
    import static org.assertj.core.api.Assertions.assertThat;

    @ExtendWith(OutputCaptureExtension.class)
    class MyOutputCaptureTests {
        @Test
        void testName(CapturedOutput output) {
            System.out.println("Hello World!");
            assertThat(output).contains("World");
        }
    }
```

`코틀린`
```kotlin
    import org.assertj.core.api.Assertions.assertThat
    import org.junit.jupiter.api.Test
    import org.junit.jupiter.api.extension.ExtendWith
    import org.springframework.boot.test.system.CapturedOutput
    import org.springframework.boot.test.system.OutputCaptureExtension

    @ExtendWith(OutputCaptureExtension::class)
    class MyOutputCaptureTests {
        @Test
        fun testName(output: CapturedOutput?) {
            println("Hello World!")
            assertThat(output).contains("World")
        }
    }
```


#### TestRestTemplate
TestRestTemplate is a convenience alternative to Spring’s RestTemplate that is useful in integration tests. You can get a vanilla template or one that sends Basic HTTP authentication (with a username and password). In either case, the template is fault tolerant. This means that it behaves in a test- friendly way by not throwing exceptions on 4xx and 5xx errors. Instead, such errors can be detected through the returned ResponseEntity and its status code.

{: .note}
Spring Framework 5.0 provides a new WebTestClient that works for WebFlux integration tests and both WebFlux and MVC end-to-end testing. It provides a fluent API for assertions, unlike TestRestTemplate.

It is recommended, but not mandatory, to use the Apache HTTP Client (version 5.1 or better). If you have that on your classpath, the TestRestTemplate responds by configuring the client appropriately. If you do use Apache’s HTTP client, some additional test-friendly features are enabled:

- Redirects are not followed (so you can assert the response location).
- Cookies are ignored (so the template is stateless).

TestRestTemplate can be instantiated directly in your integration tests, as shown in the following example:

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.boot.test.web.client.TestRestTemplate;
    import org.springframework.http.ResponseEntity;
    import static org.assertj.core.api.Assertions.assertThat;

    class MyTests {
        private final TestRestTemplate template = new TestRestTemplate();
        
        @Test
        void testRequest() {
            ResponseEntity<String> headers = this.template.getForEntity("https://myhost.example.com/example", String.class);
            assertThat(headers.getHeaders().getLocation()).hasHost("other.example.com");
        }
    }
```

`코틀린`
```kotlin
    import org.assertj.core.api.Assertions.assertThat
    import org.junit.jupiter.api.Test
    import org.springframework.boot.test.web.client.TestRestTemplate

    class MyTests {
        private val template = TestRestTemplate()

        @Test
        fun testRequest() {
            val headers = template.getForEntity("https://myhost.example.com/example", String::class.java)
            assertThat(headers.headers.location).hasHost("other.example.com")
        }
    }
```

Alternatively, if you use the @SpringBootTest annotation with WebEnvironment.RANDOM_PORT or WebEnvironment.DEFINED_PORT, you can inject a fully configured TestRestTemplate and start using it. If necessary, additional customizations can be applied through the RestTemplateBuilder bean. Any URLs that do not specify a host and port automatically connect to the embedded server, as shown in the following example:

`자바`
```java
    import java.time.Duration;
    import org.junit.jupiter.api.Test;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.boot.test.context.SpringBootTest;
    import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
    import org.springframework.boot.test.context.TestConfiguration;
    import org.springframework.boot.test.web.client.TestRestTemplate;
    import org.springframework.boot.web.client.RestTemplateBuilder;
    import org.springframework.context.annotation.Bean;
    import org.springframework.http.HttpHeaders;
    import static org.assertj.core.api.Assertions.assertThat;

    @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
    class MySpringBootTests {
        @Autowired
        private TestRestTemplate template;

        @Test
        void testRequest() {
            HttpHeaders headers = this.template.getForEntity("/example", String.class).getHeaders();
            assertThat(headers.getLocation()).hasHost("other.example.com");
        }
    
        @TestConfiguration(proxyBeanMethods = false)
        static class RestTemplateBuilderConfiguration {
            @Bean
            RestTemplateBuilder restTemplateBuilder() {
                return new RestTemplateBuilder().setConnectTimeout(Duration.ofSeconds(1))
                    .setReadTimeout(Duration.ofSeconds(1));
            } 
        } 
    }
```

`코틀린`
```kotlin
    import org.assertj.core.api.Assertions.assertThat
    import org.junit.jupiter.api.Test
    import org.springframework.beans.factory.annotation.Autowired
    import org.springframework.boot.test.context.SpringBootTest
    import org.springframework.boot.test.context.SpringBootTest.WebEnvironment
    import org.springframework.boot.test.context.TestConfiguration
    import org.springframework.boot.test.web.client.TestRestTemplate
    import org.springframework.boot.web.client.RestTemplateBuilder
    import org.springframework.context.annotation.Bean
    import java.time.Duration

    @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
    class MySpringBootTests(@Autowired val template: TestRestTemplate) {
        @Test
        fun testRequest() {
            val headers = template.getForEntity("/example", String::class.java).headers
            assertThat(headers.location).hasHost("other.example.com")
        }
        
        @TestConfiguration(proxyBeanMethods = false)
        internal class RestTemplateBuilderConfiguration {
            @Bean
            fun restTemplateBuilder(): RestTemplateBuilder {
                return RestTemplateBuilder().setConnectTimeout(Duration.ofSeconds(1))
                    .setReadTimeout(Duration.ofSeconds(1))
            } 
        }
    }
```

## 7.9. Docker Compose Support
Docker Compose is a popular technology that can be used to define and manage multiple containers for services that your application needs. A compose.yml file is typically created next to your application which defines and configures service containers.

A typical workflow with Docker Compose is to run docker compose up, work on your application with it connecting to started services, then run docker compose down when you are finished.s

The spring-boot-docker-compose module can be included in a project to provide support for working with containers using Docker Compose. Add the module dependency to your build, as shown in the following listings for Maven and Gradle:

`메이븐`
```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-docker-compose</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
```

`그레이들`
```groovy
    dependencies {
        developmentOnly("org.springframework.boot:spring-boot-docker-compose")
    }
```

When this module is included as a dependency Spring Boot will do the following:
- Search for a compose.yml and other common compose filenames in your application directory • Call docker compose up with the discovered compose.yml
- Create service connection beans for each supported container
- Call docker compose stop when the application is shutdown

{: .note}
The docker compose or docker-compose CLI application needs to be on your path in order for Spring Boot’s support to work correctly.


### 7.9.1. Service Connections
A service connection is a connection to any remote service. Spring Boot’s auto-configuration can consume the details of a service connection and use them to establish a connection to a remote service. When doing so, the connection details take precedence over any connection-related configuration properties.

When using Spring Boot’s Docker Compose support, service connections are established to the port mapped by the container.

{: .note}
Docker compose is usually used in such a way that the ports inside the container are mapped to ephemeral ports on your computer. For example, A Postgres server may run inside the container using port 5432 but be mapped to a totally different port locally. The service connection will always discover and use the locally mapped port.

Service connections are established by using the image name of the container. The following service connections are currently supported:

|Connection Details| Matched on|
|---|---|
|`CassandraConnectionDetails`|Containers named "cassandra"|
|`ElasticsearchConnectionDetails`|Containers named "elasticsearch"|
|`JdbcConnectionDetails`|Containers named "gvenzl/oracle-xe", "mariadb", "mssql/server", "mysql", or "postgres"|
|`MongoConnectionDetails`|Containers named "mongo"|
|`R2dbcConnectionDetails`|Containers named "gvenzl/oracle-xe", "mariadb", "mssql/server", "mysql", or "postgres"|
|`RabbitConnectionDetails`|Containers named "rabbitmq"|
|`RedisConnectionDetails`|Containers named "redis"|
|`ZipkinConnectionDetails`|Containers named "openzipkin/zipkin".|


### 7.9.2. Custom Images
Sometimes you may need to use your own version of an image to provide a service. You can use any custom image as long as it behaves in the same way as the standard image. Specifically, any environment variables that the standard image supports must also be used in your custom image.

If your image uses a different name, you can use a label in your compose.yml file so that Spring Boot can provide a service connection. Use a label named org.springframework.boot.service-connection to provide the service name.

예제:

```yaml
    services:
        redis:
            image: 'mycompany/mycustomredis:7.0'
            ports:
                - '6379'
            labels:
                org.springframework.boot.service-connection: redis
```


### 7.9.3. Skipping Specific Containers
If you have a container image defined in your compose.yml that you don’t want connected to your application you can use a label to ignore it. Any container with labeled with org.springframework.boot.ignore will be ignored by Spring Boot.

예제:

```yaml
    services:
        redis:
            image: 'redis:7.0'
            ports:
                - '6379'
            labels:
                org.springframework.boot.ignore: true
```


### 7.9.4. Using a Specific Compose File
If your compose file is not in the same directory as your application, or if it’s named differently, you can use spring.docker.compose.file in your application.properties or application.yaml to point to a different file. Properties can be defined as an exact path or a path that’s relative to your application.

예제:

`프로퍼티스(Properties)`
```
    spring.docker.compose.file=../my-compose.yml
```

`Yaml`
```yaml
    spring:
        docker:
            compose:
                file: "../my-compose.yml"
```


### 7.9.5. Waiting for Container Readiness
Containers started by Docker Compose may take some time to become fully ready. The recommended way of checking for readiness is to add a healthcheck section under the service definition in your compose.yml file.

Since it’s not uncommon for healthcheck configuration to be omitted from compose.yml files, Spring Boot also checks directly for service readiness. By default, a container is considered ready when a TCP/IP connection can be established to its mapped port.

You can disable this on a per-container basis by adding a org.springframework.boot.readiness- check.tcp.disable label in your compose.yml file.

예제:

```yaml
    services:
        redis:
            image: 'redis:7.0'
            ports:
                - '6379'
            labels:
                org.springframework.boot.readiness-check.tcp.disable: true
```

You can also change timeout values in your application.properties or application.yaml file:

`프로퍼티스(Properties)`
```
    spring.docker.compose.readiness.tcp.connect-timeout=10s
    spring.docker.compose.readiness.tcp.read-timeout=5s
```

`Yaml`
```yaml
    spring:
        docker:
            compose:
                readiness:
                    tcp:
                        connect-timeout: 10s
                        read-timeout: 5s
```

The overall timeout can be configured using spring.docker.compose.readiness.timeout.


### 7.9.6. Controlling the Docker Compose Lifecycle
By default Spring Boot calls docker compose up when your application starts and docker compose stop when it’s shut down. If you prefer to have different lifecycle management you can use the spring.docker.compose.lifecycle-management property.

The following values are supported:
- none - Do not start or stop Docker Compose
- start-only - Start Docker Compose when the application starts and leave it running
- start-and-stop - Start Docker Compose when the application starts and stop it when the JVM exits

In addition you can use the spring.docker.compose.start.command property to change whether docker compose up or docker compose start is used. The spring.docker.compose.stop.command allows you to configure if docker compose down or docker compose stop is used.

The following example shows how lifecycle management can be configured:

`프로퍼티스(Properties)`
```
    spring.docker.compose.lifecycle-management=start-and-stop
    spring.docker.compose.start.command=start
    spring.docker.compose.stop.command=down
    spring.docker.compose.stop.timeout=1m
```

`Yaml`
```yaml
    spring:
        docker:
            compose:
                lifecycle-management: start-and-stop
                start:
                    command: start
                stop:
                    command: down
                    timeout: 1m
```


### 7.9.7. Activating Docker Compose Profiles
Docker Compose profiles are similar to Spring profiles in that they let you adjust your Docker Compose configuration for specific environments. If you want to activate a specific Docker Compose profile you can use the spring.docker.compose.profiles.active property in your application.properties or application.yaml file:

`프로퍼티스(Properties)`
```
    spring.docker.compose.profiles.active=myprofile
```

`Yaml`
```yaml
    spring:
        docker:
            compose:
                profiles:
                    active: "myprofile"
```


## 7.10. Creating Your Own Auto-configuration
If you work in a company that develops shared libraries, or if you work on an open-source or commercial library, you might want to develop your own auto-configuration. Auto-configuration classes can be bundled in external jars and still be picked up by Spring Boot.

Auto-configuration can be associated to a “starter” that provides the auto-configuration code as well as the typical libraries that you would use with it. We first cover what you need to know to build your own auto-configuration and then we move on to the typical steps required to create a custom starter.


### 7.10.1. Understanding Auto-configured Beans
Classes that implement auto-configuration are annotated with @AutoConfiguration. This annotation itself is meta-annotated with @Configuration, making auto-configurations standard @Configuration classes. Additional @Conditional annotations are used to constrain when the auto-configuration should apply. Usually, auto-configuration classes use @ConditionalOnClass and @ConditionalOnMissingBean annotations. This ensures that auto-configuration applies only when relevant classes are found and when you have not declared your own @Configuration.

You can browse the source code of spring-boot-autoconfigure to see the @AutoConfiguration classes that Spring provides (see the META- INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports file).


### 7.10.2. Locating Auto-configuration Candidates
Spring Boot checks for the presence of a META- INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports file within your published jar. The file should list your configuration classes, with one class name per line, as shown in the following example:

```
    com.mycorp.libx.autoconfigure.LibXAutoConfiguration
    com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration
```

{: .note}
You can add comments to the imports file using the # character.

{: .note}
Auto-configurations must be loaded only by being named in the imports file. Make sure that they are defined in a specific package space and that they are never the target of component scanning. Furthermore, auto-configuration classes should not enable component scanning to find additional components. Specific @Import annotations should be used instead.

If your configuration needs to be applied in a specific order, you can use the before, beforeName, after and afterName attributes on the @AutoConfiguration annotation or the dedicated @AutoConfigureBefore and @AutoConfigureAfter annotations. For example, if you provide web- specific configuration, your class may need to be applied after WebMvcAutoConfiguration.

If you want to order certain auto-configurations that should not have any direct knowledge of each other, you can also use @AutoConfigureOrder. That annotation has the same semantic as the regular @Order annotation but provides a dedicated order for auto-configuration classes.

As with standard @Configuration classes, the order in which auto-configuration classes are applied only affects the order in which their beans are defined. The order in which those beans are subsequently created is unaffected and is determined by each bean’s dependencies and any @DependsOn relationships.


### 7.10.3. Condition Annotations
You almost always want to include one or more @Conditional annotations on your auto- configuration class. The @ConditionalOnMissingBean annotation is one common example that is used to allow developers to override auto-configuration if they are not happy with your defaults.

Spring Boot includes a number of @Conditional annotations that you can reuse in your own code by annotating @Configuration classes or individual @Bean methods. These annotations include:

- Class Conditions
- Bean Conditions
- Property Conditions
- Resource Conditions
- Web Application Conditions
- SpEL Expression Conditions


#### Class Conditions
The @ConditionalOnClass and @ConditionalOnMissingClass annotations let @Configuration classes be included based on the presence or absence of specific classes. Due to the fact that annotation metadata is parsed by using ASM, you can use the value attribute to refer to the real class, even though that class might not actually appear on the running application classpath. You can also use the name attribute if you prefer to specify the class name by using a String value.

This mechanism does not apply the same way to @Bean methods where typically the return type is the target of the condition: before the condition on the method applies, the JVM will have loaded the class and potentially processed method references which will fail if the class is not present.

To handle this scenario, a separate @Configuration class can be used to isolate the condition, as shown in the following example:

`자바`
```java
    import org.springframework.boot.autoconfigure.AutoConfiguration;
    import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
    import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    @AutoConfiguration
    // Some conditions ...
    public class MyAutoConfiguration {
        // Auto-configured beans ...
        @Configuration(proxyBeanMethods = false)
        @ConditionalOnClass(SomeService.class)
        public static class SomeServiceConfiguration {
            @Bean
            @ConditionalOnMissingBean
            public SomeService someService() {
                return new SomeService();
            }
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.condition.ConditionalOnClass
    import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean
    import org.springframework.context.annotation.Bean
    import org.springframework.context.annotation.Configuration
    
    @Configuration(proxyBeanMethods = false)
    // Some conditions ...
    class MyAutoConfiguration {
        // Auto-configured beans ...
        @Configuration(proxyBeanMethods = false)
        @ConditionalOnClass(SomeService::class)
        class SomeServiceConfiguration {
            @Bean
            @ConditionalOnMissingBean
            fun someService(): SomeService {
                return SomeService()
            }
        } 
    }
```

{: .note}
If you use @ConditionalOnClass or @ConditionalOnMissingClass as a part of a meta- annotation to compose your own composed annotations, you must use name as referring to the class in such a case is not handled.


#### Bean Conditions
The @ConditionalOnBean and @ConditionalOnMissingBean annotations let a bean be included based on the presence or absence of specific beans. You can use the value attribute to specify beans by type or name to specify beans by name. The search attribute lets you limit the ApplicationContext hierarchy that should be considered when searching for beans.

When placed on a @Bean method, the target type defaults to the return type of the method, as shown in the following example:

`자바`
```java
    import org.springframework.boot.autoconfigure.AutoConfiguration;
    import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
    import org.springframework.context.annotation.Bean;

    @AutoConfiguration
    public class MyAutoConfiguration {
        @Bean
        @ConditionalOnMissingBean
        public SomeService someService() {
            return new SomeService();
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean
    import org.springframework.context.annotation.Bean
    import org.springframework.context.annotation.Configuration

    @Configuration(proxyBeanMethods = false)
    class MyAutoConfiguration {
        @Bean
        @ConditionalOnMissingBean
        fun someService(): SomeService {
            return SomeService()
        }
    }
```
In the preceding example, the someService bean is going to be created if no bean of type SomeService is already contained in the ApplicationContext.

{: .note}
You need to be very careful about the order in which bean definitions are added, as these conditions are evaluated based on what has been processed so far. For this reason, we recommend using only @ConditionalOnBean and @ConditionalOnMissingBean annotations on auto-configuration classes (since these are guaranteed to load after any user-defined bean definitions have been added).

{: .note}
@ConditionalOnBean and @ConditionalOnMissingBean do not prevent @Configuration classes from being created. The only difference between using these conditions at the class level and marking each contained @Bean method with the annotation is that the former prevents registration of the @Configuration class as a bean if the condition does not match.

{: .note}
When declaring a @Bean method, provide as much type information as possible in the method’s return type. For example, if your bean’s concrete class implements an interface the bean method’s return type should be the concrete class and not the interface. Providing as much type information as possible in @Bean methods is particularly important when using bean conditions as their evaluation can only rely upon to type information that is available in the method signature.


#### Property Conditions
The @ConditionalOnProperty annotation lets configuration be included based on a Spring Environment property. Use the prefix and name attributes to specify the property that should be checked. By default, any property that exists and is not equal to false is matched. You can also create more advanced checks by using the havingValue and matchIfMissing attributes.


#### Resource Conditions
The @ConditionalOnResource annotation lets configuration be included only when a specific resource is present. Resources can be specified by using the usual Spring conventions, as shown in the following example: file:/home/user/test.dat.


#### Web Application Conditions
The @ConditionalOnWebApplication and @ConditionalOnNotWebApplication annotations let configuration be included depending on whether the application is a web application. A servlet- based web application is any application that uses a Spring WebApplicationContext, defines a session scope, or has a ConfigurableWebEnvironment. A reactive web application is any application that uses a ReactiveWebApplicationContext, or has a ConfigurableReactiveWebEnvironment.

The @ConditionalOnWarDeployment and @ConditionalOnNotWarDeployment annotations let configuration be included depending on whether the application is a traditional WAR application that is deployed to a servlet container. This condition will not match for applications that are run with an embedded web server.


#### SpEL Expression Conditions
The @ConditionalOnExpression annotation lets configuration be included based on the result of a SpEL expression.

{: .note}
Referencing a bean in the expression will cause that bean to be initialized very early in context refresh processing. As a result, the bean won’t be eligible for post- processing (such as configuration properties binding) and its state may be incomplete.


### 7.10.4. Testing your Auto-configuration
An auto-configuration can be affected by many factors: user configuration (@Bean definition and Environment customization), condition evaluation (presence of a particular library), and others. Concretely, each test should create a well defined ApplicationContext that represents a combination of those customizations. ApplicationContextRunner provides a great way to achieve that. ApplicationContextRunner is usually defined as a field of the test class to gather the base, common configuration. The following example makes sure that MyServiceAutoConfiguration is always invoked:

`자바`
```java
    private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()   
                    .withConfiguration(AutoConfigurations.of(MyServiceAutoConfiguration.class));
```

`코틀린`
```kotlin
    val contextRunner = ApplicationContextRunner()  
            .withConfiguration(AutoConfigurations.of(MyServiceAutoConfiguration::class.java))
```

{: .note}
If multiple auto-configurations have to be defined, there is no need to order their declarations as they are invoked in the exact same order as when running the
application.

Each test can use the runner to represent a particular use case. For instance, the sample below invokes a user configuration (UserConfiguration) and checks that the auto-configuration backs off properly. Invoking run provides a callback context that can be used with AssertJ.

`자바`
```java
    @Test
    void defaultServiceBacksOff() {
        this.contextRunner.withUserConfiguration(UserConfiguration.class).run((context) -> {
            assertThat(context).hasSingleBean(MyService.class);
            assertThat(context).getBean("myCustomService").isSameAs(context.getBean(MyService.class));
        }); 
    }
  
    @Configuration(proxyBeanMethods = false)
    static class UserConfiguration {
        @Bean
        MyService myCustomService() {
            return new MyService("mine");
        }
    }
```

`코틀린`
```kotlin
    @Test
    fun defaultServiceBacksOff() {
        contextRunner.withUserConfiguration(UserConfiguration::class.java)
            .run { context: AssertableApplicationContext ->
                assertThat(context).hasSingleBean(MyService::class.java)
                assertThat(context).getBean("myCustomService")
                    .isSameAs(context.getBean(MyService::class.java))
            } 
    }
  
    @Configuration(proxyBeanMethods = false)
    internal class UserConfiguration {
        @Bean
        fun myCustomService(): MyService {
            return MyService("mine")
        }
    }
```

It is also possible to easily customize the Environment, as shown in the following example:

`자바`
```java
    @Test
    void serviceNameCanBeConfigured() {
        this.contextRunner.withPropertyValues("user.name=test123").run((context) -> {
            assertThat(context).hasSingleBean(MyService.class);
            assertThat(context.getBean(MyService.class).getName()).isEqualTo("test123");
        }); 
    }
```

`코틀린`
```kotlin
    @Test
    fun serviceNameCanBeConfigured() {
        contextRunner.withPropertyValues("user.name=test123").run { context:
        AssertableApplicationContext ->
            assertThat(context).hasSingleBean(MyService::class.java)
            assertThat(context.getBean(MyService::class.java).name).isEqualTo("test123")
        }
    }
```

The runner can also be used to display the ConditionEvaluationReport. The report can be printed at INFO or DEBUG level. The following example shows how to use the ConditionEvaluationReportLoggingListener to print the report in auto-configuration tests.

`자바`
```java
    import org.junit.jupiter.api.Test;
    import org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener;
    import org.springframework.boot.logging.LogLevel;
    import org.springframework.boot.test.context.runner.ApplicationContextRunner;

    class MyConditionEvaluationReportingTests {
        @Test
        void autoConfigTest() {
            new ApplicationContextRunner()
                .withInitializer(ConditionEvaluationReportLoggingListener.forLogLevel(LogLevel.INFO))
                .run((context) -> {
                    // Test something...
                });
            } 
        }
```

`코틀린`
```kotlin
    import org.junit.jupiter.api.Test
    import org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener
    import org.springframework.boot.logging.LogLevel
    import org.springframework.boot.test.context.assertj.AssertableApplicationContext
    import org.springframework.boot.test.context.runner.ApplicationContextRunner

    class MyConditionEvaluationReportingTests {
        @Test
        fun autoConfigTest() {
            ApplicationContextRunner()
                .withInitializer(ConditionEvaluationReportLoggingListener.forLogLevel(LogLevel.INFO))
                .run { context: AssertableApplicationContext? -> }
        } 
    }
```


#### Simulating a Web Context
If you need to test an auto-configuration that only operates in a servlet or reactive web application context, use the WebApplicationContextRunner or ReactiveWebApplicationContextRunner respectively.


#### Overriding the Classpath
It is also possible to test what happens when a particular class and/or package is not present at runtime. Spring Boot ships with a FilteredClassLoader that can easily be used by the runner. In the following example, we assert that if MyService is not present, the auto-configuration is properly disabled:

`자바`
```java
    @Test
    void serviceIsIgnoredIfLibraryIsNotPresent() {
        this.contextRunner.withClassLoader(new FilteredClassLoader(MyService.class))
            .run((context) -> assertThat(context).doesNotHaveBean("myService"));
}

```

`코틀린`
```kotlin
    @Test
    fun serviceIsIgnoredIfLibraryIsNotPresent() {
        contextRunner.withClassLoader(FilteredClassLoader(MyService::class.java))
            .run { context: AssertableApplicationContext? ->
                assertThat(context).doesNotHaveBean("myService")
            }
}
```


### 7.10.5. Creating Your Own Starter
A typical Spring Boot starter contains code to auto-configure and customize the infrastructure of a given technology, let’s call that "acme". To make it easily extensible, a number of configuration keys in a dedicated namespace can be exposed to the environment. Finally, a single "starter" dependency is provided to help users get started as easily as possible.

Concretely, a custom starter can contain the following:
- The autoconfigure module that contains the auto-configuration code for "acme".
- The starter module that provides a dependency to the autoconfigure module as well as "acme" and any additional dependencies that are typically useful. In a nutshell, adding the starter should provide everything needed to start using that library.

This separation in two modules is in no way necessary. If "acme" has several flavors, options or optional features, then it is better to separate the auto-configuration as you can clearly express the fact some features are optional. Besides, you have the ability to craft a starter that provides an opinion about those optional dependencies. At the same time, others can rely only on the autoconfigure module and craft their own starter with different opinions.

If the auto-configuration is relatively straightforward and does not have optional features, merging the two modules in the starter is definitely an option.


#### Naming
You should make sure to provide a proper namespace for your starter. Do not start your module names with spring-boot, even if you use a different Maven groupId. We may offer official support for the thing you auto-configure in the future.

As a rule of thumb, you should name a combined module after the starter. For example, assume that you are creating a starter for "acme" and that you name the auto-configure module acme- spring-boot and the starter acme-spring-boot-starter. If you only have one module that combines the two, name it acme-spring-boot-starter.

#### Configuration keys
If your starter provides configuration keys, use a unique namespace for them. In particular, do not include your keys in the namespaces that Spring Boot uses (such as server, management, spring, and so on). If you use the same namespace, we may modify these namespaces in the future in ways that break your modules. As a rule of thumb, prefix all your keys with a namespace that you own (for example acme).

Make sure that configuration keys are documented by adding field javadoc for each property, as shown in the following example:

`자바`
```java
    import java.time.Duration;
    import org.springframework.boot.context.properties.ConfigurationProperties;
    
    @ConfigurationProperties("acme")
    public class AcmeProperties {
        /**
        * Whether to check the location of acme resources.
        */
        private boolean checkLocation = true;
        
        /**
        * Timeout for establishing a connection to the acme server.
        */
        private Duration loginTimeout = Duration.ofSeconds(3);
        
        public boolean isCheckLocation() {
            return this.checkLocation;
        }

        public void setCheckLocation(boolean checkLocation) {
            this.checkLocation = checkLocation;
        }

        public Duration getLoginTimeout() {
            return this.loginTimeout;
        }
        
        public void setLoginTimeout(Duration loginTimeout) {
            this.loginTimeout = loginTimeout;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import java.time.Duration

    @ConfigurationProperties("acme")
    class AcmeProperties(
        /**
        * Whether to check the location of acme resources.
        */
        var isCheckLocation: Boolean = true,
        
        /**
        * Timeout for establishing a connection to the acme server.
        */
        var loginTimeout:Duration = Duration.ofSeconds(3))
```

{: .note}
You should only use plain text with @ConfigurationProperties field Javadoc, since they are not processed before being added to the JSON.

Here are some rules we follow internally to make sure descriptions are consistent:
- Do not start the description by "The" or "A".
- For boolean types, start the description with "Whether" or "Enable".
- For collection-based types, start the description with "Comma-separated list"
- Use java.time.Duration rather than long and describe the default unit if it differs from milliseconds, such as "If a duration suffix is not specified, seconds will be used".
- Do not provide the default value in the description unless it has to be determined at runtime.

Make sure to trigger meta-data generation so that IDE assistance is available for your keys as well. You may want to review the generated metadata (META-INF/spring-configuration-metadata.json) to make sure your keys are properly documented. Using your own starter in a compatible IDE is also a good idea to validate that quality of the metadata.

#### The “autoconfigure” Module
The autoconfigure module contains everything that is necessary to get started with the library. It may also contain configuration key definitions (such as @ConfigurationProperties) and any callback interface that can be used to further customize how the components are initialized.

{: .note}
You should mark the dependencies to the library as optional so that you can include the autoconfigure module in your projects more easily. If you do it that way, the library is not provided and, by default, Spring Boot backs off.

Spring Boot uses an annotation processor to collect the conditions on auto-configurations in a metadata file (META-INF/spring-autoconfigure-metadata.properties). If that file is present, it is used to eagerly filter auto-configurations that do not match, which will improve startup time.

When building with Maven, it is recommended to add the following dependency in a module that contains auto-configurations:

```xml
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-autoconfigure-processor</artifactId>
        <optional>true</optional>
    </dependency>
```

If you have defined auto-configurations directly in your application, make sure to configure the spring-boot-maven-plugin to prevent the repackage goal from adding the dependency into the fat jar:

```xml
    <project>
        <build>
            <plugins>
                <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                    <configuration>
                        <excludes>
                            <exclude>
                                <groupId>org.springframework.boot</groupId>
                                <artifactId>spring-boot-autoconfigure-processor</artifactId>
                            </exclude>
                        </excludes>
                    </configuration>
                </plugin>
            </plugins>
        </build>
    </project>
```

With Gradle, the dependency should be declared in the annotationProcessor configuration, as shown in the following example:

`그레이들`
```groovy
    dependencies {
        annotationProcessor "org.springframework.boot:spring-boot-autoconfigure-processor"
    }
```

#### Starter Module
The starter is really an empty jar. Its only purpose is to provide the necessary dependencies to work with the library. You can think of it as an opinionated view of what is required to get started.

Do not make assumptions about the project in which your starter is added. If the library you are auto-configuring typically requires other starters, mention them as well. Providing a proper set of default dependencies may be hard if the number of optional dependencies is high, as you should avoid including dependencies that are unnecessary for a typical usage of the library. In other words, you should not include optional dependencies.

{: .note}
Either way, your starter must reference the core Spring Boot starter (spring-boot- starter) directly or indirectly (there is no need to add it if your starter relies on another starter). If a project is created with only your custom starter, Spring Boot’s core features will be honoured by the presence of the core starter.


## 7.11. Kotlin Support
Kotlin is a statically-typed language targeting the JVM (and other platforms) which allows writing concise and elegant code while providing interoperability with existing libraries written in Java.

Spring Boot provides Kotlin support by leveraging the support in other Spring projects such as Spring Framework, Spring Data, and Reactor. See the Spring Framework Kotlin support documentation for more information.

The easiest way to start with Spring Boot and Kotlin is to follow this comprehensive tutorial. You can create new Kotlin projects by using start.spring.io. Feel free to join the #spring channel of Kotlin Slack or ask a question with the spring and kotlin tags on Stack Overflow if you need support.


### 7.11.1. Requirements
Spring Boot requires at least Kotlin 1.7.x and manages a suitable Kotlin version through dependency management. To use Kotlin, org.jetbrains.kotlin:kotlin-stdlib and org.jetbrains.kotlin:kotlin-reflect must be present on the classpath. The kotlin-stdlib variants kotlin-stdlib-jdk7 and kotlin-stdlib-jdk8 can also be used.

Since Kotlin classes are final by default, you are likely to want to configure kotlin-spring plugin in order to automatically open Spring-annotated classes so that they can be proxied.

Jackson’s Kotlin module is required for serializing / deserializing JSON data in Kotlin. It is automatically registered when found on the classpath. A warning message is logged if Jackson and Kotlin are present but the Jackson Kotlin module is not.

{: .note}
These dependencies and plugins are provided by default if one bootstraps a Kotlin project on start.spring.io.


### 7.11.2. Null-safety
One of Kotlin’s key features is null-safety. It deals with null values at compile time rather than deferring the problem to runtime and encountering a NullPointerException. This helps to eliminate a common source of bugs without paying the cost of wrappers like Optional. Kotlin also allows using functional constructs with nullable values as described in this comprehensive guide to null-safety in Kotlin.

Although Java does not allow one to express null-safety in its type system, Spring Framework, Spring Data, and Reactor now provide null-safety of their API through tooling-friendly annotations. By default, types from Java APIs used in Kotlin are recognized as platform types for which null- checks are relaxed. Kotlin’s support for JSR 305 annotations combined with nullability annotations provide null-safety for the related Spring API in Kotlin.

The JSR 305 checks can be configured by adding the -Xjsr305 compiler flag with the following options: -Xjsr305={strict|warn|ignore}. The default behavior is the same as -Xjsr305=warn. The strict value is required to have null-safety taken in account in Kotlin types inferred from Spring API but should be used with the knowledge that Spring API nullability declaration could evolve even between minor releases and more checks may be added in the future.

{: .warning}
Generic type arguments, varargs and array elements nullability are not yet supported. See SPR-15942 for up-to-date information. Also be aware that
Spring Boot’s own API is not yet annotated.

### 7.11.3. Kotlin API

#### runApplication
Spring Boot provides an idiomatic way to run an application with runApplication<MyApplication>(*args) as shown in the following example:

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.boot.runApplication
  
    @SpringBootApplication
    class MyApplication
    fun main(args: Array<String>) {
        runApplication<MyApplication>(*args)
    }
```

This is a drop-in replacement for SpringApplication.run(MyApplication::class.java, *args). It also allows customization of the application as shown in the following example:

`코틀린`
```kotlin
    runApplication<MyApplication>(*args) {
        setBannerMode(OFF)
    }
```


#### Extensions
Kotlin extensions provide the ability to extend existing classes with additional functionality. The Spring Boot Kotlin API makes use of these extensions to add new Kotlin specific conveniences to existing APIs.

TestRestTemplate extensions, similar to those provided by Spring Framework for RestOperations in Spring Framework, are provided. Among other things, the extensions make it possible to take advantage of Kotlin reified type parameters.


### 7.11.4. Dependency management
In order to avoid mixing different versions of Kotlin dependencies on the classpath, Spring Boot imports the Kotlin BOM.

With Maven, the Kotlin version can be customized by setting the kotlin.version property and plugin management is provided for kotlin-maven-plugin. With Gradle, the Spring Boot plugin automatically aligns the kotlin.version with the version of the Kotlin plugin.

Spring Boot also manages the version of Coroutines dependencies by importing the Kotlin Coroutines BOM. The version can be customized by setting the kotlin-coroutines.version property.

{: .note}
org.jetbrains.kotlinx:kotlinx-coroutines-reactor dependency is provided by default if one bootstraps a Kotlin project with at least one reactive dependency on
start.spring.io.


### 7.11.5. @ConfigurationProperties
@ConfigurationProperties when used in combination with constructor binding supports classes with immutable val properties as shown in the following example:

`코틀린`
```kotlin
    @ConfigurationProperties("example.kotlin")
    data class KotlinExampleProperties(
        val name: String,
        val description: String,

        val myService: MyService) {
            data class MyService(
                val apiToken: String,
                val uri: URI
            ) 
        }
```

{: .note}
To generate your own metadata using the annotation processor, kapt should be configured with the spring-boot-configuration-processor dependency. that some features (such as detecting the default value or deprecated items) are not working due to limitations in the model kapt provides.


### 7.11.6. Testing
While it is possible to use JUnit 4 to test Kotlin code, JUnit 5 is provided by default and is recommended. JUnit 5 enables a test class to be instantiated once and reused for all of the class’s tests. This makes it possible to use @BeforeAll and @AfterAll annotations on non-static methods, which is a good fit for Kotlin. 

To mock Kotlin classes, MockK is recommended. If you need the MockK equivalent of the Mockito specific @MockBean and @SpyBean annotations, you can use SpringMockK which provides similar @MockkBean and @SpykBean annotations.


### 7.11.7. Resources
Further reading
- Kotlin language reference
- Kotlin Slack (with a dedicated #spring channel)
- Stack Overflow with spring and kotlin tags
- Try Kotlin in your browser
- Kotlin blog
- Awesome Kotlin
- Tutorial: building web applications with Spring Boot and Kotlin • Developing Spring Boot applications with Kotlin
- A Geospatial Messenger with Kotlin, Spring Boot and PostgreSQL • Introducing Kotlin support in Spring Framework 5.0
- Spring Framework 5 Kotlin APIs, the functional way

예제
- spring-boot-kotlin-demo: regular Spring Boot + Spring Data JPA project
- mixit: Spring Boot 2 + WebFlux + Reactive Spring Data MongoDB
- spring-kotlin-fullstack: WebFlux Kotlin fullstack example with Kotlin2js for frontend instead of JavaScript or TypeScript
- spring-petclinic-kotlin: Kotlin version of the Spring PetClinic Sample Application
- spring-kotlin-deepdive: a step by step migration for Boot 1.0 + Java to Boot 2.0 + Kotlin
- spring-boot-coroutines-demo: Coroutines sample project


## 7.12. SSL
Spring Boot provides the ability to configure SSL trust material that can be applied to several types of connections in order to support secure communications. Configuration properties with the prefix spring.ssl.bundle can be used to specify named sets of trust material and associated information.


### 7.12.1. Configuring SSL With Java KeyStore Files
Configuration properties with the prefix spring.ssl.bundle.jks can be used to configure bundles of trust material created with the Java keytool utility and stored in Java KeyStore files in the JKS or PKCS12 format. Each bundle has a user-provided name that can be used to reference the bundle.

When used to secure an embedded web server, a keystore is typically configured with a Java KeyStore containing a certificate and private key as shown in this example:

`프로퍼티스(Properties)`
```
    spring.ssl.bundle.jks.mybundle.key.alias=application
    spring.ssl.bundle.jks.mybundle.keystore.location=classpath:application.p12
    spring.ssl.bundle.jks.mybundle.keystore.password=secret
    spring.ssl.bundle.jks.mybundle.keystore.type=PKCS12
```

`Yaml`
```yaml
    spring: 
        ssl:
            bundle: 
                jks:
                    mybundle:
                        key:
                            alias: "application"
                        keystore:
                            location: "classpath:application.p12"
                            password: "secret"
                            type: "PKCS12"

```
When used to secure a client-side connection, a truststore is typically configured with a Java KeyStore containing the server certificate as shown in this example:

`프로퍼티스(Properties)`
```
    spring.ssl.bundle.jks.mybundle.truststore.location=classpath:server.p12
    spring.ssl.bundle.jks.mybundle.truststore.password=secret
```

`Yaml`
```yaml
    spring: 
        ssl:
            bundle: 
                jks:
                    mybundle:
                        truststore:
                            location: "classpath:server.p12"
                            password: "secret"
```
See JksSslBundleProperties for the full set of supported properties.


### 7.12.2. Configuring SSL With PEM-encoded Certificates
Configuration properties with the prefix spring.ssl.bundle.pem can be used to configure bundles of trust material in the form of PEM-encoded text. Each bundle has a user-provided name that can be used to reference the bundle.

When used to secure an embedded web server, a keystore is typically configured with a certificate and private key as shown in this example:

`프로퍼티스(Properties)`
```
    spring.ssl.bundle.pem.mybundle.keystore.certificate=classpath:application.crt
    spring.ssl.bundle.pem.mybundle.keystore.private-key=classpath:application.key
```

`Yaml`
```yaml
  spring: 
    ssl:
      bundle: 
        pem:
          mybundle:
            keystore:
              certificate: "classpath:application.crt"
              private-key: "classpath:application.key"
```

When used to secure a client-side connection, a truststore is typically configured with the server certificate as shown in this example:

`프로퍼티스(Properties)`
```
spring.ssl.bundle.pem.mybundle.truststore.certificate=classpath:server.crt
```

`Yaml`
```yaml
  spring: 
    ssl:
      bundle: 
        pem:
          mybundle:
            truststore:
              certificate: "classpath:server.crt"
```

See PemSslBundleProperties for the full set of supported properties.


### 7.12.3. Applying SSL Bundles
Once configured using properties, SSL bundles can be referred to by name in configuration properties for various types of connections that are auto-configured by Spring Boot. See the sections on embedded web servers, data technologies, and REST clients for further information.


### 7.12.4. Using SSL Bundles
Spring Boot auto-configures a bean of type SslBundles that provides access to each of the named bundles configured using the spring.ssl.bundle properties.

An SslBundle can be retrieved from the auto-configured SslBundles bean and used to create objects that are used to configure SSL connectivity in client libraries. The SslBundle provides a layered approach of obtaining these SSL objects:

- getStores() provides access to the key store and trust store java.security.KeyStore instances as well as any required key store password.
- getManagers() provides access to the java.net.ssl.KeyManagerFactory and java.net.ssl.TrustManagerFactory instances as well as the java.net.ssl.KeyManager and java.net.ssl.TrustManager arrays that they create.
- createSslContext() provides a convenient way to obtain a new java.net.ssl.SSLContext instance.

In addition, the SslBundle provides details about the key being used, the protocol to use and any option that should be applied to the SSL engine.

The following example shows retrieving an SslBundle and using it to create an SSLContext:

`자바`
```java
    import javax.net.ssl.SSLContext;
    import org.springframework.boot.ssl.SslBundle;
    import org.springframework.boot.ssl.SslBundles;
    import org.springframework.stereotype.Component;

    @Component
    public class MyComponent {
        public MyComponent(SslBundles sslBundles) {
            SslBundle sslBundle = sslBundles.getBundle("mybundle");
            SSLContext sslContext = sslBundle.createSslContext();
            // do something with the created sslContext
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.ssl.SslBundles
    import org.springframework.stereotype.Component
    
    @Component
    class MyComponent(sslBundles: SslBundles) {
        init {
            val sslBundle = sslBundles.getBundle("mybundle")
            val sslContext = sslBundle.createSslContext()
            // do something with the created sslContext
        } 
    }
```

## 7.13. What to Read Next
If you want to learn more about any of the classes discussed in this section, see the Spring Boot API documentation or you can browse the source code directly. If you have specific questions, see the how-to section.

If you are comfortable with Spring Boot’s core features, you can continue on and read about production-ready features.