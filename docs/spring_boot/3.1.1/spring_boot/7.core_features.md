---
layout: default
title: 7. Core Features
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 7
---

# 7. Core Features
이 장에서는 스프링 부트 세부 사항을 자세히 살펴본다. 여기서는 사용하고 커스텀할 수 있는 주요 기능에 대해 알아볼 수 있다. "[Getting Started](https://onestone9900.github.io/docs/spring_boot/3.1.1/spring_boot/4.getting_started/#4-getting-started)" 및 "[Developing with Spring Boot](https://onestone9900.github.io/docs/spring_boot/3.1.1/spring_boot/6.developing_with_spring_boot/)"을 아직 읽지 않았다면 먼저 읽고 기본 사항에 대한 기초를 다지는 것이 좋다.


## 7.1. SpringApplication
`스프링애플리케이션(SpringApplication)` 클래스는 `main()` 메서드에서 시작되는 스프링 애플리케이션을 부트스트랩하는 편리한 방법을 제공한다. 다양한 상황에서 다음 예제와 같이 `static SpringApplication.run` 메서드에 위임할 수 있다:

`자바`
```java
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class MyApplication {
        public static void main(String[] args) {
            SpringApplication.run(MyApplication.class, args);
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.boot.runApplication

    @SpringBootApplication
    class MyApplication
    
    fun main(args: Array<String>) {
        runApplication<MyApplication>(*args)
    }
```

애플리케이션이 시작되면 다음 출력과 비슷한 내용이 표시된다:
```
 .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.1.1)
2023-06-22T12:08:14.396Z INFO 22973 --- [ main] o.s.b.d.f.s.MyApplication
: Starting MyApplication using Java 17.0.7 with PID 22973 (/opt/apps/myapp.jar started by myuser in /opt/apps/)
2023-06-22T12:08:14.413Z INFO 22973 --- [ main] o.s.b.d.f.s.MyApplication
: No active profile set, falling back to 1 default profile: "default" 2023-06-22T12:08:16.739Z INFO 22973 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http)
2023-06-22T12:08:16.765Z INFO 22973 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2023-06-22T12:08:16.766Z INFO 22973 --- [ main] o.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/10.1.10]
2023-06-22T12:08:17.261Z INFO 22973 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext
2023-06-22T12:08:17.280Z INFO 22973 --- [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 2705 ms
2023-06-22T12:08:18.801Z INFO 22973 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ''
2023-06-22T12:08:18.840Z INFO 22973 --- [ main] o.s.b.d.f.s.MyApplication
: Started MyApplication in 5.871 seconds (process running for 7.263)
22T12:08:18.916Z INFO 22973 --- [ionShutdownHook] o.apache.catalina.core.StandardService : Stopping service [Tomcat]
```

기본적으로, 애플리케이션을 시작한 사용자와 같이, 일부 관련 시작 세부 정보를 포함한 `INFO` 로깅 메시지가 표시된다. `INFO` 이외의 로그 레벨이 필요한 경우 로그 레벨에 설명된 대로 설정할 수 있다. 애플리케이션 버전은 메인 애플리케이션 클래스 패키지의 구현 버전을 사용하여 결정된다. `spring.main.log-startup-info`를 `false`로 설정하면 시작 정보 로깅을 끌 수 있다. 그러면 애플리케이션의 활성 프로필에 대한 로깅도 꺼진다.

{: .note}
시작하는 동안 로깅을 추가하려면 `스프링애플리케이션(SpringApplication)`의 하위 클래스에서 `logStartupInfo(boolean)`을 오버라이드할 수 있다.


### 7.1.1. Startup Failure
애플리케이션이 시작되지 않으면 등록된 `페일러애널라이저(FailureAnalyzer)`가 전용 오류 메시지와 문제 해결을 위한 구체적인 조치사항를 제공한다. 예를 들어, 포트 `8080`에서 웹 애플리케이션을 시작했는데 해당 포트가 이미 사용 중이라면 다음 메시지와 비슷한 내용이 표시된다:
```
    ***************************
    APPLICATION FAILED TO START
    ***************************
    
    Description:
    
    Embedded servlet container failed to start. Port 8080 was already in use.
    
    Action:

    Identify and stop the process that is listening on port 8080 or configure this application to listen on another port.
```

{: .note}
스프링 부트는 다양한 `페일러애널라이저(FailureAnalyzer)` 구현체를 제공하며 사용자가 직접 추가할 수 있다.

페일러 애널라이저(failure analyzer)가 예외를 처리할 수 없는 경우에도 전체 상태를 표시하여 무엇이 잘못되었는지 잘 이해할 수 있다. 이렇게 하려면 `디버그(debug) 프로퍼티를 활성화`하거나 `org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener`에 대한 `DEBUG` 로깅을 활성화해야 한다.

예를 들어, `java -jar`을 사용하여 애플리케이션을 실행하는 경우 다음과 같이 디버그(debug) 프로퍼티을 활성화할 수 있다:
```
    $ java -jar myproject-0.0.1-SNAPSHOT.jar --debug
```


### 7.1.2. Lazy Initialization
`스프링애플리케이션(SpringApplication)`을 사용하면 애플리케이션을 느리게(lazily) 초기화할 수 있다. 지연 초기화(lazy initialization)가 활성화되면 애플리케이션 시작 중이 아닌 필요할 때 빈이 생성된다. 결과적으로 지연 초기화를 활성화하면 애플리케이션을 시작하는 데 걸리는 시간을 줄일 수 있다. 웹 애플리케이션에서 지연 초기화를 활성화하면 HTTP 요청이 수신될 때까지 많은 웹 관련 빈이 초기화되지 않는다.


지연 초기화의 단점은 애플리케이션의 문제 발견이 지연될 수 있다는 것이다. 잘못 구성된 빈이 느리게 초기화되면, 시작 중에는 실패가 발생하지 않으며 빈이 초기화될 때만 문제가 발생한다. 또한 JVM에 시작 중에 초기화되는 빈뿐만 아니라 모든 애플리케이션 빈을 수용할 수 있는 충분한 메모리가 있는지 확인해야 한다. 이러한 이유로 지연 초기화는 기본적으로 활성화되지 않으며 지연 초기화를 활성화하기 전에 JVM의 힙 크기를 조정하는 것이 좋다.

지연 초기화는 `스프링애플리케이션빌더(SpringApplicationBuilder)`의 `lazyInitialization` 메소드 또는 `스프링애플리케이션(SpringApplication)`의 `setLazyInitialization` 메소드를 사용하여 프로그래밍 방식으로 활성화할 수 있다. 또는 다음 예제와 같이 `spring.main.lazy-initialization` 프로퍼티을 사용하여 활성화할 수 있다:

`프로퍼티스(Properties)`
```
    spring.main.lazy-initialization=true
```

`Yaml`
```yaml
    spring:
        main:
            lazy-initialization: true
```

{: .note}
애플리케이션의 나머지 부분에 대한 지연 초기화를 사용하는 동안 특정 빈에 대한 지연 초기화를 비활성화하려는 경우 `@Lazy(false)` 어노테이션을 사용하여 해당 빈의 `lazy` 애트리뷰트를 `false`로 설정할 수 있다.


### 7.1.3. Customizing the Banner
시작할 때 인쇄되는 배너는 클래스패스에 `banner.txt` 파일을 추가하거나 `spring.banner.location` 프로퍼티를 해당 파일의 위치로 설정하여 변경할 수 있다. 파일에 UTF-8 이외의 인코딩이 있는 경우 `spring.banner.charset`을 설정할 수 있다.

`banner.txt` 파일 내에서, 환경변수에서 사용 가능한 모든 키와 다음의 자리표시자(placeholders)를 사용할 수 있다:

테이블 4. 배너 변수

|***변수***|***설명***|
|---|---|
|`${application.version}`|`MANIFEST.MF`에 선언된 애플리케이션의 버전이다. 예를 들어, `Implement-Version: 1.0`은 1.0으로 표시된다.|
|`${application.formatted-version}`|`MANIFEST.MF`에 선언되고 표시용 포맷으로 지정된 애플리케이션의 버전 번호이다(대괄호로 묶이고 접두사 v가 붙음). 예를 들어 `(v1.0)`.|
|`${spring-boot.version}`|사용 중인 스프링 부트 버전이다. 예를 들어 `3.1.1.`|
|`${spring-boot.formatted-version}`|사용 중인 스프링 부트 버전으로, 표시용으로 포맷이 지정됐다(대괄호로 묶이고 접두사 v가 붙음). 예를 들면 `(v3.1.1)`이다.|
|`${Ansi.NAME}(or ${AnsiColor.NAME}, ${AnsiBackground.NAME}, ${AnsiStyle.NAME})`|여기서 `NAME`은 ANSI 이스케이프 코드의 이름입니다. 자세한 내용은 [`AnsiPropertySource`](https://github.com/spring-projects/spring-boot/blob/v3.1.1/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java)를 참고하자.|
|`${application.title}`|`MANIFEST.MF`에 선언된 애플리케이션의 타이틀이다. 예를 들어 `Implement-Title: MyApp`은 `MyApp`로 표시된다.|

{: .note}
프로그래밍 방식으로 배너를 생성하려는 경우 `SpringApplication.setBanner(...)` 메서드를 사용할 수 있다. `org.springframework.boot.Banner` 인터페이스를 사용하고 자신만의 `printBanner()` 메소드를 구현해보자.

`spring.main.banner-mode` 프로퍼티을 사용하여 배너를 표시해야 하는지 결정할 수도 있다. `System.out`(`console`)에서 구성된 로거로 전송되거나(`log`) 전혀 생성되지 않는다(`off`).

표시된 배너는 `springBootBanner`이라는 명칭으로 싱글톤 빈이 등록된다.

{: .note}
${application.version} 및 ${application.formatted-version} 프로퍼티는 스프링 부트 런처(launchers)를 사용하는 경우에만 사용할 수 있다. 압축이 풀린 jar를 실행하고 `java -cp <classpath> <mainclass>`로 시작하는 경우 값이 확인되지 않는다.


### 7.1.4. Customizing SpringApplication
`스프링애플리케이션(SpringApplication)` 기본값이 마음에 들지 않으면 대신 로컬 인스턴스를 생성하고 커스텀할 수 있다. 예를 들어 배너를 끄려면 다음과 같이 작성할 수 있다:

`자바`
```java
    import org.springframework.boot.Banner;
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class MyApplication {
        public static void main(String[] args) {
            SpringApplication application = new SpringApplication(MyApplication.class);
            application.setBannerMode(Banner.Mode.OFF);
            application.run(args);
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.Banner
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.boot.runApplication

    @SpringBootApplication
    class MyApplication
    fun main(args: Array<String>) {
        runApplication<MyApplication>(*args) {
            setBannerMode(Banner.Mode.OFF)
        }
    }
```

{: .note}
`스프링애플리케이션(SpringApplication)`에 전달된 생성자 아규먼트는 스프링 빈의 구성 소스이다. 대부분의 경우 `@Configuration` 클래스에 대한 참조이지만 `@Component` 클래스를 직접 참조할 수도 있다.

`application.properties` 파일을 사용하여 `스프링애플리케이션(SpringApplication)`을 구성하는 것도 가능하다. 자세한 내용은 Externalized Configuration을 참고하자.

구성 옵션의 전체 목록은 [`스프링애플리케이션(SpringApplication)` Javadoc](https://docs.spring.io/spring-boot/docs/3.1.1/api/org/springframework/boot/SpringApplication.html)을 참고하자.


### 7.1.5. Fluent Builder API
`애플리케이션컨텍스트(ApplicationContext)` 계층 구조(상위/하위 관계가 있는 다중 컨텍스트)를 구축해야 하거나 "`플루언트(fluent)`" 빌더 API 사용을 선호하는 경우 `스프링애플리케이션빌더(SpringApplicationBuilder)`를 사용할 수 있다.

`스프링애플리케이션빌더(SpringApplicationBuilder)`를 사용하면 여러 메서드 호출을 연결할 수 있으며 다음 예제와 같이 계층 구조를 만들 수 있는 상위 및 하위 메서드가 포함되어 있다:

`자바`
```java
    new SpringApplicationBuilder().sources(Parent.class)
        .child(Application.class)
        .bannerMode(Banner.Mode.OFF)
        .run(args);
```

`코틀린`
```kotlin
    SpringApplicationBuilder()
        .sources(Parent::class.java)
        .child(Application::class.java)
        .bannerMode(Banner.Mode.OFF)
        .run(*args)
```

{: .note}
`애플리케이션컨텍스트(ApplicationContext)` 계층 구조를 생성할 때 몇 가지 제한 사항이 있다. 예를 들어 웹 컴포넌트는 하위 컨텍스트 내에 포함되어야 하며 상위 및 하위 컨텍스트 모두에 동일한 환경이 사용된다. 자세한 내용은 [`스프링애플리케이션빌더(SpringApplicationBuilder)` Javadoc](https://docs.spring.io/spring-boot/docs/3.1.1/api/org/springframework/boot/builder/SpringApplicationBuilder.html)을 참고하자.


### 7.1.6. Application Availability
플랫폼에 배포되면, 애플리케이션은 [쿠버네티스 프로브](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/)와 같은 인프라를 사용하여 플랫폼에 가용성에 대한 정보를 제공할 수 있다. 스프링 부트에는 일반적으로 사용되는 "활성" 및 "준비성" 가용성 상태에 대한 지원이 있다. 스프링 부트의 "액추에이터"를 사용하는 경우 이러한 상태는 헬스(health) 엔드포인트 그룹으로 노출된다.

또한,` 애플리케이션어베일러빌리티(ApplicationAvailability)` 인터페이스를 자신의 빈에 삽입하여 가용성 상태를 얻을 수도 있다.


#### Liveness State
애플리케이션의 "활성(Liveness)" 상태는 애플리케이션이 올바르게 작동할 수 있는지, 아니면 현재 오류가 발생한 경우 자체적으로 복구할 수 있는지를 알려준다. 손상된 "활성" 상태는 애플리케이션이 복구할 수 없는 상태에 있으며 인프라가 애플리케이션을 재시작해야 함을 의미한다.

{: .note}
일반적으로, 헬스 체크가 확인하는 "활성" 상태는 외부 서버의 확인을 기반으로 해서는 안 된다. 만약 그렇다면, 외부 시스템(데이터베이스, 웹 API, 외부 캐시)의 실패로 인해 대규모 재시작이 발생하고 플랫폼 전체에 연속적인 오류가 발생하게 된다.

스프링 부트 애플리케이션의 내부 상태는 대부분 스프링 `애플리케이션컨텍스트(ApplicationContext)`로 표현된다. 애플리케이션 컨텍스트가 성공적으로 시작된 경우 스프링 부트는 애플리케이션이 유효한 상태에 있다고 가정한다. 컨텍스트가 새로 고쳐지는 즉시 애플리케이션은 라이브로 간주한다. 스프링 부트 애플리케이션 라이프사이클 및 관련 애플리케이션 이벤트를 참고하자.


#### Readiness State
애플리케이션의 "준비성" 상태는 애플리케이션이 트래픽을 처리할 준비가 되었는지 여부를 알려준다. 실패한 "준비성" 상태는 지금은 트래픽을 애플리케이션으로 라우팅해서는 안 된다는 것을 플랫폼에 알린다. 이는 일반적으로 `커맨드라인러너(CommandLineRunner)` 및 `애플리케이션러너(ApplicationRunner)` 컴포넌트가 시작하고 처리하는 동안 또는 애플리케이션이 추가 트래픽을 처리하기에는 너무 바쁘다고 판단하는 경우 언제든지 발생한다.

애플리케이션 및 커맨드라인 러너가 호출되자마자 애플리케이션은 준비된 것으로 간주된다. 스프링 부트 애플리케이션 라이프사이클 및 관련 애플리케이션 이벤트를 참고하자.

{: .note}
시작 중에 실행될 것으로 예상되는 작업은 `@PostConstruct`와 같은 스프링 컴포넌트 생명주기 콜백을 사용하는 대신 `커맨드라인러너(CommandLineRunner)` 및 `애플리케이션러너(ApplicationRunner)` 컴포넌트에 의해 실행되어야 한다.


#### Managing the Application Availability State
애플리케이션 컴포넌트는 `애플리케이션어베일러빌리티(ApplicationAvailability)` 인터페이스를 주입하고, 이에 대한 메소드를 호출하여 언제든지 현재 가용성 상태를 검색할 수 있다. 애플리케이션은 상태 업데이트를 수신하거나 애플리케이션 상태 업데이트를 하려는 경우가 많다.

예를 들어, 쿠버네티스 "exec Probe"가 이 파일을 볼 수 있도록 애플리케이션의 "준비성" 상태를 파일로 내보낼 수 있다:

`자바`
```java
    import org.springframework.boot.availability.AvailabilityChangeEvent;
    import org.springframework.boot.availability.ReadinessState;
    import org.springframework.context.event.EventListener;
    import org.springframework.stereotype.Component;

    @Component
    public class MyReadinessStateExporter {
        @EventListener
        public void onStateChange(AvailabilityChangeEvent<ReadinessState> event) {
            switch (event.getState()) {
                case ACCEPTING_TRAFFIC:
                    // /tmp/healthy 파일 생성
                    break;
                case REFUSING_TRAFFIC:
                    // /tmp/healthy 파일 제거
                    break;  
            }
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.availability.AvailabilityChangeEvent
    import org.springframework.boot.availability.ReadinessState
    import org.springframework.context.event.EventListener
    import org.springframework.stereotype.Component

    @Component
    class MyReadinessStateExporter {
        @EventListener
        fun onStateChange(event: AvailabilityChangeEvent<ReadinessState?>) {
            when (event.state) {
                ReadinessState.ACCEPTING_TRAFFIC -> {
                    // /tmp/healthy  파일 생성
                }
                ReadinessState.REFUSING_TRAFFIC -> {
                    // /tmp/healthy 파일 제거
                }
                else -> {
                    // ... 
                }
            } 
        }
    }
```

애플리케이션이 중단되어 복구할 수 없는 경우 애플리케이션 상태를 업데이트할 수도 있다:

`자바`
```java
    import org.springframework.boot.availability.AvailabilityChangeEvent;
    import org.springframework.boot.availability.LivenessState;
    import org.springframework.context.ApplicationEventPublisher;
    import org.springframework.stereotype.Component;
    
    @Component
    public class MyLocalCacheVerifier {
        private final ApplicationEventPublisher eventPublisher;
        public MyLocalCacheVerifier(ApplicationEventPublisher eventPublisher) {
            this.eventPublisher = eventPublisher;
        }

        public void checkLocalCache() {
            try {
                // ... 
            } catch (CacheCompletelyBrokenException ex) {
              AvailabilityChangeEvent.publish(this.eventPublisher, ex, LivenessState.BROKEN);
            }
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.availability.AvailabilityChangeEvent
    import org.springframework.boot.availability.LivenessState
    import org.springframework.context.ApplicationEventPublisher
    import org.springframework.stereotype.Component

    @Component
    class MyLocalCacheVerifier(private val eventPublisher: ApplicationEventPublisher) {
        fun checkLocalCache() {
            try {
                // ...
            } catch (ex: CacheCompletelyBrokenException) {
                AvailabilityChangeEvent.publish(eventPublisher, ex, LivenessState.BROKEN)
            }
        } 
    }
```

스프링 부트는 액츄에이터 헬스 엔드포인트를 통해 "활성" 및 "준비성"에 대한 쿠버네티스 HTTP 프로브를 제공한다. 다음 절에서 쿠버네티스에 스프링 부트 애플리케이션을 배포하는 방법에 대한 자세한 지침을 얻을 수 있다.


### 7.1.7. Application Events and Listeners
`컨텍스트리프레시이벤트(ContextRefreshedEvent)`와 같은 일반적인 스프링 프레임워크 이벤트 외에도 `스프링애플리케이션(SpringApplication)`은 몇 가지 추가 애플리케이션 이벤트를 보낸다.

***

`노트`

일부 이벤트는 실제로 `스프링애플리케이션(SpringApplication)`이 생성되기 전에 트리거되므로, 해당 이벤트에 대한 리스너를 `@Bean`으로 등록할 수 없다. `SpringApplication.addListeners(...)` 메소드 또는` SpringApplicationBuilder.listeners(...)` 메소드를 사용하여 등록할 수 있다.

애플리케이션 생성 방식에 관계없이 해당 리스너를 자동으로 등록하려면, 다음 예제처럼, 프로젝트에 `META-INF/spring.factories` 파일을 추가하고 `org.springframework.context.ApplicationListener` 키(key)를 사용하여 리스너를 참조할 수 있다:
```
    org.springframework.context.ApplicationListener=com.example.project.MyListener
```
***

애플리케이션이 실행될 때, 애플리케이션 이벤트는 다음 순서로 전송된다:
1. `애플리케이션스타팅이벤트(ApplicationStartingEvent)`는 실행 시작 시, 리스너 및 이니셜라이저(initializer) 등록을 제외한 모든 처리가 발생하기 전에 전송된다.
2. `애플리케이션인바이런먼트프리페어드이벤트(ApplicationEnvironmentPreparedEvent)`는 컨텍스트에서 사용할 환경이 알려졌지만 컨텍스트가 생성되기 전에 전송된다.
3. `애플리케이션컨텍스트이니셜라이즈이벤트(ApplicationContextInitializedEvent)`는 `애플리케이션컨텍스트(ApplicationContext)`가 준비되고 `애플리케이션컨텍스트이니셜라이저(ApplicationContextInitializers)`가 호출되었지만 빈 정의가 로드되기 전에 전송된다.
4. `애플리케이션프리페어드이벤트(ApplicationPreparedEvent)`는 새로고침(refresh)이 시작되기 직전 빈 정의가 로드된 후에 전송된다.
5. `애플리케이션스타트이벤트(ApplicationStartedEvent)`는 컨텍스트 새로고침 후 애플리케이션 및 커맨드라인 러너가 호출되기 전에 전송된다.
6. `LivenessState.CORRECT` 직후에 `어베일러빌리티체인지이벤트(AvailabilityChangeEvent)`가 전송되어 애플리케이션이 라이브로 간주됨을 나타낸다.
7. `애플리케이션레디이벤트(ApplicationReadyEvent)`는 애플리케이션 및 커맨드라인 러너가 호출된 후에 전송된다.
8. `어베일러빌리티체인지이벤트(AvailabilityChangeEvent)`는 `ReadinessState.ACCEPTING_TRAFFIC`과 함께 바로 전송되어 애플리케이션이 요청을 처리할 준비가 되었음을 나타낸다.
9. 시작 시 예외가 발생하면, `애플리케이션페일이벤트(ApplicationFailedEvent)`가 전송된다.

위 목록에는 `스프링애플리케이션(SpringApplication)`에 연결된 `스프링애플리케이션이벤트(SpringApplicationEvents)`만 포함되어 있다. 이 외에도 `애플리케이션프리페어드이벤트(ApplicationPreparedEvent)` 및 `애플리케이션스타트이벤트(ApplicationStartedEvent)` 다음 이벤트도 나타난다:

- `웹서버이니셜라이즈이벤트(WebServerInitializedEvent)`는 `웹서버(WebServer)`가 준비된 후 전송된다. `서블릿웹서버이니셜라이즈이벤트(ServletWebServerInitializedEvent)` 및 `리액티브웹서버이니셜라이즈이벤트(ReactiveWebServerInitializedEvent)`는 각각 서블릿 및 리액티브 변수다.
- `컨텍스트리프레시이벤트(ContextRefreshedEvent)`는 `애플리케이션컨텍스트(ApplicationContext)`가 새로고침(refreshed) 될 때 전송된다.

{: .note}
애플리케이션 이벤트를 사용할 필요가 없는 경우가 많지만 이벤트가 존재한다는 사실을 알아두면 편리할 수 있다. 내부적으로 스프링 부트는 이벤트를 사용하여 다양한 작업을 처리한다.

{: .note}
이벤트 리스너는 기본적으로 동일한 스레드에서 실행되므로 시간이 오래 걸릴 수 있는 작업을 실행해서는 안 된다. 대신 애플리케이션 및 커맨드라인 러너를 사용하자.

애플리케이션 이벤트는 스프링 프레임워크의 이벤트 퍼블리싱(publishing) 메커니즘을 사용하여 전송된다. 이 메커니즘의 일부는 하위 컨텍스트의 리스너에 퍼블리시된 이벤트가 모든 상위 컨텍스트의 리스너에도 퍼블리시되도록 보장한다. 결과적으로 애플리케이션이 스프링애플리케이션 인스턴스의 계층 구조를 사용하는 경우 리스너는 동일한 타입의 애플리케이션 이벤트에 대한 여러 인스턴스를 수신할 수 있다.

리스너가 컨텍스트에 대한 이벤트와 하위 컨텍스트에 대한 이벤트를 구별할 수 있도록 하려면, 애플리케이션 컨텍스트가 주입되도록 요청한 다음 주입된 컨텍스트를 이벤트 컨텍스트와 비교해야 한다. `애플리케이션컨텍스트어웨어(ApplicationContextAware)`를 구현하거나 리스너가 빈인 경우 `@Autowired`를 사용하여 컨텍스트를 주입할 수 있다.


### 7.1.8. Web Environment
`스프링애플리케이션(SpringApplication)`은 사용자를 대신하여 올바른 타입의 `애플리케이션컨텍스트(ApplicationContext)`를 생성하려고 시도한다. `웹어플리케이션타입(WebApplicationType)`을 결정하는 데 사용되는 알고리즘은 다음과 같다:
- 스프링 MVC가 존재하는 경우 `어노테이션컨피그서블릿웹서버애플리케이션컨텍스트(AnnotationConfigServletWebServerApplicationContext)`가 사용된다.
- 스프링 MVC가 없고 스프링 웹플럭스가 있는 경우 `어노테이션컨피그리액티브웹서버애플리케이션컨텍스트(AnnotationConfigReactiveWebServerApplicationContext)`가 사용된다.
- 그렇지 않으면, `어노테이션컨피그애플리케이션컨텍스트(AnnotationConfigApplicationContext)`가 사용된다.

이는 동일한 애플리케이션에서 스프링 MVC와 스프링 웹플럭스의 새로운 `웹클라이언트(WebClient)`를 사용하는 경우 기본적으로 스프링 MVC가 사용된다는 것을 의미한다. `setWebApplicationType(WebApplicationType)`을 호출하여 이를 쉽게 오버라이드할 수 있다.

`setApplicationContextFactory(...)`를 호출하여 사용되는 `애플리케이션컨텍스트(ApplicationContext)` 타입을 완전히 제어하는 ​​것도 가능하다.

{: .note}
JUnit 테스트에서 `스프링애플리케이션(SpringApplication)`을 사용할 때 `setWebApplicationType(WebApplicationType.NONE)`을 호출하는 것이 바람직한 경우가 있다.


### 7.1.9. Accessing Application Arguments
`SpringApplication.run(...)`에 전달된 애플리케이션 아규먼트에 접근해야 하는 경우 `org.springframework.boot.ApplicationArguments` 빈을 주입할 수 있다. 애플리케이션아규먼트(ApplicationArguments) 인터페이스는 다음 예제와 같이 `String[]` 아규먼트와 파싱된 `옵션` 및 `비옵션(non-option)` 아규먼트 모두에 대한 접근할 수 있다.

`자바`
```java
    import java.util.List;
    import org.springframework.boot.ApplicationArguments;
    import org.springframework.stereotype.Component;

    @Component
    public class MyBean {
        public MyBean(ApplicationArguments args) {
            boolean debug = args.containsOption("debug");
            List<String> files = args.getNonOptionArgs();

            if (debug) {
                System.out.println(files);
            }
            // "--debug logfile.txt"로 실행하면 ["logfile.txt"]가 표시된다.
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.ApplicationArguments
    import org.springframework.stereotype.Component

    @Component
    class MyBean(args: ApplicationArguments) {
        init {
            val debug = args.containsOption("debug")
            val files = args.nonOptionArgs
            if (debug) {
                println(files)
            }
            // "--debug logfile.txt"로 실행하면 ["logfile.txt"]가 표시된다.
        }
    }
```

{: .note}
스프링 부트는 또한 스프링 환경에 `커맨드라인프로퍼티소스(CommandLinePropertySource)`를 등록한다. 이를 통해 `@Value` 어노테이션을 사용하여 싱글 애플리케이션 아규먼트를 주입할 수도 있다.


### 7.1.10. Using the ApplicationRunner or CommandLineRunner
`스프링애플리케이션(SpringApplication)`이 시작된 후 특정 코드를 실행해야 하는 경우 `애플리케이션러너(ApplicationRunner)` 또는 `커맨드라인러너(CommandLineRunner)` 인터페이스를 구현할 수 있다. 두 인터페이스 모두 동일한 방식으로 작동하며 `SpringApplication.run(...)`이 완료되기 직전에 호출되는 `run` 메서드를 제공한다.

{: .note}
이 기능은 애플리케이션 시작 후 트래픽 수신을 시작하기 전에 실행해야 하는 작업에 매우 적합하다.

`커맨드라인러너(CommandLineRunner)` 인터페이스는 문자열 배열로 애플리케이션 아규먼트에 대한 접근를 제공하는 반면, `애플리케이션러너(ApplicationRunner)`는 앞에서 설명한 `애플리케이션아규먼트(ApplicationArguments)` 인터페이스를 사용한다. 다음 예에서는 `run` 메서드가 있는 `커맨드라인러너(CommandLineRunner)`를 보여준다:

`자바`
```java
    import org.springframework.boot.CommandLineRunner;
    import org.springframework.stereotype.Component;
    
    @Component
    public class MyCommandLineRunner implements CommandLineRunner {
        @Override
        public void run(String... args) {
            // 무엇인가 작동하는..
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.CommandLineRunner
    import org.springframework.stereotype.Component

    @Component
    class MyCommandLineRunner : CommandLineRunner {
        override fun run(vararg args: String) {
          // 무엇인가 작동하는..
        } 
    }
```

특정 순서로 호출되어야 하는 여러 `커맨드라인러너(CommandLineRunner)` 또는 `애플리케이션러너(ApplicationRunner)` 빈이 정의된 경우 `org.springframework.core.Ordered` 인터페이스를 추가로 구현하거나 `org.springframework.core.annotation.Order` 어노테이션을 사용할 수 있다.


### 7.1.11. Application Exit
각 `스프링애플리케이션(SpringApplication)`은 종료 시 `애플리케이션컨텍스트(ApplicationContext)`가 정상적(gracefully)으로 닫히도록 JVM에 종료 후크(hook)를 등록한다. 모든 표준 스프링 라이프사이클 콜백(예: DisposableBean 인터페이스 또는 @PreDestroy 어노테이션)을 사용할 수 있다.

게다가, `SpringApplication.exit()`가 호출될 때 특정 종료 코드를 반환하려는 경우, `org.springframework.boot.ExitCodeGenerator` 인터페이스를 구현할 수 있다. 그런 다음 이 종료 코드를 `System.exit()`에 전달하여 다음 예제와 같이 상태 코드로 반환할 수 있다:

```java
    import org.springframework.boot.ExitCodeGenerator;
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.context.annotation.Bean;

    @SpringBootApplication
    public class MyApplication {
        @Bean
        public ExitCodeGenerator exitCodeGenerator() {
            return () -> 42;
        }
      
        public static void main(String[] args) {
            System.exit(SpringApplication.exit(SpringApplication.run(MyApplication.class, args))); 
        }
    }
```

```kotlin
    import org.springframework.boot.ExitCodeGenerator
    import org.springframework.boot.SpringApplication
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.boot.runApplication
    import org.springframework.context.annotation.Bean
    import kotlin.system.exitProcess

    @SpringBootApplication
    class MyApplication {
        @Bean
        fun exitCodeGenerator() = ExitCodeGenerator { 42 }
    }
    
    fun main(args: Array<String>) {
        exitProcess(SpringApplication.exit(runApplication<MyApplication>(*args)))
    }
```

또한 `엑시트코드제너레이터(ExitCodeGenerator)` 인터페이스는 예외로 구현될 수 있다. 이러한 예외가 발생하면 스프링 부트는 구현된 `getExitCode()` 메서드에서 제공하는 종료 코드를 반환한다.

`엑시트코드제너레이터(ExitCodeGenerator)`가 두 개 이상인 경우 생성된 첫 번째의 0이 아닌 종료 코드가 사용된다. 제너레이터가 호출되는 순서를 제어하려면 `org.springframework.core.Ordered` 인터페이스를 추가로 구현하거나 `org.springframework.core.annotation.Order` 어노테이션을 사용하자.


### 7.1.12. Admin Features
`spring.application.admin.enabled` 프로퍼티를 지정하여 애플리케이션에 대한 관리 기능을 활성화할 수 있다. 이는 플랫폼 `MBeanServer`에 `SpringApplicationAdminMXBean`을 노출한다. 이 기능을 사용하여 스프링 부트 애플리케이션을 원격으로 관리할 수 있다. 이 기능은 모든 서비스 래퍼 구현에도 유용할 수 있다.

{: .note}
애플리케이션이 실행 중인 HTTP 포트를 알고 싶다면, `local.server.port` 키를 사용하여 프로퍼티를 가져오자.


### 7.1.13. Application Startup tracking
애플리케이션 시작 중에 `스프링애플리케이션(SpringApplication)`과 `애플리케이션컨텍스트(ApplicationContext)`는 애플리케이션 라이프사이클, 빈 라이프사이클 또는 심지어 애플리케이션 이벤트 처리와 관련된 많은 작업을 수행한다. `애플리케이션스타트업(ApplicationStartup)`을 사용하면 [스프링 프레임워크를 사용하여 `스타트업스텝(StartupStep)` 객체](https://docs.spring.io/spring-framework/reference/core/beans/context-introduction.html#context-functionality-startup)를 사용하여 애플리케이션 시작 순서를 추적할 수 있다. 이 데이터는 프로파일링 목적으로 수집되거나 애플리케이션 시작 프로세스를 더 잘 이해하기 위해 수집할 수 있다.

`스프링애플리케이션(SpringApplication)` 인스턴스를 설정할 때 `애플리케이션스타트업(ApplicationStartup)` 구현을 선택할 수 있다. 예를 들어 `버퍼링애플리케이션스타트업(BufferingApplicationStartup)`을 사용하려면 다음과 같이 작성할 수 있다:

`자바`
```java
    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.boot.context.metrics.buffering.BufferingApplicationStartup;

    @SpringBootApplication
    public class MyApplication {
        public static void main(String[] args) {
            SpringApplication application = new SpringApplication(MyApplication.class);
            application.setApplicationStartup(new BufferingApplicationStartup(2048));
            application.run(args);
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.boot.context.metrics.buffering.BufferingApplicationStartup
    import org.springframework.boot.runApplication

    @SpringBootApplication
    class MyApplication

    fun main(args: Array<String>) {
        runApplication<MyApplication>(*args) {
            applicationStartup = BufferingApplicationStartup(2048)
        }
    }
```

사용 가능한 첫 번째 구현체인 `플라이트레코더애플리케이션스타트업(FlightRecorderApplicationStartup)`은 스프링 프레임워크에서 제공된다. 이는 자바 플라이트 레코더 절에 스프링 관련 시작 이벤트를 추가하며 애플리케이션을 프로파일링하고 스프링 컨텍스트 라이프사이클을 JVM 이벤트(할당, GC, 클래스 로딩 등)와 연관시키는 데 사용된다. 일단 구성되면 플라이트 레코더가 활성화된 상태에서 애플리케이션을 실행하여 데이터를 기록할 수 있다.

```
    $ java -XX:StartFlightRecording:filename=recording.jfr,duration=10s -jar demo.jar
```

스프링 부트는 `버퍼링애플리케이션스타트업(BufferingApplicationStartup)` 변수과 함께 제공된다. 이 구현체는 시작 단계를 버퍼링하고 이를 외부 측정 시스템으로 배출하기 위한 것이다. 애플리케이션은 모든 컴포넌트에서  `버퍼링애플리케이션스타트업(BufferingApplicationStartup)` 타입의 빈을 요청할 수 있다.


스프링 부트는 이 정보를 JSON 문서로 제공하는 [스타트업 엔드포인트](https://docs.spring.io/spring-boot/docs/3.1.1/actuator-api/htmlsingle/#startup)를 노출하도록 구성할 수도 있다.


## 7.2. Externalized Configuration
스프링 부트를 사용하면 구성을 외부화하여 다양한 환경에서 동일한 애플리케이션 코드로 작업할 수 있다. 자바 프로퍼티스 파일, YAML 파일, 환경 변수, 커맨드라인 아규먼트를 비롯한 다양한 외부 구성 소스를 사용할 수 있다.

프로퍼티 값은 `@Value` 어노테이션을 사용하여 빈에 직접 주입하거나 스프링의 환경 추상화를 통해 접근하거나 `@ConfigurationProperties`를 통해 구조화된 객체에 바인딩할 수 있다.

스프링 부트는 값 오버라이드를 허용하도록 설계된 특별한 `PropertySource` 순서를 사용한다. 이후 프로퍼티 소스는 이전 프로퍼티 소스에서 정의된 값을 오버라이드할 수 있다. 소스는 다음 순서를 고려한다:
1. 기본 프로퍼티(`SpringApplication.setDefaultProperties` 설정을 통해 지정).
2. `@Configuration` 클래스의 `@PropertySource` 어노테이션. 이러한 프로퍼티 소스는 애플리케이션 컨텍스트가 새로고침될 때까지 환경에 추가되지 않는다. 새로고침이 시작되기 전에 읽혀지는 `logging.*` 및 `spring.main.*`과 같은 특정 프로퍼티를을 구성하기에는 너무 늦다.
3. 구성 데이터(예: `application.properties` 파일)
4. `random.*` 프로퍼티을 갖는 `랜덤벨류프로퍼티소스(RandomValuePropertySource)`이다.
5. OS 환경 변수
6. 자바 시스템 프로퍼티스(`System.getProperties()`).
7. `java:comp/env`의 JNDI 애트리뷰트.
8. `서블릿컨텍스트(ServletContext)`의 초기화 파라미터.
9. `서블릿컨피그(ServletConfig)`의 초기화 파라미터.
10. `SPRING_APPLICATION_JSON` 프로퍼티의 (환경 변수 또는 시스템 프로퍼티에 포함된 인라인 JSON)
11. 커맨드라인 아규먼트
12. 테스트의 프로퍼티스 애트리뷰트. `@SpringBootTest` 및 애플리케이션의 특정 부분을 테스트하기 위한 테스트 어노테이션에서 사용할 수 있다.
13. 테스트의 `@DynamicPropertySource` 어노테이션.
14. 테스트의 `@TestPropertySource` 어노테이션.
15. `데브툴즈(devtools)`가 활성화된 경우 `$HOME/.config/spring-boot` 디렉터리에 있는 `Devtools` 글로벌 설정 프로퍼티.

구성 데이터 파일은 다음 순서를 고려한다:
1. jar 내부에 패키지된 애플리케이션 프로퍼티(`application.properties` 및 `YAML` 변수)
2. jar 내부에 패키지된 프로필(Profile)별 애플리케이션 프로퍼티스(`application-{profile}.properties` 및 `YAML` 변수)
3. 패키지된 jar 외부의 애플리케이션 프로퍼티스(`application.properties` 및 `YAML` 변수)
4. 패키지된 jar 외부의 프로필(Profile)별 애플리케이션 프로퍼티스(`application-{profile}.properties` 및 `YAML` 변수)

{: .note}
전체 애플리케이션에 대해 하나의 포맷을 사용하는 것이 좋다. `.properties` 및 `YAML` 포맷 모두 포함된 구성 파일이 동일한 위치에 있는 경우 `.properties`가 우선 적용된다.

{: .note}
시스템 프로퍼티 대신 환경 변수를 사용하는 경우, 대부분의 운영 체제에서는 마침표로 구분된 키 이름을 허용하지 않지만 대신 밑줄을 사용할 수 있다(예: `spring.config.name` 대신 `SPRING_CONFIG_NAME`). 자세한 내용은 환경 변수 바인딩을 참고하자.

{: .note}
애플리케이션이 서블릿 컨테이너 또는 애플리케이션 서버에서 실행되는 경우 JNDI 프로퍼티스(`java:comp/env`) 또는 서블릿 컨텍스트 초기화 파라미터를 환경 변수 또는 시스템 프로퍼티 대신 사용할 수 있다.

구체적인 예를 제공하기 위해 다음 예와 같이 `name` 프로퍼티을 사용하는 `@Component`를 개발한다고 가정한다:

`자바`
```java
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.stereotype.Component;

    @Component
    public class MyBean {
        @Value("${name}")
        private String name;

        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.beans.factory.annotation.Value
    import org.springframework.stereotype.Component
    
    @Component
    class MyBean {
        @Value("\${name}")
        private val name: String? = null
        // ... 
    }
```
애플리케이션 클래스 패스(예: jar 내부)에는 `name`에 대한 적절한 프로퍼티 값을 제공하는 `application.properties` 파일이 있다. 새 환경에서 실행할 때 이름을 오버라이드하는 jar 외부에 `application.properties` 파일을 제공할 수 있다. 일회성 테스트의 경우 특정 커맨드라인 스위치(예: `java -jar app.jar --name="Spring"`)를 사용하여 시작할 수 있다.

{: .note}
`env` 및 `configprops` 엔드포인트는 프로퍼티에 특정 값이 있는 이유를 확인하는 데 유용할 수 있다. 이러한 두 엔드포인트를 사용하여 예기치 않은 프로퍼티 값을 진단할 수 있다. 자세한 내용은 "Production ready features" 절을 참고하자.


### 7.2.1. Accessing Command Line Properties
기본적으로 `스프링애플리케이션(SpringApplication)`은 모든 커맨드라인 옵션 아규먼드(즉, `--server.port=9000`과 같이 `--`로 시작하는 아규먼트)를 프로퍼티로 변환하고 이를 스프링 환경에 추가한다. 앞에서 언급한 것처럼 커맨드라인 프로퍼티는 항상 파일 기반 프로퍼티 소스보다 우선한다.

환경에 커맨드라인 프로퍼티를 추가하지 않으려면 `SpringApplication.setAddCommandLineProperties(false)`를 사용하여 비활성화할 수 있다.


### 7.2.2. JSON Application Properties
환경 변수 및 시스템 프로퍼티에는 일부 프로퍼티명을 사용할 수 없는 제한이 있다. 이를 돕기 위해 스프링 부트를 사용하면 프로퍼티 블록을 싱글 JSON 구조로 인코딩할 수 있다.

애플리케이션이 시작되면 `spring.application.json` 또는 `SPRING_APPLICATION_JSON` 프로퍼티가 파싱되어 환경에 추가된다.

예를 들어, `SPRING_APPLICATION_JSON` 프로퍼티는 UN*X 셸의 커맨드라인에 환경 변수로 제공될 수 있다:
```sh
    $ SPRING_APPLICATION_JSON='{"my":{"name":"test"}}' java -jar myapp.jar
```

앞의 예에서는, 스프링 환경에서 `my.name=test`로 끝난다.

동일하게 JSON을 시스템 프로퍼티로 제공할 수도 있다:
```sh
    $ java -Dspring.application.json='{"my":{"name":"test"}}' -jar myapp.jar
```

또는 커맨드라인 아규먼트를 사용하여 JSON을 제공할 수 있다:
```sh
    $ java -jar myapp.jar --spring.application.json='{"my":{"name":"test"}}'
```

클래식 애플리케이션 서버(Application Server)에 배포하는 경우 `java:comp/env/spring.application.json`이라는 JNDI 변수를 사용할 수도 있다.

{: .note}
JSON의 `null` 값이 프로퍼티 소스에 추가되지만, `프로퍼티소스프로퍼티리졸버(PropertySourcesPropertyResolver)`는 `null` 프로퍼티를 누락된 값으로 처리한다. 이는 JSON이 `null` 값을 사용하여 하위 프로퍼티 소스의 프로퍼티를 오버라이드할 수 없음을 의미한다.


### 7.2.3. External Application Properties
스프링 부트는 애플리케이션이 시작될 때 아래 위치에서 `application.properties` 및 `application.yaml` 파일을 자동으로 찾아 로드한다:
1. 클래스패스
    1. 루트 클래스패스
    2. `/config` 패키지 클래스패스
2. 디렉토리
    1. 디렉토리
    2. 디렉토리의 `config/` 하위디렉토리 
    3. `config/` 하위 디렉터리의 바로 하위 디렉터리

목록은 우선 순위에 따라 정렬된다(낮은 항목의 값이 이전 항목보다 우선됨).
로드된 파일 문서는 스프링 환경에 `프로퍼티소스(PropertySource)`로 추가된다.

애플리케이션의 구성 파일명이 마음에 들지 않으면 `spring.config.name` 환경 프로퍼티를 지정하여 다른 파일명으로 전환할 수 있다. 예를 들어 `myproject.properties` 및 `myproject.yaml` 파일을 찾으려면 다음과 같이 애플리케이션을 실행할 수 있다:
```sh
    $ java -jar myproject.jar --spring.config.name=myproject
```

`spring.config.location` 환경 프로퍼티를 사용하여 위치를 참조할 수도 있다. 이 프로퍼티는 확인할 위치가 하나 이상일 경우 쉼표로 구분된 목록을 받을 수 있다.

다음 예에서는 두 개의 개별 파일을 지정하는 방법을 보여준다:
```sh
    $ java -jar myproject.jar --spring.config.location=\
        optional:classpath:/default.properties,\
        optional:classpath:/override.properties
```

{: .note}
`optional:` 접두사를 사용하기: 위치는 옵셔널이고 위치가 없어도 괜찮을 경우.

{: .warning}
`spring.config.name`, `spring.config.location` 및 `spring.config.additional-location`은 로드해야 할 파일을 결정하기 위해 초기에 사용된다. 이는 환경 프로퍼티(일반적으로 OS 환경 변수, 시스템 프로퍼티 또는 커맨드라인 아규먼트)으로 정의되어야 한다.

`spring.config.location`에 파일이 아닌 디렉터리가 포함되어 있으면 `/`로 끝나야 한다. 런타임 시 로드되기 전에 `spring.config.name`에서 생성된 이름이 추가된다. `spring.config.location`에 지정된 파일을 직접 가져온다.

{: .note}
프로필별(profile) 파일을 확인하기 위해 디렉터리 및 파일 위치 값도 모두 확장된다. 예를 들어 `classpath:myconfig.properties`의 `spring.config.location`이 있는 경우 적절한 `classpath:myconfig- <profile>.properties` 파일이 로드되는 것을 볼 수 있다.

대부분의 상황에서, 추가하는 각 `spring.config.location` 항목은 싱글 파일이나 디렉터리를 참조한다. 위치는 정의된 순서대로 처리되며, 이후 위치는 이전 위치의 값을 오버라이드할 수 있다.

위치 설정이 복잡하면서 프로필별 구성 파일을 사용하는 경우 스프링 부트가 그룹화 방법을 알 수 있도록 추가 힌트를 제공해야 할 수도 있다. 위치 그룹은 모두 동일한 레벨로 간주되는 위치 모음이다. 예를 들어 모든 클래스패스의 위치를 그룹화할 수 있다. 위치 그룹 내의 항목은 ;로 구분되어야 한다. 자세한 내용은 "프로필별 파일" 절의 예를 참고하자.

`spring.config.location`을 사용하여 구성된 위치는 기본 위치를 대체한다. 예를 들어, `spring.config.location`이 `optional:classpath:/custom-config/,optional:file:./custom-config/` 값으로 구성된 경우 고려되는 전체 위치 세트는 다음과 같다:
1. `optional:classpath:custom-config/`
2. `optional:file:./custom-config/`

위치를 바꾸는 대신 위치를 추가하려는 경우 `spring.config.additional-location`을 사용할 수 있다. 추가 위치에서 로드된 프로퍼티는 기본 위치의 프로퍼티를 오버라이드할 수 있다. 예를 들어, `spring.config.additional-location`이 `optional:classpath:/custom-config/,optional:file:./custom-config/` 값으로 구성된 경우 고려되는 전체 위치 세트는 다음과 같다:
1. `optional:classpath:/;optional:classpath:/config/`
2. `optional:file:./;optional:file:./config/;optional:file:./config/*/ `
3. `optional:classpath:custom-config/`
4. `optional:file:./custom-config/`

This search ordering lets you specify default values in one configuration file and then selectively override those values in another. You can provide default values for your application in application.properties (or whatever other basename you choose with spring.config.name) in one of the default locations. These default values can then be overridden at runtime with a different file located in one of the custom locations.

이 검색 순서를 사용하면 한 구성 파일에서 기본값을 지정한 다음 다른 구성 파일에서 해당 값을 선택적으로 오버라이드할 수 있다. 기본 위치 중 하나에 있는 `application.properties`(또는 `spring.config.name`으로 선택한 다른 이름)에 애플리케이션의 기본값을 제공할 수 있다. 그러면 이러한 기본값은 런타임 시 커스텀 위치 중 하나에 있는 다른 파일로 오버라이드될 수 있다.

#### Optional Locations
기본적으로, 지정된 구성 데이터 위치가 없으면 스프링 부트는 `컨피그데이터로케이션낫파운드익셉션(ConfigDataLocationNotFoundException)`을 발생시키고 애플리케이션이 시작되지 않는다.

위치를 지정하고 싶지만 위치가 항상 존재하지 않더라도 상관없는 경우 optional: 접두사를 사용할 수 있다. `spring.config.location` 및 `spring.config.additional-location` 프로퍼티는 물론 `spring.config.import` 선언과 함께 이 접두사를 사용할 수 있다.

예를 들어, `spring.config.import`에 `option:file:./myconfig.properties`를 할당하면 `myconfig.properties` 파일이 누락된 경우에도 애플리케이션을 시작할 수 있다.

모든 `컨피그데이터로케이션낫파운드익셉션(ConfigDataLocationNotFoundException)`을 무시하고 항상 애플리케이션을 계속 시작하려면 `spring.config.on-not-found` 프로퍼티를 사용할 수 있다. `SpringApplication.setDefaultProperties(...)`를 사용하거나 시스템/환경 변수를 사용하여 무시하도록 값을 설정한다.


#### Wildcard Locations
구성 파일 위치의 마지막 패스 세그먼트에 `*` 문자가 포함되어 있으면, 와일드카드 위치로 간주한다. 구성이 로드되면 와일드카드가 확장되어 하위 디렉터리도 검사한다. 와일드카드 위치는 구성 프로퍼티의 소스가 여러 개 있는 쿠버네이티스와 같은 환경에서 특히 유용하다.

예를 들어, 일부 레디스 구성과 일부 MySQL 구성이 있는 경우 두 구성 부분을 별도로 유지하면서 둘 다 `application.properties` 파일에 존재하도록 할 수 있다. 이로 인해 `/config/redis/application.properties` 및 `/config/mysql/application.properties`와 같은 서로 다른 위치에 두 개의 별도 `application.properties` 파일이 마운트될 수 있습니다. 이러한 경우 와일드카드 위치가 config/*/이면 두 파일이 모두 처리된다.

기본적으로, 스프링 부트는 기본 검색 위치에 `config/*/`를 포함한다. 이는 jar 외부의 `/config` 디렉토리의 모든 하위 디렉토리 검색을 의미한다.

`spring.config.location` 및 `spring.config.additional-location` 프로퍼티를 사용하여 와일드카드 위치를 직접 사용할 수 있다.

{: .note}
와일드카드 위치에는 `*` 하나만 포함되어야 하며, 디렉터리 검색 위치의 경우 `*/`로 끝나야 하고, 파일 검색 위치의 경우 `*/<filename>`으로 끝나야 한다. 와일드카드가 있는 위치는 절대 경로에서 알파벳순으로 정렬된다.

{: .note}
와일드카드 위치는 외부 디렉터리에서만 작동한다. `classpath:` 위치에는 와일드카드를 사용할 수 없다.


#### Profile Specific Files
애플리케이션 프로퍼티 파일뿐만 아니라, 스프링 부트는 명명 규칙 `application-{profile}`을 사용하여 프로필별 파일 로드를 시도한다. 예를 들어, 애플리케이션이 `prod`라는 프로필을 활성화하고, YAML 파일을 사용하는 경우 `application.yaml`과 `application-prod.yaml`이 모두 고려된다.

프로필별 프로퍼티는 표준 `application.properties`와 동일한 위치에서 로드되며, 프로필별 파일은 항상 특정되지 않은 파일보다 우선시 된다. 여러 프로필이 지정된 경우 최후 승리 전략(last-wins strategy)이 적용된다. 예를 들어 `prod`,`live` 프로필이 `spring.profiles.active` 프로퍼티에 의해 지정되면 `application-prod.properties`의 값은 `application-live.properties`의 값으로 오버라이드될 수 있다.

***
`노트`

최후 승리 전략은 위치(location) 그룹 레벨에서 적용된다. `classpath:/cfg/,classpath:/ext/`로 설정된 `spring.config.location`에는 `classpath:/cfg/;classpath:/ext/`과 같은 오버라이드 규칙이 없다.


예를 들어, 위의 `prod`,`live` 예제를 계속하면 다음 파일이 있을 수 있다:

```
    /cfg
        application-live.properties
    /ext
        application-live.properties
        application-prod.properties
```

`spring.config.location`이 `classpath:/cfg/,classpath:/ext/`인 경우 모든 `/ext` 파일보다 먼저 모든 `/cfg` 파일을 처리한다:
1. `/cfg/application-live.properties`
2. `/ext/application-prod.properties`
3. `/ext/application-live.properties`

대신 `classpath:/cfg/;classpath:/ext/`(`;` 구분 기호 사용)가 있는 경우 `/cfg` 및 `/ext`를 동일한 레벨에서 처리한다:
1. `/ext/application-prod.properties`
2. `/cfg/application-live.properties`
3. `/ext/application-live.properties`
***

환경에는 활성 프로필이 설정되지 않은 경우 사용되는 기본 프로필 세트(기본적으로 [default])가 있다. 즉, 명시적으로 활성화된 프로필이 없으면 `application-default`의 프로퍼티가 고려된다.

{: .note}
프로퍼티 파일은 한 번만 로드된다. 이미 프로필별 프로퍼티 파일을 직접 가져온 경우에는 두 번째로 가져오지 않는다.


#### Importing Additional Data
애플리케이션 프로퍼티는 `spring.config.import` 프로퍼티을 사용하여 다른 위치에서 추가 구성 데이터를 가져올 수 있다. 임포트(Imports)는 발견된 대로 처리되며, 임포트를 요청한 문서 바로 아래에 삽입될 추가 문서로 처리된다.

예를 들어, 클래스패스 `application.properties` 파일이 다음과 같다:

`프로퍼티스(Properties)`
``` 
    spring.application.name=myapp
    spring.config.import=optional:file:./dev.properties
```

`Yaml`
```yaml
    spring:
        application:
            name: "myapp"
        config:
            import: "optional:file:./dev.properties"
```

그러면 현재 디렉터리에 `dev.properties` 파일이 있는 경우 임포트가 트리거된다. 가져온 `dev.properties`의 값은 임포트를 요청하고 트리거한 파일보다 우선한다. 위의 예에서 `dev.properties`는 `spring.application.name`을 다른 값으로 오버라이드할 수 있다.

임포트는 선언 횟수에 상관없이 한 번만 가져와 진다. 임포트가 properties/yaml 파일 내에서 정의되는 순서는 중요하지 않다. 예를 들어, 아래 두 예는 동일한 결과를 보여준다:

`프로퍼티스(Properties)`
```
    spring.config.import=my.properties
    my.property=value
```

`Yaml`
```yaml
    spring:
        config:
            import: "my.properties"
    my:
        property: "value"
```

`프로퍼티스(Properties)`
``` 
    my.property=value
    spring.config.import=my.properties
```

`Yaml`
```yaml
    my:
        property: "value"
    spring:
        config:
            import: "my.properties"
```

위의 두 예제에서 `my.properties` 파일의 값은 해당 임포트를 트리거한 파일보다 우선시 된다.

단일 `spring.config.import` 키 아래에 여러 위치를 지정할 수 있다. 위치는 정의된 순서대로 처리되며 이후 임포트가 우선 적용됩니다.

{: .note}
해당하는 경우 프로필별 변수도 임포트 대상으로 고려된다. 위의 예에서는 `my.properties`와 `my-<profile>.properties` 변수를 모두 가져온다.

***

`TIP`

스프링 부트에는 다양한 위치를 지원할 수 있는 플러그형 API가 있다. 기본적으로 자바 프로퍼티스, YAML 및 "구성 트리"를 가져올 수 있다.

서드파티 jar는 추가 기술에 대한 지원을 한다. 예를 들어 `Consul`, 아파치 주키퍼(ZooKeepe)r 또는 넷플릭스 Archaius와 같은 외부 저장소의 구성 데이터를 상상할 수 있다.

커스텀 위치를 ​​지원하려면, `org.springframework.boot.context.config` 패키지의 `컨피그데이터로케이션리졸버(ConfigDataLocationResolver)` 및 `컨피스데이터로더(ConfigDataLoader)` 클래스를 참고하자.
***

#### Importing Extensionless Files
일부 클라우드 플랫폼은 볼륨 마운트 파일에 파일 확장자를 추가할 수 없다. 이러한 확장자가 없는 파일을 가져오려면 스프링 부트에 힌트를 제공하여 로드 방법을 알 수 있도록 해야 한다. 대괄호 안에 확장 힌트를 넣으면 된다.

예를 들어, yaml로 임포트하려는 `/etc/config/myconfig` 파일이 있다고 가정하자. 다음 예제의 `application.properties`에서 가져올 수 있다:

`프로퍼티스(Properties)`
``` 
    spring.config.import=file:/etc/config/myconfig[.yaml]
```

`Yaml`
```yaml
    spring:
        config:
            import: "file:/etc/config/myconfig[.yaml]"
```


####  Using Configuration Trees
클라우드 플랫폼(예: 쿠버네티스)에서 애플리케이션을 실행할 때 플랫폼이 제공하는 구성 값을 읽어야 하는 경우가 많다. 이러한 목적으로 환경 변수를 사용하는 것은 드문 일이 아니지만, 특히 값을 비밀로 유지해야 하는 경우에는 단점이 있을 수 있다.

환경 변수의 대안으로, 이제 많은 클라우드 플랫폼에서 구성을 탑재된 데이터 볼륨에 매핑할 수 있다. 예를 들어 쿠버네티스는 `컨피그맵(ConfigMap)`과 `시크릿(Secret)`을 모두 볼륨 마운트할 수 있다.

사용할 수 있는 두 가지 일반적인 볼륨 마운트 패턴이 있다:
1. 싱글 파일에는 전체 프로퍼티 세트(일반적으로 YAML로 작성됨)가 포함되어 있다.
2. 여러 파일이 디렉터리 트리에 기록되며, 파일 이름은 '키'가 되고 내용은 '값'이 된다.

첫 번째 경우, 위에서 설명한 대로 `spring.config.import`를 사용하여 YAML 또는 프로퍼티 파일을 직접 가져올 수 있다. 두 번째 경우에는 스프링 부트가 모든 파일을 프로퍼티로 노출해야 한다는 것을 알 수 있도록 `configtree:` 접두사를 사용해야 한다.

예를 들어 쿠버네티스가 다음 볼륨을 마운트했다고 가정해 보자.
```
    etc/ 
        config/
        myapp/
            username
            password
```
사용자명 파일의 내용은 컨피그 값(config value)이고 비밀번호의 내용은 시크릿(secret)이다.

이러한 프로퍼티를 가져오려면, `application.properties` 또는 `application.yaml` 파일에 다음 내용을 추가하면 된다.

`프로퍼티스(Properties)`
``` 
    spring.config.import=optional:configtree:/etc/config/
```

`Yaml`
```yaml
    spring:
        config:
            import: "optional:configtree:/etc/config/"
```

그런 다음 일반적인 방법으로 환경에서 `myapp.username` 및 `myapp.password` 프로퍼티스에 접하거나 주입할 수 있다.

{: .note}
구성 트리(Configuration tree) 아래의 폴더가 프로퍼티명을 형성한다. 위의 예에서 사용자 이름과 비밀번호로 프로퍼티에 접근하려면 `spring.config.import`를 `optional:configtree:/etc/config/myapp`으로 설정할 수 있다.

{: .note}
점 표기법이 있는 파일명도 올바르게 매핑된다. 예를 들어 위의 예제에서 `/etc/config`에 `myapp.username`이라는 파일이 있으면 환경에 `myapp.username` 프로퍼티가 생성된다.

{: .note}
구성 트리 값은 예상되는 내용에 따라 `String` 및 `byte[]` 타입 모두에 바인딩될 수 있다.

동일한 상위 폴더에서 가져올 구성 트리가 여러 개 있는 경우 와일드카드 단축키를 사용할 수 있다. `/*/`로 끝나는 모든 `configtree:` 위치는 모든 하위 항목을 구성 트리로 가져온다.

예를 들어 다음과 같은 볼륨이 있다고 가정하자:
```
    etc/ 
        config/
        dbconfig/
            db/
                username
                password
        mqconfig/
            mq/ 
                username
                password
```

`configtree:/etc/config/*/`를 임포트 위치로 사용할 수 있다.

`프로퍼티스(Properties)`
``` 
    spring.config.import=optional:configtree:/etc/config/*/
```

`Yaml`
```yaml
    spring:
        config:
            import: "optional:configtree:/etc/config/*/"
```

그러면 `db.username`, `db.password`, `mq.username` 및 `mq.password` 프로퍼티가 추가된다.

{: .note}
와일드카드를 사용하여 로드된 디렉터리는 알파벳순으로 정렬된다. 다른 순서가 필요한 경우 각 위치를 별도의 임포트로 나열해야 한다.

구성 트리는 도커 시크릿에도 사용할 수 있다. 도커 스웜(Swarm) 서비스에 시크릿에 대한 접근 권한이 부여되면 해당 시크릿이 컨테이너에 탑재된다. 예를 들어, `db.password`라는 시크릿이 `/run/secrets/` 위치에 마운트된 경우 다음 내용을 사용하여 스프링 환경에서 `db.password`를 사용할 수 있다:

`프로퍼티스(Properties)`
``` 
    spring.config.import=optional:configtree:/run/secrets/
```

`Yaml`
```yaml
    spring:
        config:
            import: "optional:configtree:/run/secrets/"
```

#### Property Placeholders
`application.properties` 및 `application.yaml`의 값은 사용 시 기존 환경을 통해 필터링되므로 이미 존재하는 값(예: 시스템 프로퍼티 또는 환경 변수)을 다시 참조할 수 있다. 표준 ${name} 프로퍼티-자리 표시자(placeholder) 문법은 값 내 어디에서나 사용할 수 있다. 프로퍼티 자리 표시자는 프로퍼티명에서 기본값을 구분하기 위해 :을 사용하여 기본값을 지정할 수도 있다(예: ${name:default}).

기본값이 있거나 없는 자리 표시자의 사용은 다음 예재에 나와 있다.

`프로퍼티스(Properties)`
``` 
    app.name=MyApp
    app.description=${app.name} is a Spring Boot application written by ${username:Unknown}
```

`Yaml`
```yaml
  app:
    name: "MyApp"
    description: "${app.name} is a Spring Boot application written by ${username:Unknown}"
```

`username` 프로퍼티가 다른 곳에서 설정되지 않았다고 가정하면 `app.description`의 값은 MyApp is a Spring Boot application written by Unknown이 된다.

***
`노트`

항상 표준 포맷(소문자만 사용하는 케밥 케이스)을 사용하여 자리 표시자에서 프로퍼티명을 참조해야 한다. 이렇게 하면 스프링 부트가 `@ConfigurationProperties` 바인딩할 때와 동일한 로직를 사용할 수 있다.

예를 들어 `${demo.item-price}`는 `application.properties` 파일에서 `demo.item-price` 및 `demo.itemPrice` 양식을 선택하고 시스템 환경에서 `DEMO_ITEMPRICE`를 선택한다. 대신 `${demo.itemPrice}`를 사용한 경우, `deco.item-price` 및 `DEMO_ITEMPRICE`는 고려되지 않는다.
***

{: .note}
또한 이 기술을 사용하여 기존 스프링 부트 프로퍼티의 "짧은" 변수을 만들 수도 있다. 자세한 내용은 '짧은' 커맨드라인 아규먼트 사용 방법을 참고하자.


#### Working With Multi-Document Files
스프링 부트를 사용하면 파일을 각각 독립적으로 추가되는 여러 논리적 문서로 분할할 수 있다. 문서는 위에서 아래로 순서대로 처리된다. 최신 문서는 이전 문서에서 정의된 프로퍼티를 오버라이드할 수 있다.

`application.yaml` 파일의 경우 표준 `YAML` 다중 문서 문법이 사용된다. 세 개의 연속된 하이픈은 한 문서의 끝과 다음 문서의 시작을 나타낸다.

예를 들어 다음 파일에는 두 개의 논리적 문서가 있다:
```yaml
spring:
    application:
        name: "MyApp"
---
spring:
    application:
        name: "MyCloudApp"
    config:
        activate:
            on-cloud-platform: "kubernetes"
```

`application.properties` 파일의 경우 특수 #--- 또는 !--- 주석을 사용하여 문서 분할을 표시한다.
```
spring.application.name=MyApp
#---
spring.application.name=MyCloudApp
spring.config.activate.on-cloud-platform=kubernetes
```

{: .note}
프로퍼티 파일 구분기호(separator)에는 선행 공백이 없어야 하며 정확히 3개의 하이픈 문자가 있어야 한다. 구분 기호 바로 앞과 뒤의 줄은 동일한 주석 접두사가 아니어야 한다.

{: .note}
다중 문서 프로퍼티 파일은 `spring.config.activate.on-profile`과 같은 `activation` 프로퍼티과 함께 사용되는 경우가 많다. 자세한 내용은 다음 절을 참고하자.

{: .warning}
`@PropertySource` 또는 `@TestPropertySource` 어노테이션을 사용하여 다중 문서 프로퍼티 파일을 로드할 수 없다.


#### Activation Properties
특정 조건이 충족될 때 특정 프로퍼티스 세트만 활성화하는 것이 유용한 경우가 있다. 예를 들어 특정 프로필이 활성화된 경우에만 관련된 프로퍼티가 있을 수 있다.

`spring.config.activate.*`를 사용하여 프로퍼티 문서를 조건부로 활성화할 수 있다.

다음 활성화 프로퍼티를 사용할 수 있다:

테이블 5. 활성화 프로퍼티스

|프로퍼티|설명|
|---|---|
|`on-profile`|문서가 활성화되려면 일치해야 하는 프로필 표현식이다.|
|`on-cloud-platform`|문서를 활성화하기 위해 클라우드플랫폼(CloudPlatform)을 감지해야 한다.|

예를 들어 다음은 쿠버네티스에서 실행될 때 두 번째 문서가 활성화되고, "prod" 또는 "staging" 프로필이 활성화될 때 활성화되도록 지정한다:

`프로퍼티스(Properties)`
``` 
    myprop=always-set
    #---
    spring.config.activate.on-cloud-platform=kubernetes
    spring.config.activate.on-profile=prod | staging
    myotherprop=sometimes-set
```

`Yaml`
```yaml
    myprop: "always-set"
    --- 
    spring:
        config:
            activate:
                on-cloud-platform: "kubernetes"
                on-profile: "prod | staging"
    myotherprop: "sometimes-set"
```


### 7.2.4. Encrypting Properties
스프링 부트는 프로퍼티 값 암호화에 대한 지원을 제공하지 않지만 스프링 `환경(Environment)`에 포함된 값을 수정하는 데 필요한 후크 포인트를 제공한다. `인바이런먼트포스트프로세서(EnvironmentPostProcessor)` 인터페이스를 사용하면 애플리케이션이 시작되기 전 `환경(Environment)`를 조작할 수 있다. 자세한 내용은 [Customize the Environment or ApplicationContext Before It Starts]()을 참고하자.

크리덴셜(credentials)과 비밀번호를 안전하게 저장하는 방법이 필요한 경우, 스프링 클라우드 볼트(Vault) 프로젝트는 하시코프 볼트(HashiCorp Vault)에 외부화된 구성을 저장하기 위한 지원을 제공한다.


### 7.2.5. Working With YAML
[YAML](https://yaml.org/)은 JSON의 상위 집합이므로 계층적 구성 데이터를 지정하는 데 편리한 포맷이다. 스프링애플리케이션(SpringApplication) 클래스는 클래스패스에 [`SnakeYAML`](https://github.com/snakeyaml/snakeyaml) 라이브러리가 있을 때 프로퍼티 대신 YAML을 자동으로 지원한다.

{: .note}
"Starters"를 사용하는 경우 `SnakeYAML`은 `spring-boot-starter`에 의해 자동 제공된다.


#### Mapping YAML to Properties
YAML 문서는 계층 포맷에서 스프링 환경과 함께 사용할 수 있는 플랫 구조(flat structure)로 변환되어야 한다. 예를 들어 다음 YAML 문서를 생각해보자:

```yaml
    environments:
        dev:
            url: "https://dev.example.com"
            name: "Developer Setup"
        prod:
            url: "https://another.example.com"
            name: "My Cool App"
```

환경에서 이러한 프로퍼티에 접근하려면 다음과 같이 플랫화 되어아한다:
```
    environments.dev.url=https://dev.example.com
    environments.dev.name=Developer Setup
    environments.prod.url=https://another.example.com
    environments.prod.name=My Cool App
```

마찬가지로, YAML 리스트도 플랫화해야 한다. [index] 역참조자를 사용하여 속성 키로 표시된다. 예를 들어 다음 YAML을 생각해보자:
```yaml
    my:
        servers:
            - "dev.example.com"
            - "another.example.com"
```

앞의 예는 다음 프로퍼티로 변환된다.
```
    my.servers[0]=dev.example.com
    my.servers[1]=another.example.com
```

{: .note}
[index] 표기법을 사용하는 프로퍼티는 스프링 부트의 `바인더(Binder)` 클래스를 사용하여 자바 리스트 또는 세트(Set) 객체에 바인딩될 수 있다. 자세한 내용은 아래의 "Type-safe Configuration Properties" 절을 참고하자.

{: .warning}
`@PropertySource` 또는 `@TestPropertySource` 어노테이션을 사용하여 YAML 파일을 로드할 수 없다. 따라서 이러한 방식으로 값을 로드해야 하는 경우 프로퍼티스 파일을 사용해야 합니다.


#### Directly Loading YAML
스프링 프레임워크는 YAML 문서를 로드하는 데 사용할 수 있는 두 가지 편리한 클래스를 제공한다. `Yaml프로퍼티스팩토리빈(YamlPropertiesFactoryBean)`은 YAML을 프로퍼티스로 로드하고 `Yaml맵팩토리빈(YamlMapFactoryBean)`은 YAML을 맵으로 로드한다.


YAML을 스프링 `프로퍼티소스(PropertySource)`로 로드하려는 경우 `Yaml프로퍼티소스로더(YamlPropertySourceLoader)` 클래스를 사용할 수도 있다.


### 7.2.6. Configuring Random Values
`랜덤벨류프로퍼티소스(RandomValuePropertySource)`는 랜덤 값을 주입하는 데 유용하다(예: 시크릿 또는 테스트). 다음 예제와 같이 정수, long, uuid 또는 string을 생성할 수 있다:

`프로퍼티스(Properties)`
``` 
    my.secret=${random.value}
    my.number=${random.int}
    my.bignumber=${random.long}
    my.uuid=${random.uuid}
    my.number-less-than-ten=${random.int(10)}
    my.number-in-range=${random.int[1024,65536]}
```

`Yaml`
```yaml
  my:
    secret: "${random.value}"
    number: "${random.int}"
    bignumber: "${random.long}"
    uuid: "${random.uuid}"
    number-less-than-ten: "${random.int(10)}"
    number-in-range: "${random.int[1024,65536]}"
```

`random.int*` 구문은 `OPEN value (,max) CLOSE`이다. 여기서 `OPEN,CLOSE`는 랜덤 문자이고 `value,max`는 정수이다. `max`가 제공되면 `value`는 최소값이고 `max`는 최대값(제외, 미만)입니다.


### 7.2.7. Configuring System Environment Properties
스프링 부트는 환경 프로퍼티에 대한 접두사 설정을 지원한다. 이는 구성 요구 사항이 서로 다른 여러 스프링 부트 애플리케이션에서 시스템 환경을 공유하는 경우 유용하다. 시스템 환경 프로퍼티의 접두사는 `스프링애플리케이션(SpringApplication)`에서 직접 설정할 수 있다.

예를 들어, 접두어를 `input`으로 설정하면 시스템 환경에서는 `remote.timeout`과 같은 프로퍼티도 `input.remote.timeout`으로 해석된다.


### 7.2.8. Type-safe Configuration Properties
`@Value("${property}")` 어노테이션을 사용하여 구성 프로퍼티를 주입하는 것은 때로 번거로울 수 있다. 특히 여러 프로퍼티로 작업하거나 데이터가 본질적으로 계층적인 경우에 더욱 그렇다. 스프링 부트는 강력한 타입의 빈이 애플리케이션 구성을 관리하고 유효성을 검사할 수 있도록 하는 프로퍼티를 사용하여 작업하는 대안 메소드를 제공한다.

{: .note}
`@Value`와 `type-safe configuration` 프로퍼티의 차이점도 참고하자.


#### JavaBean Properties Binding
다음 예제와 같이 표준 `자바빈(JavaBean)` 프로퍼티를 선언한 빈을 바인딩하는 것이 가능하다:

`자바`
```java
    import java.net.InetAddress;
    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.List;
    import org.springframework.boot.context.properties.ConfigurationProperties;
    
    @ConfigurationProperties("my.service")
    public class MyProperties {
        private boolean enabled;
        private InetAddress remoteAddress;
        private final Security security = new Security();

        public boolean isEnabled() {
            return this.enabled;
        }
        
        public void setEnabled(boolean enabled) {
            this.enabled = enabled;
        }
        
        public InetAddress getRemoteAddress() {
            return this.remoteAddress;
        }

        public void setRemoteAddress(InetAddress remoteAddress) {
            this.remoteAddress = remoteAddress;
        }
      
        public Security getSecurity() {
            return this.security;
        }

        public static class Security {
            private String username;
            private String password;
            private List<String> roles = new ArrayList<>(Collections.singleton("USER"));

            public String getUsername() {
                return this.username;
            }

            public void setUsername(String username) {
                this.username = username;
            }
        
            public String getPassword() {
                return this.password;
            }

            public void setPassword(String password) {
                this.password = password;
            }

            public List<String> getRoles() {
                return this.roles;
            }

            public void setRoles(List<String> roles) {
                this.roles = roles;
            }
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import java.net.InetAddress

    @ConfigurationProperties("my.service")
    class MyProperties {
        var isEnabled = false
        var remoteAddress: InetAddress? = null
        val security = Security()

        class Security {
            var username: String? = null
            var password: String? = null
            var roles: List<String> = ArrayList(setOf("USER"))
        } 
    }
```

앞의 POJO는 다음 프로퍼티를 정의한다:
- `my.service.enabled`, 기본값은 `false`
- `my.service.remote-address`, 문자열에서 강제 변환할 수 있는 타입.
- `my.service.security.username`, 프로퍼티명에 따라 이름이 결정되는 중첩된 "security" 객체가 있다. 이 타입은 전혀 사용되지 않으며 `시큐리티프로퍼티스(SecurityProperties)`일 수 있다.
- `my.service.security.password.`
- `my.service.security.roles`, 기본값이 USER인 문자열 컬렉션이다.

***
`NOTE`

프로퍼티스 파일, YAML 파일, 환경 변수 및 기타 메커니즘을 통해 구성되는 스프링 부트에서 `@ConfigurationProperties` 클래스에 매핑되는 프로퍼티는 공개 API이지만 클래스 자체의 접근자(getter/setter)는 공개 API가 아니다.

이러한 배열은 기본 빈 생성자에 의존하며 getter 및 setter는 일반적으로 필수다. 바인딩은 스프링 MVC에서와 마찬가지로 표준 자바 빈즈 프로퍼티 디스크립터(Java Beans property descriptors)를 통해 이루어지기 때문이다. 다음과 같은 경우에는 setter가 생략될 수 있다:

- 맵은, 초기화되면 getter가 필요하지만 바인더에 의해 변경될 수 있으므로 반드시 setter는 필요하지 않다.
- 컬렉션과 배열은 인덱스(일반적으로 YAML 사용)를 하거나, 쉼표로 구분된 단일 값(프로퍼티스)을 사용하여 접근할 수 있다. 후자의 경우 setter가 필수다. 이러한 타입에 대해서는 항상 setter를 추가하는 것이 좋다. 컬렉션을 초기화하는 경우 이전 예제와 같이 컬렉션이 변경 불가능하지 않은지 확인하자.
- 중첩된 POJO 프로퍼티스가 초기화되면(이전 예의 Security 필드와 같이) setter가 필요하지 않다. 바인더가 기본 생성자를 사용하여 즉시 인스턴스를 생성하도록 하려면 setter가 필요하다.

어떤 사람들은 `롬복(Lombok)`을 사용하여 getter와 setter를 자동으로 추가합니다. 객체를 인스턴스화하기 위해 컨테이너에서 자동으로 사용되므로 롬복이 이러한 타입에 대해 특정 생성자를 생성하지 않는지 확인해야 한다.

마지막으로, 표준 자바 빈 프로퍼티스만 고려되며, 스태틱 프로퍼티에 대한 바인딩은 지원되지 않는다.
***


#### Constructor Binding
이전 절의 예제는 다음 예제와 같이 불변(immutable) 방식으로 다시 작성할 수 있다:

`자바`
```java
    import java.net.InetAddress;
    import java.util.List;
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.boot.context.properties.bind.DefaultValue;

    @ConfigurationProperties("my.service")
    public class MyProperties {
        private final boolean enabled;
        private final InetAddress remoteAddress;
        private final Security security;

        public MyProperties(boolean enabled, InetAddress remoteAddress, Security security) {
          this.enabled = enabled;
          this.remoteAddress = remoteAddress;
          this.security = security;
        }

        public boolean isEnabled() {
            return this.enabled;
        }
        
        public InetAddress getRemoteAddress() {
            return this.remoteAddress;
        }
        
        public Security getSecurity() {
            return this.security;
        }
    
        public static class Security {
            private final String username;
            private final String password;
            private final List<String> roles;

            public Security(String username, String password, @DefaultValue("USER") List<String> roles) {
                this.username = username;
                this.password = password;
                this.roles = roles;
            }

            public String getUsername() {
                return this.username;
            }
            
            public String getPassword() {
                return this.password;
            }
            
            public List<String> getRoles() {
                return this.roles;
            }
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.boot.context.properties.bind.DefaultValue
    import java.net.InetAddress

    @ConfigurationProperties("my.service")
    class MyProperties(val enabled: Boolean, val remoteAddress: InetAddress, val security: Security) {
        class Security(val username: String, val password: String, @param:DefaultValue("USER") val roles: List<String>)
    }
```

이 설정에서 파라미터화된 생성자가 있다는 것은 생성자 바인딩을 사용해야 함을 의미한다. 이는 바인더가 바인딩하려는 파라미터가 있는 생성자를 찾는것을 의미한다. 클래스에 여러 생성자가 있는 경우 `@ConstructorBinding` 어노테이션을 사용하여 생성자 바인딩에 사용할 생성자를 지정할 수 있다. 단일 파라미터화된 생성자가 있는 클래스에 대한 생성자 바인딩을 선택 해제하려면 생성자에 `@Autowired` 어노테이션을 달아야 한다. 생성자 바인딩은 레코드와 함께 사용할 수 있다. 레코드에 생성자가 여러 개 있지 않으면 `@ConstructorBinding`을 사용할 필요가 없다.

생성자 바인딩 클래스(예: 위 예의 Security)의 중첩 멤버도 해당 생성자를 통해 바인딩된다.

기본값은 생성자 파라미터 및 레코드 컴포넌트에 `@DefaultValue`를 사용하여 지정할 수 있다. 어노테이션의 문자열 값을 누락된 프로퍼티의 대상 타입으로 강제 변환하기 위해 변환 서비스(conversion service)가 적용된다.

이전 예제를 참고하면 `Security`에 바인딩된 프로퍼티스가 없으면, `MyProperties` 인스턴스에는 `Security`을 위해 `null` 값이 포함된다. 바인딩된 프로퍼티스가 없는 경우에도 `Null`이 아닌 `Security` 인스턴스를 포함하려면(코틀린을 사용하는 경우 기본값이 없으므로 `Security`의 사용자 이름 및 비밀번호 파라미터를 `null` 허용으로 선언해야 함) 빈(empty) `@DefaultValue` 어노테이션 사용한다:

`자바`
```java
    public MyProperties(boolean enabled, InetAddress remoteAddress, @DefaultValue Security security) {
        this.enabled = enabled;
        this.remoteAddress = remoteAddress;
        this.security = security;
    }
```

`코틀린`
```kotlin
    class MyProperties(val enabled: Boolean, val remoteAddress: InetAddress, @DefaultValue val security: Security) {
        class Security(val username: String?, val password: String?, @param:DefaultValue("USER") val roles: List<String>)
    }
```

{: .note}
생성자 바인딩을 사용하려면 `@EnableConfigurationProperties` 또는 컨피규레이션 프로퍼티 스캐닝(configuration property scanning)을 사용하여 클래스를 활성화해야 한다. 일반 스프링 메커니즘으로 생성된 빈(예: `@Component Bean`, `@Bean` 메서드를 사용하여 생성된 `Bean` 또는 `@Import`를 사용하여 로드된 `Bean`)에는 생성자 바인딩을 사용할 수 없다.

{: .note}
네이티브 이미지에서 생성자 바인딩을 사용하려면 클래스를 `-parameters`로 컴파일해야 한다. 이는 스프링 부트의 그레이들 플러그인을 사용하거나 메이븐 및 `spring-boot-starter-parent`를 사용하는 경우 자동으로 동작한다.

{: .note}
`@ConfigurationProperties`와 함께 `java.util.Optional`을 사용하는 것은 주로 리턴 타입으로 사용하기 위한 것이므로 권장되지 않는다. 따라서 구성 프로퍼티 주입에는 적합하지 않다. 다른 타입의 프로퍼티와의 일관성을 위해 `옵셔널(Optional)` 프로퍼티를 선언했는데 값이 없으면 빈 `옵셔널(Optional)`이 아닌 `null`이 바인딩된다.


#### Enabling @ConfigurationProperties-annotated Types
스프링 부트는 `@ConfigurationProperties` 타입을 바인딩하고 이를 빈으로 등록하는 인프라스트럭처를 제공한다. 클래스별로 구성 프로퍼티를 활성화하거나 컴포넌트 스캐닝(component scanning)과 유사한 방식으로 작동하는 구성 프로퍼티 스캐닝(configuration property scanning)을 활성화할 수 있다.

때로는, `@ConfigurationProperties`로 어노테이션이 달린 클래스가 스캐닝에 적합하지 않을 수 있다. 예를 들어, 자체 자동 구성(auto-configuration)을 개발 중이거나 조건부로 활성화하려는 경우가 그렇다. 이러한 경우 `@EnableConfigurationProperties` 어노테이션을 사용하여 처리할 타입 목록을 지정한다. 다음 예제와 같이 모든 `@Configuration` 클래스에서 이 작업을 수행할 수 있다:

`자바`
```java
    import org.springframework.boot.context.properties.EnableConfigurationProperties;
    import org.springframework.context.annotation.Configuration;
  
    @Configuration(proxyBeanMethods = false)
    @EnableConfigurationProperties(SomeProperties.class)
    public class MyConfiguration { }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.EnableConfigurationProperties
    import org.springframework.context.annotation.Configuration

    @Configuration(proxyBeanMethods = false)
    @EnableConfigurationProperties(SomeProperties::class)
    class MyConfiguration
```

`자바`
```java
    import org.springframework.boot.context.properties.ConfigurationProperties;

    @ConfigurationProperties("some.properties")
    public class SomeProperties { }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
  
    @ConfigurationProperties("some.properties")
    class SomeProperties
```

컨피규레이션 프로퍼티 스캐닝(configuration property scanning)을 사용하려면, 애플리케이션에 `@ConfigurationPropertiesScan` 어노테이션을 추가하자. 일반적으로 `@SpringBootApplication`이라는 어노테이션이 달린 메인 애플리케이션 클래스에 추가되지만, 모든 `@Configuration` 클래스에 추가할 수 있다. 기본적으로, 스캐닝은 어노테이션을 선언하는 클래스의 패키지에서 동작한다. 스캔할 특정 패키지를 정의하려면, 다음 예제에 표시된 대로 수행할 수 있다:

`자바`
```java
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.boot.context.properties.ConfigurationPropertiesScan;
  
    @SpringBootApplication
    @ConfigurationPropertiesScan({ "com.example.app", "com.example.another" })
    public class MyApplication { }
```

`코틀린`
```kotlin
    import org.springframework.boot.autoconfigure.SpringBootApplication
    import org.springframework.boot.context.properties.ConfigurationPropertiesScan

    @SpringBootApplication
    @ConfigurationPropertiesScan("com.example.app", "com.example.another")
    class MyApplication
```
<br>

***
`Note`

`@ConfigurationProperties` 빈이 컨피규레이션 프로퍼티 스캐닝을 사용하거나 `@EnableConfigurationProperties`를 통해 등록되면 빈은 `<prefix>-<fqn>`이라는 일반적인 이름을 갖는다. 여기서 <prefix>는 `@ConfigurationProperties` 어노테이션에 지정된 환경 키 접두사이고 <fqn> 빈의 완전한 이름이다. 어노테이션이 접두사를 제공하지 않으면 빈의 이름만 사용한다.

`com.example.app` 패키지에 있다고 가정하면, 위 `SomeProperties` 예제의 빈 이름은 `some.properties-com.example.app.SomeProperties`이다.
***

`@ConfigurationProperties`는 환경에서만 처리하고 특히 컨텍스트에서 다른 빈을 주입하지 않는 것이 좋다. 특수한 경우에는 setter 주입을 사용하거나 프레임워크에서 제공하는 `*Aware` 인터페이스(예: 환경에 접근해야 하는 경우 `인바이런먼트어웨어(EnvironmentAware)`)를 사용할 수 있다. 생성자를 사용하여 다른 빈을 계속 주입하려면 구성 프로퍼티 빈에 `@Component`로 어노테이션을 달고 자바빈즈 기반 프로퍼티 바인딩을 사용해야 한다.


#### Using @ConfigurationProperties-annotated Types
이 구성 스타일은 다음 예제와 같이 `스프링어노테이션(SpringApplication)` 외부 YAML 구성과 특히 잘 작동한다:

```yaml
  my: 
    service:
      remote-address: 192.168.1.1
        security:
          username: "admin"
            roles:
            - "USER"
            - "ADMIN"
```

`@ConfigurationProperties` 빈을 사용하려면 다음 예제와 같이 다른 빈과 동일한 방식으로 이를 주입할 수 있다:

`자바`
```java
    import org.springframework.stereotype.Service;
  
    @Service
    public class MyService {

        private final MyProperties properties;
        
        public MyService(MyProperties properties) {
            this.properties = properties;
        }
      
        public void openConnection() {
            Server server = new Server(this.properties.getRemoteAddress());
            server.start();
            // ...
        }
        // ... 
    }
```

`코틀린`
```kotlin
    import org.springframework.stereotype.Service

    @Service
    class MyService(val properties: MyProperties) {
    
        fun openConnection() {
            val server = Server(properties.remoteAddress)
            server.start()
            // ...
        }
        // ... 
    }
```

{: .note}
`@ConfigurationProperties`를 사용하면 IDE에서 자체 키에 대한 자동 완성 기능을 제공하는 데 사용할 수 있는 메타데이터 파일을 생성할 수도 있다. 자세한 내용은 부록을 참고하자.


#### Third-party Configuration
`@ConfigurationProperties`를 사용하여 클래스에 어노테이션을 달 수 있을 뿐만 아니라 퍼블릭(public) `@Bean` 메서드에서도 사용할 수 있다. 이렇게 하면 제어할 수 없는 서드 파티 컴포넌트에 프로퍼티스를 바인딩하려는 경우 특히 유용할 수 있다.

환경 프로퍼티스에서, 빈을 구성하려면 다음 예제와 같이 해당 빈 등록에 `@ConfigurationProperties`를 추가하자:

`자바`
```java
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;

    @Configuration(proxyBeanMethods = false)
    public class ThirdPartyConfiguration {

        @Bean
        @ConfigurationProperties(prefix = "another")
        public AnotherComponent anotherComponent() {
            return new AnotherComponent();
        }
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.context.annotation.Bean
    import org.springframework.context.annotation.Configuration

    @Configuration(proxyBeanMethods = false)
    class ThirdPartyConfiguration {
        @Bean
        @ConfigurationProperties(prefix = "another")
        fun anotherComponent(): AnotherComponent = AnotherComponent()
    }
```

다른 접두사로 정의된 자바빈 프로퍼티는 이전 `SomeProperties` 예제와 유사한 방식으로 해당 `AnotherComponent` 빈에 매핑된다.


#### Relaxed Binding
스프링 부트는 환경 프로퍼티스를 `@ConfigurationProperties` 빈에 바인딩하기 위해 몇 가지 완화된(relaxed) 규칙을 사용하므로 환경(Environment) 프로퍼티스명과 빈 프로퍼티스명이 정확히 일치할 필요는 없다. 이것이 유용한 예시는 대시(-)로 구분된 환경 프로퍼티스(예: context-path가 contextPath에 바인딩됨) 및 대문자로 표시된 환경 프로퍼티스(예: PORT가 port에 바인딩됨)이 포함된다.

예를 들어 다음 `@ConfigurationProperties` 클래스를 생각해보자:

`자바`
```java
    import org.springframework.boot.context.properties.ConfigurationProperties;

    @ConfigurationProperties(prefix = "my.main-project.person")
    public class MyPersonProperties {
        private String firstName;

        public String getFirstName() {
            return this.firstName;
        }
      
        public void setFirstName(String firstName) {
            this.firstName = firstName;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties

    @ConfigurationProperties(prefix = "my.main-project.person")
    class MyPersonProperties {
        var firstName: String? = null
    }
```

앞의 코드에서는 다음 프로퍼티스명을 모두 사용할 수 있다:

테이블 6. 완화된 바인딩 정책

|프로퍼티|설명|
|---|---|
|`my.main-project.person.first-name`|.properties 및 YAML 파일에 사용하도록 권장되는 케밥(Kebab) 케이스다|
|`my.main-project.person.firstName`|표준 카멜 케이스 문법.|
|`my.main-project.person.first_name`|.properties 및 YAML 파일에 사용하기 위한 대체 형식인 밑줄 표기법이다.|
|`MY_MAINPROJECT_PERSON_FIRSTNAME`|시스템 환경 변수를 사용할 때 권장되는 대문자 형식이다.|

{: .note}
어노테이션의 접두사 값은 케밥 대소문자(my.main-project.person과 같이 소문자로 -로 구분됨)여야 한다.

프로퍼티 소스당 완화된 바인딩 규칙
테이블 7. relaxed binding rules per property source

|프로퍼티 소스|심플|리스트|
|---|---|---|
|프로퍼티스 파일(Properties Files)|카멜 케이스, 케밥 케이스 또는 밑줄 표기|[ ] 또는 쉼표로 구분된 값을 사용하는 표준 목록 구문|
|YAML 파일|카멜 케이스, 케밥 케이스 또는 밑줄 표기|표준 YAML 목록 구문 또는 쉼표(,)로 구분된 값|
|환경 변수|밑줄을 구분 기호로 사용하는 대문자 형식이다(환경 변수에서 바인딩 참조).|밑줄로 묶인 숫자 값(환경 변수에서 바인딩 참조)|
|시스템 프로퍼티스|카멜 케이스, 케밥 케이스 또는 밑줄 표기|[ ] 또는 쉼표로 구분된 값을 사용하는 표준 목록 구문|

{: .note}
가능하면 프로퍼티를 `my.person.first-name=Rod`와 같은 소문자 케밥 형식으로 저장하는 것이 좋다.
.

#### Binding Maps
`맵` 프로퍼티스에 바인딩할 때 원래 `키` 값이 유지되도록 특수 대괄호 표기법을 사용해야 할 수도 있다. 키가 `[]`로 묶이지 않은 경우 영숫자가 아닌 `문자` 또는 `-` 또는 `.`가 제거된다.

예를 들어, 다음 프로퍼티스를 `Map<String,String>`에 바인딩하는 것을 생각해보자:

`프로퍼티스(Properties)`
``` 
    my.map.[/key1]=value1
    my.map.[/key2]=value2
    my.map./key3=value3
```

`Yaml`
```yaml
  my: 
    map:
      "[/key1]": "value1"
      "[/key2]": "value2"
      "/key3": "value3"
```

{: .note}
YAML 파일의 경우, 키를 올바르게 파싱하려면 대괄호를 따옴표로 묶어야 한다.

위의 속성은 맵의 키로 `/key1`, `/key2` 및 `key3`을 사용하여 맵에 바인딩된다. 슬래시는 대괄호로 묶이지 않았기 때문에 key3에서 제거됐다.

스칼라 값에 바인딩할 때 `.`가 포함된 키는 `[]`로 묶을 필요가 없다. 스칼라 값에는 `오브젝트(Object)`를 제외한 `java.lang` 패키지의 모든 타입과 이넘(enum)이 포함된다. `a.b=c`를 `Map<String, String>`에 바인딩하면 키의 `.`가 유지되고 `{"a.b"="c"}` 항목이 포함된 맵(Map)이 반환된다. 다른 타입의 경우 키에 `.`가 포함되어 있으면 대괄호 표기법을 사용해야 한다. 예를 들어, `a.b=c`를 `Map<String, Object>`에 바인딩하면 `{"a"={"b"="c"}}` 항목이 포함된 Map이 반환된다. 반면 `[a.b]=c`는 `{"a.b"="c"}` 항목이 포함된 맵를 반환한다.


#### Binding From Environment Variables
대부분의 운영 체제는 환경 변수에 사용할 수 있는 이름에 대해 엄격한 규칙을 적용한다. 예를 들어 리눅스 셸 변수에는 문자(`a`~`z` 또는 `A`~`Z`), 숫자(`0`~`9`) 또는 밑줄 문자(`_`)만 포함될 수 있다. 관례적으로 유닉스 쉘 변수명도 대문자로 표시된다.

스프링 부트의 완화된 바인딩 규칙은 가능한 한 이러한 명명 제한 사항과 호환되도록 설계됐다.

표준 형식의 프로퍼티명을 환경 변수명으로 변환하려면 다음 규칙을 따르면 된다:
- 점(.)을 밑줄(_)로 바꾼다.
- 대시(-)를 제거하자. 
- 소문자로 변경하자.

예를 들어, 구성 프로퍼티 `spring.main.log-startup-info`는 `SPRING_MAIN_LOGSTARTUPINFO`라는 환경 변수가 된다.

객체 목록에 바인딩할 때, 환경 변수를 사용할 수도 있다. 목록에 바인딩하려면 변수명에서 엘리먼트 번호를 밑줄로 묶어야 한다.

예를 들어 `my.service[0].other` 구성 프로퍼티는 `MY_SERVICE_0_OTHER`라는 환경 변수를 사용한다.


#### Merging Complex Types
목록이 여러 위치에 구성된 경우 오버라이드는 전체 목록을 바꾸는 방식으로 작동한다.

예를 들어, 기본적으로 null인 `name` 및 `description` 애트리뷰트을 가진 `MyPojo` 객체를 가정해보자.
다음 예에서는 `MyProperties`의 `MyPojo` 객체 리스트를 노출한다:

`자바`
```java
    import java.util.ArrayList;
    import java.util.List;
    import org.springframework.boot.context.properties.ConfigurationProperties;

    @ConfigurationProperties("my")
    public class MyProperties {
        private final List<MyPojo> list = new ArrayList<>();

        public List<MyPojo> getList() {
            return this.list;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    
    @ConfigurationProperties("my")
    class MyProperties {
        val list: List<MyPojo> = ArrayList()
    }
```

다음 구성을 생각해보자:

`프로퍼티스(Properties)`
``` 
my.list[0].name=my name
my.list[0].description=my description
#---
spring.config.activate.on-profile=dev
my.list[0].name=my another name
```

`Yaml`
```yaml
my: 
  list:
   - name: "my name"
     description: "my description"
--- 
spring:
  config:
    activate:
      on-profile: "dev"
my:
  list:
  - name: "my another name"
```

`dev` 프로필이 활성화되지 않은 경우 `MyProperties.list`에는 이전에 정의된 대로 하나의 `MyPojo` 항목이 포함된다. 그러나 `dev` 프로필이 활성화된 경우에도 리스트에는 여전히 하나의 항목만 포함된다(`my another name`의 `name`과 `null`의`description` 포함). 이 구성은 두 번째 `MyPojo` 인스턴스를 목록에 추가하지 않으며 항목을 병합하지 않는다.

여러 프로필에 리스트가 지정되면 우선 순위가 가장 높은 프로필(해당 프로필만)이 사용된다. 다음 예를 생각해보자:

`프로퍼티스(Properties)`
``` 
my.list[0].name=my name
my.list[0].description=my description
my.list[1].name=another name
my.list[1].description=another description
#---
spring.config.activate.on-profile=dev
my.list[0].name=my another name
```

`Yaml`
```yaml
my: 
  list:
  - name: "my name"
    description: "my description"
  - name: "another name"
    description: "another description"
--- 
spring:
  config:
    activate:
      on-profile: "dev"
my:
  list:
  - name: "my another name"
```

앞의 예에서 `dev` 프로필이 활성화된 경우 `MyProperties.list`에는 하나의 `MyPojo` 항목(`my another name`의 `name`과 `null`의 `description` 포함)이 포함된다. YAML의 경우 쉼표로 구분된 목록과 YAML 목록을 모두 사용하여 목록 내용을 완전히 오버라이드할 수 있다.

맵 프로퍼티스의 경우, 여러 소스에서 가져온 프로퍼티 값과 바인딩할 수 있다. 그러나 여러 소스의 동일한 프로퍼티에 대해서는 우선순위가 가장 높은 프로퍼티가 사용된다. 다음 예에서는 `MyProperties`에서 `Map<String, MyPojo>`를 노출한다:

`자바`
```java
    import java.util.LinkedHashMap;
    import java.util.Map;
    import org.springframework.boot.context.properties.ConfigurationProperties;

    @ConfigurationProperties("my")
    public class MyProperties {
        private final Map<String, MyPojo> map = new LinkedHashMap<>();
        
        public Map<String, MyPojo> getMap() {
            return this.map;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties

    @ConfigurationProperties("my")
    class MyProperties {
        val map: Map<String, MyPojo> = LinkedHashMap()
    }
```

다음 구성을 생각해보자:

`프로퍼티스(Properties)`
``` 
my.map.key1.name=my name 1
my.map.key1.description=my description 1
#---
spring.config.activate.on-profile=dev
my.map.key1.name=dev name 1
my.map.key2.name=dev name 2
my.map.key2.description=dev description 2
```

`Yaml`
```yaml
my: 
  map:
    key1:
      name: "my name 1"
      description: "my description 1"
--- 
spring:
  config:
  activate:
    on-profile: "dev"
my:
  map: 
    key1:
      name: "dev name 1"
    key2:
      name: "dev name 2"
      description: "dev description 2"
```

`dev` 프로필이 활성화되지 않은 경우 `MyProperties.map`에는 키가 `key1`(`name`에 `my name 1`과 `description`에 `my description 1`)이 있는 하나의 항목이 포함된다. 그러나 `dev` 프로필이 활성화된 경우 맵에는 `key1`(`name`에 `dev name 1`과 `description`에 `my description 1`) 및 `key2`(`name`에 `dev name 2`과 `description`에 `dev description 2`)가 있는 두 개의 항목이 포함된다.

{: .note}
앞의 병합 규칙은 파일뿐만 아니라 모든 프로퍼티 소스의 프로프티스에 적용된다.


#### Properties Conversion
스프링 부트는 `@ConfigurationProperties` 빈에 바인딩될 때 외부 애플리케이션 프로퍼티스을 올바른 타입으로 강제 변환하려고 시도한다. 커스텀 타입 변환이 필요한 경우 `컨버젼서비스(ConversionService)` 빈(`conversionService`라는 빈 포함) 또는 커스텀 프로퍼티 에디터(`커스텀에디터컨피규어러(CustomEditorConfigurer)` 빈을 통해) 또는 커스텀 컨버터(`@ConfigurationPropertiesBinding` 어노테이션이 달린 빈 정의 포함)를 제공할 수 있다.

{: .note}
이 빈은 애플리케이션 라이프사이클 중 매우 초기에 요청되므로 `컨버젼서비스(ConversionService)`가 사용하는 의존성을 제한해야 한다. 일반적으로 필요한 의존성은 생성 시 완전히 초기화되지 않을 수 있다. 구성 키 강제 변환에 필요하지 않고 `@ConfigurationPropertiesBinding`으로 자격을 갖춘 커스텀 컨버터에만 의존하는 경우 커스텀 `컨버전서비스(ConversionService)`의 이름을 바꿀 수 있다.


#### Converting Durations
스프링 부트에는 기간(durations) 표현을 위한 전용 지원이 있다. `java.time.Duration` 프로퍼티를 노출하는 경우, 애플리케이션 프로퍼티스에서 다음 포맷을 사용할 수 있다:
- 일반적인 긴 표현(`@DurationUnit`이 지정되지 않은 한 기본 단위로 밀리초 사용)
- `java.time.Duration`에서 사용되는 표준 ISO-8601 형식
- 값(value)과 단위(unit)가 결합되어 더 읽기 쉬운 형식(10s는 10초를 의미함).

다음 예제를 생각해보자:

`자바`
```java
    import java.time.Duration;
    import java.time.temporal.ChronoUnit;
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.boot.convert.DurationUnit;

    @ConfigurationProperties("my")
    public class MyProperties {
        @DurationUnit(ChronoUnit.SECONDS)
        private Duration sessionTimeout = Duration.ofSeconds(30);
        private Duration readTimeout = Duration.ofMillis(1000);
        
        public Duration getSessionTimeout() {
          return this.sessionTimeout;
        }
      
        public void setSessionTimeout(Duration sessionTimeout) {
            this.sessionTimeout = sessionTimeout;
        }
      
        public Duration getReadTimeout() {
            return this.readTimeout;
        }
        
        public void setReadTimeout(Duration readTimeout) {
            this.readTimeout = readTimeout;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.boot.convert.DurationUnit
    import java.time.Duration
    import java.time.temporal.ChronoUnit

    @ConfigurationProperties("my")
    class MyProperties {

        @DurationUnit(ChronoUnit.SECONDS)
        var sessionTimeout = Duration.ofSeconds(30)
        var readTimeout = Duration.ofMillis(1000)
    }
```

세션 시간 초과를 30초로 지정하려면 30, PT30S 및 30s가 모두 동일하다. 500ms의 읽기 시간 제한은 500, PT0.5S 및 500ms 포맷으로 지정할 수 있다.

지원되는 단위를 사용할 수도 있다:
- `ns` for nanoseconds 
- `us` for microseconds
- `ms` for milliseconds 
- `s` for seconds
- `m` for minutes
- `h` for hours
- `d` for days

기본 단위는 밀리초(ms)이며, 위 샘플에 표시된 대로 `@DurationUnit`을 사용하여 오버라이드할 수 있다.

생성자 바인딩을 사용하려는 경우 다음 예제와 같이 동일한 프로퍼티스를 노출할 수 있다:

`자바`
```java
    import java.time.Duration;
    import java.time.temporal.ChronoUnit;
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.boot.context.properties.bind.DefaultValue;
    import org.springframework.boot.convert.DurationUnit;

    @ConfigurationProperties("my")
    public class MyProperties {
        private final Duration sessionTimeout;
        private final Duration readTimeout;
        
        public MyProperties(@DurationUnit(ChronoUnit.SECONDS) @DefaultValue("30s") Duration sessionTimeout, @DefaultValue("1000ms") Duration readTimeout) {
            this.sessionTimeout = sessionTimeout;
            this.readTimeout = readTimeout;
        }
        
        public Duration getSessionTimeout() {
            return this.sessionTimeout;
        }
        
        public Duration getReadTimeout() {
            return this.readTimeout;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.boot.context.properties.bind.DefaultValue
    import org.springframework.boot.convert.DurationUnit
    import java.time.Duration
    import java.time.temporal.ChronoUnit

    @ConfigurationProperties("my")
    class MyProperties(@param:DurationUnit(ChronoUnit.SECONDS) @param:DefaultValue("30s") val sessionTimeout: Duration, @param:DefaultValue("1000ms") val readTimeout: Duration)
```

{: .note}
`Long` 프로퍼티로 업그레이드하는 경우 밀리초가 아닌 경우 단위를 정의해야 한다(`@DurationUnit` 사용). 이렇게 하면 훨씬 더 풍부한 포맷을 지원하면서 투명한 업그레이드가 제공된다.


#### Converting Periods
기간(Durations) 외에도, 스프링 부트는 `java.time.Period` 타입에서도 작동할 수 있다. 애플리케이션 프로퍼티스에서는 다음 타입을 사용할 수 있다: 
- 일반 int 표현(`@PeriodUnit`이 지정되지 않은 한 일(days)을 기본 단위로 사용)
- `java.time.Period`에서 사용되는 표준 ISO-8601 형식
- 값과 단위 쌍이 결합되는 더 간단한 형식(1y3d는 1년 3일을 의미함)


단순 형식에서는 다음 단위가 지원된다:
- `y` for years
- `m` for months 
- `w` for weeks
- `d` for days

{: .note}
`java.time.Period` 타입은 실제로 주(weeks) 수를 저장하지 않으며, "7일"을 의미하는 단축어다.


#### Converting Data Sizes
스프링 프레임워크에는 크기를 바이트 단위로 표현하는 `데이터사이즈(DataSize)` 값 타입이 있다. 데이터사이즈(DataSize) 프로퍼티를 노출하는 경우 애플리케이션 프로퍼티에서 다음 타입을 사용할 수 있다:
- 일반적인 긴 표현(`@DataSizeUnit`이 지정되지 않은 한 바이트를 기본 단위로 사용)
- 값과 단위가 결합되어 더 읽기 쉬운 형식(10MB는 10MB를 의미함)

다음 예제를 생각해보자:

`자바`
```java
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.boot.convert.DataSizeUnit;
    import org.springframework.util.unit.DataSize;
    import org.springframework.util.unit.DataUnit;

    @ConfigurationProperties("my")
    public class MyProperties {
        @DataSizeUnit(DataUnit.MEGABYTES)
        private DataSize bufferSize = DataSize.ofMegabytes(2);

        private DataSize sizeThreshold = DataSize.ofBytes(512);

        public DataSize getBufferSize() {
            return this.bufferSize;
        }
        
        public void setBufferSize(DataSize bufferSize) {
            this.bufferSize = bufferSize;
        }
        
        public DataSize getSizeThreshold() {
            return this.sizeThreshold;
        }
        
        public void setSizeThreshold(DataSize sizeThreshold) {
            this.sizeThreshold = sizeThreshold;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.boot.convert.DataSizeUnit
    import org.springframework.util.unit.DataSize
    import org.springframework.util.unit.DataUnit

    @ConfigurationProperties("my")
    class MyProperties {
        @DataSizeUnit(DataUnit.MEGABYTES)
        var bufferSize = DataSize.ofMegabytes(2)
        var sizeThreshold = DataSize.ofBytes(512)
    }
```
10MB의 버퍼 크기를 지정하려면, 10과 10MB가 동일하다. 256바이트의 크기 임계값(threshold)은 256 또는 256B로 지정할 수 있다.

지원되는 단위를 사용할 수도 있다:
- `B` for bytes
- `KB` for kilobytes
- `MB` for megabytes
- `GB` for gigabytes
- `TB` for terabytes

기본 단위는 바이트이며 위 샘플에 표시된 대로 `@DataSizeUnit`을 사용하여 오버라이드할 수 있다.

생성자 바인딩을 사용하려는 경우 다음 예제와 같이 동일한 프로퍼티를 노출할 수 있다.

`자바`
```java
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.boot.context.properties.bind.DefaultValue;
    import org.springframework.boot.convert.DataSizeUnit;
    import org.springframework.util.unit.DataSize;
    import org.springframework.util.unit.DataUnit;

    @ConfigurationProperties("my")
    public class MyProperties {
        private final DataSize bufferSize;
        private final DataSize sizeThreshold;
        
        public MyProperties(@DataSizeUnit(DataUnit.MEGABYTES) @DefaultValue("2MB") DataSize bufferSize, @DefaultValue("512B") DataSize sizeThreshold) {
            this.bufferSize = bufferSize;
            this.sizeThreshold = sizeThreshold;
        }
        
        public DataSize getBufferSize() {
            return this.bufferSize;
        }
      
        public DataSize getSizeThreshold() {
            return this.sizeThreshold;
        } 
    }
```

`코틀린`
```kotlin
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.boot.context.properties.bind.DefaultValue
    import org.springframework.boot.convert.DataSizeUnit
    import org.springframework.util.unit.DataSize
    import org.springframework.util.unit.DataUnit

    @ConfigurationProperties("my")
    class MyProperties(@param:DataSizeUnit(DataUnit.MEGABYTES) @param:DefaultValue("2MB") val bufferSize: DataSize, @param:DefaultValue("512B") val sizeThreshold: DataSize)
```

{: .note}
`Long` 프로퍼티를 업그레이드하는 경우, 바이트가 아닌 경우 단위를 정의해야 한다(`@DataSizeUnit` 사용). 이렇게 하면 훨씬 더 풍부한 포맷을 지원하면서 투명한 업그레이드가 제공된다.


#### @ConfigurationProperties Validation
스프링 부트는 스프링의 `@Validated` 어트리뷰트가 추가될 때마다, `@ConfigurationProperties` 클래스의 유효성을 검사하려고 시도한다. 구성 클래스에서 직접 `JSR-303 jakarta.validation` 제약 조건(constraint) 어노테이션을 사용할 수 있다. 이렇게 하려면, 다음 예제에 표시된 대로 호환 `JSR-303` 구현이 클래스패스에 있는지 확인한 후 필드에 제약 조건 어노테이션을 추가하자:

`자바`
```java
    import java.net.InetAddress;
    import jakarta.validation.constraints.NotNull;
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.validation.annotation.Validated;

    @ConfigurationProperties("my.service")
    @Validated
    public class MyProperties {
        @NotNull
        private InetAddress remoteAddress;
        public InetAddress getRemoteAddress() {
            return this.remoteAddress;
        }
      
        public void setRemoteAddress(InetAddress remoteAddress) {
            this.remoteAddress = remoteAddress;
        }
    }
```

`코틀린`
```kotlin
    import jakarta.validation.constraints.NotNull
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.validation.annotation.Validated
    import java.net.InetAddress

    @ConfigurationProperties("my.service")
    @Validated
    class MyProperties {
        var remoteAddress: @NotNull InetAddress? = null
    }
```

{: .note}
`@Validated`로 구성 프로퍼티스를 생성하는 `@Bean` 메서드에 어노테이션을 달아 유효성 검사를 트리거할 수도 있다.

프로퍼티가 발견되지 않은 경우에도, 중첩된 프로퍼티스에 대해 유효성 검사가 항상 트리거되도록 하려면, 연결된 필드에 `@Valid` 어노테이션을 달아야 한다. 다음 예제는 이전 `MyProperties` 예제를 기반으로 한다:

`자바`
```java
    import java.net.InetAddress;
    import jakarta.validation.Valid;
    import jakarta.validation.constraints.NotEmpty;
    import jakarta.validation.constraints.NotNull;
    import org.springframework.boot.context.properties.ConfigurationProperties;
    import org.springframework.validation.annotation.Validated;
    
    @ConfigurationProperties("my.service")
    @Validated
    public class MyProperties {
        @NotNull
        private InetAddress remoteAddress;
        
        @Valid
        private final Security security = new Security();
        
        public InetAddress getRemoteAddress() {
            return this.remoteAddress;
        }
    
        public void setRemoteAddress(InetAddress remoteAddress) {
            this.remoteAddress = remoteAddress;
        }
    
        public Security getSecurity() {
            return this.security;
        }
        
        public static class Security {
            @NotEmpty
            private String username;
            
            public String getUsername() {
                return this.username;
            }
            
            public void setUsername(String username) {
                this.username = username;
            } 
        }
    }
```

`코틀린`
```kotlin
    import jakarta.validation.Valid
    import jakarta.validation.constraints.NotEmpty
    import jakarta.validation.constraints.NotNull
    import org.springframework.boot.context.properties.ConfigurationProperties
    import org.springframework.validation.annotation.Validated
    import java.net.InetAddress

    @ConfigurationProperties("my.service")
    @Validated
    class MyProperties {
        var remoteAddress: @NotNull InetAddress? = null
      
        @Valid
        val security = Security()
      
        class Security {
            @NotEmpty
            var username: String? = null
        } 
    }
```

`컨피규레이션프로퍼티스밸리데이터(ConfigurationPropertiesValidator)`라는 빈을 생성하여 커스텀 스프링 `밸리데이터(Validator)`를 추가할 수도 있다. `@Bean` 메소드는 스태틱으로 선언되어야 한다. 구성 프로퍼티스 밸리데이터는 애플리케이션 라이프사이클 초기에 생성되며 `@Bean` 메서드를 스태틱으로 선언하면 `@Configuration` 클래스를 인스턴스화하지 않고도 빈을 생성할 수 있다. 이렇게 하면 초기 인스턴스화로 인해 발생할 수 있는 문제를 피할 수 있다.

{: .note}
`spring-boot-actuator` 모듈에는 모든 `@ConfigurationProperties` 빈을 노출하는 엔드포인트가 포함되어 있다. 웹 브라우저에서 `/actuator/configprops`를 가리키거나 동등한 JMX 엔드포인트를 사용해보자. 자세한 내용은 "Production ready features" 절을 참고하자.


#### @ConfigurationProperties vs. @Value
`@Value` 어노테이션은 코어 컨테이너 기능이며 `타입 세이프한 구성 프로퍼티`와 동일한 기능을 제공하지 않는다. 다음 표에는 `@ConfigurationProperties` 및 `@Value`에서 지원되는 기능이 요약되어 있다:

|기능|`@ConfigurationProperties`|`@Value`|
|---|---|---|
|완화된 바인딩(Relaxed binding)|Yes|제한됨(아래 참고 참조)|
|메타데이터(Meta-data) 지원|Yes|No|
|SpEL evaluation|No|Yes|

{: .note}
>`@Value`를 사용하려면 표준 포맷(소문자만 사용하는 케밥 케이스)을 사용하여 프로퍼티명을 참조하는 것이 좋다. 이렇게 하면 스프링 부트가 `@ConfigurationProperties` 바인딩을 완화할 때(Relaxed)와 동일한 논리를 사용할 수 있다.

{: .note}
>예를 들어 `@Value("\${demo.item-price}")`는 `application.properties` 파일에서 `demo.item-price` 및 `demo.itemPrice` 포맷을 선택하고 시스템 환경에서 `DEMO_ITEMPRICE`를 선택한다. 대신 `@Value("\${demo.itemPrice}")`를 사용한 경우, `deco.item-price` 및 `DEMO_ITEMPRICE`는 고려하지 않는다.

자체 컴포넌트에 대한 구성 키 세트을 정의하는 경우 `@ConfigurationProperties` 어노테이션이 달린 POJO로 그룹화하는 것이 좋다. 그렇게 하면 자신의 빈에 주입할 수 있는 구조화되고 타입이 안전한 객체가 제공된다.


애플리케이션 특성 파일의 SpEL 표현식은 해당 파일을 파싱하고 환경을 채울 때 처리되지 않는다. 그러나 `@Value`에 `SpEL 표현식`을 작성할 수 있다. 애플리케이션 프로퍼티스 파일의 프로퍼티 값이 `SpEL` 표현식인 경우 `@Value`를 통해 사용될 때 평가된다.

