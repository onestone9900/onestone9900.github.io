---
layout: default
title: 9. 데이터(Web)
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 9
---

***
9. 데이터(Data)
    - 9.1. SQL 데이터베이스(SQL Databases)
        - 9.1.1. 데이터소스 구성(Configure a DataSource)
            임베디드 데이터베이스 지원(Embedded Database Support)
            프로덕션 데이터베이스에 연결(Connection to a Production Database)
            데이터소스 구성(DataSource Configuration)
            커넥션 풀 지원(Supported Connection Pools)
            JNDI 데이터소스 커넥션(Connection to a JNDI DataSource)
        - 9.1.2. JdbcTemplate 사용(Using JdbcTemplate)
        - 9.1.3. JPA와 스프링 데이터 JPA(JPA and Spring Data JPA)
            엔터티 클래스(Entity Classes)
            스프링 데이터 JPA 리포지터리(Spring Data JPA Repositories)
            스프링 데이터 Envers 리포지터리(Spring Data Envers Repositories)
            JPA 데이터베이스 생성 및 삭제(Creating and Dropping JPA Databases)
            뷰에서 보기에서 엔터티매니저 열기(Open EntityManager in View)
        - 9.1.4. Spring Data JDBC
        - 9.1.5. Using H2’s Web Console
            Changing the H2 Console’s Path
            Accessing the H2 Console in a Secured Application
        - 9.1.6. Using jOOQ
            Code Generation
            Using DSLContext
            jOOQ SQL Dialect
            Customizing jOOQ
        - 9.1.7. Using R2DBC
            Embedded Database Support
            Using DatabaseClient
            Spring Data R2DBC Repositories
    - 9.2. Working with NoSQL Technologies
        - 9.2.1. Redis
            Connecting to Redis
        - 9.2.2. MongoDB
            Connecting to a MongoDB Database
            MongoTemplate
            Spring Data MongoDB Repositories
        - 9.2.3. Neo4j
            Connecting to a Neo4j Database
            Spring Data Neo4j Repositories
        - 9.2.4. Elasticsearch
            Connecting to Elasticsearch Using REST clients
            Connecting to Elasticsearch by Using Spring Data
            Spring Data Elasticsearch Repositories
        - 9.2.5. Cassandra
            Connecting to Cassandra
            Spring Data Cassandra Repositories
        - 9.2.6. Couchbase
            Connecting to Couchbase
            Spring Data Couchbase Repositories
        - 9.2.7. LDAP
            Connecting to an LDAP Server
            Spring Data LDAP Repositories
            Embedded In-memory LDAP Server
        - 9.2.8. InfluxDB
            Connecting to InfluxDB
    - 9.3. What to Read Next
***


# 9. 데이터(Data)
스프링 부트는 SQL 및 NoSQL 등 다양한 데이터 기술과 통합할 수 있다.

## 9.1. SQL 데이터베이스(SQL Databases)
스프링 프레임워크는 Jdbc템플릿(JdbcTemplate)을 사용해 직접 JDBC 접근부터 하이버네이트(Hibernate)와 같은 완전한 "객체 관계형 매핑" 기술에 이르기까지 SQL 데이터베이스 작업에 대해 광범위하게 지원한다. 스프링 데이터는 인터페이스에서 직접 리포지터리를 구현하고 컨벤션을 사용하여 메서드명에서 쿼리를 생성하는 추가 기능 레벨을 제공한다.


### 9.1.1. 데이터소스 구성(Configure a DataSource)
자바의 `javax.sql.DataSource` 인터페이스는 데이터베이스 연결 작업의 표준을 제공한다. 전통적으로 데이터소스(DataSource)는 일부 자격 증명(credential)과 함께 URL을 사용하여 데이터베이스 커넥션을 설정한다.


{: .note}
일반적으로 데이터소스(DataSource) 구성을 완전히 제어하는 ​​고급 예제는 "방법(How-to)" 장을 참고하자.


#### 임베디드 데이터베이스 지원(Embedded Database Support)
인메모리 임베디드 데이터베이스를 사용하여 애플리케이션을 개발하는 것이 편리한 경우가 많다. 분명히 인메모리 데이터베이스는 영구 저장소를 제공하지 않는다. 애플리케이션이 시작될 때 데이터베이스를 채워야 하고 애플리케이션이 종료되면 데이터를 버릴 준비를 해야 한다.

{: .note}
"방법(How-to)" 섹션에는 데이터베이스를 초기화하는 방법에 대한 장이 포함되어 있다.

스프링 부트는 임베디드 H2, HSQL 및 Derby 데이터베이스를 자동 구성(auto-configure)할 수 있다. 연결 URL을 제공할 필요가 없다. 사용하려는 임베디드 데이터베이스에 대한 빌드 의존성만 포함하면 된다. 클래스패스에 여러 개의 임베디드 데이터베이스가 있는 경우 `spring.datasource.embedded-database-connection` 구성 프로퍼티을 설정하여 어느 것이 사용되는지 제어하자. 프로퍼티를 none으로 설정하면 임베디드 데이터베이스의 자동 구성이 비활성화된다.

{: .note}
테스트에서 이 기능을 사용하는 경우, 사용하는 애플리케이션 컨텍스트 수에 관계없이 전체 테스트 스위트에서 동일한 데이터베이스가 재사용된다는 것을 알 수 있다. 각 컨텍스트에 별도의 임베디드 데이터베이스가 있는지 확인하려면 `spring.datasource.generate-unique-name`을 true로 설정해야 한다.

예를 들어 일반적인 POM 의존성은 다음과 같다.

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
<dependency>
  <groupId>org.hsqldb</groupId>
  <artifactId>hsqldb</artifactId>
  <scope>runtime</scope>
</dependency>
```

{: .note}
임베디드 데이터베이스를 자동 구성하려면, `spring-jdbc`에 대한 의존성이 필요하다. 이 예제에서는 `spring-boot-starter-data-jpa`를 통해 전이적으로 끌어온다.

{: .note}
어떤 이유로든 임베디드 데이터베이스에 대한 연결 URL을 구성하는 경우 데이터베이스의 자동 종료가 비활성화되어 있는지 확인하자. H2를 사용하는 경우 `DB_CLOSE_ON_EXIT=FALSE`를 사용해야 한다. HSQLDB를 사용하는 경우 `shutdown=true`가 사용되지 않는지 확인해야 한다. 스프링 부트가 데이터베이스가 닫힐 때 제어할 수 있는 데이터베이스 자동 종료를 비활성화하면, 데이터베이스에 대한 접근이 더 이상 필요하지 않을 때 발생할 수 있도록 보장한다.


#### 프로덕션 데이터베이스에 연결(Connection to a Production Database)
풀링 데이터소스(DataSource)를 사용하여 프로덕션 데이터베이스 커넥션을 자동으로 구성할 수도 있다.


#### 데이터소스 구성(DataSource Configuration)
`데이터소스(DataSource)` 구성은 `spring.datasource.*`의 외부 구성 프로퍼티스에 의해 제어된다. 예를 들어 `application.properties`에서 다음 내용을 선언할 수 있다.

`프로퍼티스(Properties)`
```
spring.datasource.url=jdbc:mysql://localhost/test
spring.datasource.username=dbuser
spring.datasource.password=dbpass
```

`Yaml`
```yaml
spring:
  datasource:
    url: "jdbc:mysql://localhost/test"
    username: "dbuser"
    password: "dbpass"
```

{: .note}
최소 `spring.datasource.url` 프로퍼티에 URL을 지정해야 한다. 그렇지 않으면 스프링 부트는 임베디드 데이터베이스를 자동 구성하려고 시도한다.


{: .note}
스프링 부트는 URL에서 대부분 데이터베이스에 대한 JDBC 드라이버 클래스를 추론할 수 있다. 특정 클래스를 지정해야 하는 경우 `spring.datasource.driver-class-name` 프로퍼티를 사용할 수 있다.

{: .note}
풀링 데이터소스(DataSource)를 생성하려면 유효한 드라이버(Driver) 클래스가 사용 가능한지 확인할 수 있어야 하므로 작업을 수행하기 전에 이를 확인해야 한다. 즉, `spring.datasource.driver-class-name=com.mysql.jdbc.Driver`를 설정한 경우 해당 클래스를 로드할 수 있어야 한다.

지원되는 옵션에 대한 자세한 내용은 데이터소스프로퍼티스(DataSourceProperties)를 참조하자. 이는 실제 구현과 관계없이 작동하는 표준 옵션이다. 각각의 접두사(spring.datasource.hikari.*, spring.datasource.tomcat.*, spring.datasource.dbcp2.* 및 spring.datasource.oracleucp.*)를 사용하여 구현별 설정을 미세 조정하는 것도 가능하다. 자세한 내용은 사용 중인 커넥션 풀 구현 설명서를 참고하자.

예를 들어, 톰캣 커넥션 풀을 사용하는 경우 다음 예와 같이 다양한 추가 설정을 커스텀할 수 있다.

`프로퍼티스(Properties)`
```
spring.datasource.tomcat.max-wait=10000
spring.datasource.tomcat.max-active=50
spring.datasource.tomcat.test-on-borrow=true
```

`Yaml`
```yaml
spring:
  datasource:
    tomcat:
    max-wait: 10000
    max-active: 50
    test-on-borrow: true
```

이렇게 하면 사용 가능한 커넥션이 없는 경우 예외가 발생하기 전에 10000ms를 기다리도록 풀이 설정되고, 최대 커넥션 수를 50으로 제한하고 풀에서 커넥션을 빌리기 전에 연결의 유효성을 검사한다.


#### 커넥션 풀 지원(Supported Connection Pools)
스프링 부트는 특정 구현을 선택하기 위해 다음 알고리즘을 사용한다.
1. 우리는 성능과 동시성(concurrency) 때문에 히카리CP(HikariCP)를 선호한다. 히카리CP(HikariCP)를 사용할 수 있으면 항상 이를 선택한다.
2. 그렇지 않고, 톰캣 풀링 데이터소스(DataSource)를 사용할 수 있으면 이를 사용한다.
3. 그렇지 않고 Commons DBCP2를 사용할 수 있으면 이를 사용한다.
4. 히카리CP(HikariCP), 톰캣, DBCP2 중 어느 것도 사용할 수 없고 오라클 UCP를 사용할 수 있으면 이를 사용한다.

{: .note}
`spring-boot-starter-jdbc` 또는 `spring-boot-starter-data-jpa` "스타터"를 사용하는 경우 자동으로 히카리CP에 대한 의존성을 얻는다.

`spring.datasource.type` 프로퍼티을 설정하면 해당 알고리즘을 완전히 우회하고 사용할 커넥션 풀을 지정할 수 있다. Tomcat-jdbc가 기본적으로 제공되므로 이는 톰캣 컨테이너에서 애플리케이션을 실행하는 경우 특히 중요하다.

추가 커넥션 풀은 항상 데이터소스빌더(DataSourceBuilder)를 사용하여 수동으로 구성할 수 있다. 자체 데이터소스(DataSource) 빈을 정의하면 자동 구성이 발생하지 않는다. 데이터소스빌더(DataSourceBuilder)는 다음 커넥션 풀을 지원한다.
- 히카리CP(HikariCP)
- 톰캣 풀링 데이터소스(Tomcat pooling Datasource)
- Commons DBCP2
- Oracle UCP & OracleDataSource
- 스프링 프레임워크의 심플드라이버데이터소스(SimpleDriverDataSource)
- H2 JdbcDataSource
- PostgreSQL PGSimpleDataSource
- C3P0


#### JNDI 데이터소스 커넥션(Connection to a JNDI DataSource)
스프링 부트 애플리케이션을 애플리케이션 서버에 배포하는 경우, 서버의 기능을 사용하여 데이서소스(DataSource)를 구성 및 관리하고 JNDI를 사용하여 접근할 수 있다.

`spring.datasource.jndi-name` 프로퍼티는 `spring.datasource.url`, `spring.datasource.username` 및 `spring.datasource.password` 프로퍼티스의 대안으로 사용되어 특정 JNDI 위치에서 데이터소스(DataSource)에 접근할 수 있다. 예를 들어, `application.properties`의 다음 내용에서는 JBoss AS 정의 데이터소스(DataSource)에 접근하는 방법을 보여준다.

`프로퍼티스(Properties)`
```
spring.datasource.jndi-name=java:jboss/datasources/customers
```

`Yaml`
```yaml
spring:
  datasource:
    jndi-name: "java:jboss/datasources/customers"
```


### 9.1.2. JdbcTemplate 사용(Using JdbcTemplate)
스프링의 JdbcTemplate 및 NamedParameterJdbcTemplate 클래스는 자동으로 구성되며 다음 예제와 같이 @Autowire를 자신의 빈에 직접 연결할 수 있다.

`자바`
```java
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

@Component
public class MyBean {
    private final JdbcTemplate jdbcTemplate;

    public MyBean(JdbcTemplate jdbcTemplate) {

          this.jdbcTemplate = jdbcTemplate;
    }

    public void doSomething() {
        this.jdbcTemplate ...
    } 
}
```

`코틀린`
```kotlin
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.stereotype.Component

@Component
class MyBean(private val jdbcTemplate: JdbcTemplate) {
    fun doSomething() {
        jdbcTemplate.execute("delete from customer")
    } 
}
```

다음 예제와 같이 `spring.jdbc.template.*` 프로퍼티스를 사용하여 템플릿의 일부 프로퍼티스를 커스텀할 수 있다.

`프로퍼티스(Properties)`
```
spring.jdbc.template.max-rows=500
```

`Yaml`
```yaml
spring:
  jdbc:
    template:
      max-rows: 500
```

{: .note}
NamedParameterJdbcTemplate은 뒤에서 동일한 JdbcTemplate 인스턴스를 재사용한다. 둘 이상의 JdbcTemplate이 정의되고 기본 후보가 없으면 NamedParameterJdbcTemplate이 자동 구성되지 않는다.


### 9.1.3. JPA와 스프링 데이터 JPA(JPA and Spring Data JPA)
자바 퍼시스턴스(Persistence) API는 객체를 관계형 데이터베이스에 "매핑"할 수 있는 표준 기술이다. `spring-boot-starter-data-jpa` POM은 시작하는 빠른 방법을 제공한다. 다음과 같은 주요 의존성을 제공한다.
- 하이버네이트(Hibernate): 가장 인기 있는 JPA 구현 중 하나다.
- 스프링 데이터 JPA: JPA 기반 리포지터리를 구현하는 데 도움이 된다.
- 스프링 ORM: 스프링 프레임워크의 ORM 코어 지원이다.

{: .note}
여기서는 JPA 또는 스프링 데이터에 대해 너무 많은 세부 사항을 다루지 않는다. `spring.io`의 [“Accessing Data with JPA” 가이드](https://spring.io/guides/gs/accessing-data-jpa/)와 [스프링 데이터 JPA](https://spring.io/projects/spring-data-jpa)와 [하이버네이트 레퍼런스 문서](https://hibernate.org/orm/documentation/)를 읽어보자.


#### 엔터티 클래스(Entity Classes)
전통적으로 JPA "Entity" 클래스는 persistence.xml 파일에 지정된다. 스프링 부트에서는 이 파일이 필요하지 않으며 대신 "Entity Scanning"이 사용된다. 기본적으로 기본 구성 클래스(@EnableAutoConfiguration 또는 @SpringBootApplication으로 어노테이션이 달린 패키지) 아래의 모든 패키지가 검색된다.

`@Entity`, `@Embeddable` 또는 `@MappedSuperclass`로 어노테이션이 달린 모든 클래스가 고려된다. 일반적인 엔터티 클래스는 다음 예와 유사하다.

`자바`
```java
import java.io.Serializable;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;

@Entity
public class City implements Serializable {
    @Id
    @GeneratedValue
    private Long id;

    @Column(nullable = false)
    private String name;

    @Column(nullable = false)
    private String state;
    
    // ... 추가 멤버에는 종종 @OneToMany 매핑이 포함된다.
    protected City() {
        // JPA 사양에 필요한 인수 없는(no-args) 생성자
        // 직접 사용되어서는 안 되기 때문에 protected로 선언한다.
    }

    public City(String name, String state) {
        this.name = name;
        this.state = state;
    }

    public String getName() {
        return this.name;
    }

    public String getState() {
        return this.state;
    }

    // ... 기타 등등.
}
```

`코틀린`
```kotlin
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.Id
import java.io.Serializable

@Entity
class City : Serializable {
    @Id
    @GeneratedValue
    private val id: Long? = null

    @Column(nullable = false)
    var name: String? = null
        private set

    // ... etc
    @Column(nullable = false)
    var state: String? = null
        private set

    // ... 추가 멤버에는 종종 @OneToMany 매핑이 포함된다.
    protected constructor() {
        // JPA 사양에 필요한 인수 없는(no-args) 생성자
        // 직접 사용되어서는 안 되기 때문에 protected로 선언한다.
    }

    constructor(name: String?, state: String?) {
        this.name = name
        this.state = state
    }
}
```

{: .note}
`@EntityScan` 어노테이션을 사용하여 엔터티 스캐닝 위치를 커스텀할 수 있다. "스프링 구성에서 @Entity 정의 분리(Separate @Entity Definitions from Spring Configuration)" 방법을 참고하자.


#### 스프링 데이터 JPA 리포지터리(Spring Data JPA Repositories)
스프링 데이터 JPA 리포지토리는 데이터에 접근하기 위해 정의할 수 있는 인터페이스다. JPA 쿼리는 메소드명에서 자동으로 생성된다. 예를 들어 CityRepository 인터페이스는 주어진 주의 모든 도시를 찾기 위해 findAllByState(String state) 메소드를 선언할 수 있다.

더 복잡한 쿼리의 경우 스프링 데이터의 쿼리(Query) 어노테이션을 사용하여 메서드에 어노테이션을 달 수 있다.

스프링 데이터 리포지터리는 일반적으로 리포지터리(Repository) 또는 CrudRepository 인터페이스를 상속한다. 자동 구성을 사용하는 경우 기본 구성 클래스(@EnableAutoConfiguration 또는 @SpringBootApplication 어노테이션이 달린 클래스)가 포함된 패키지에서 리포지토리가 검색된다.

다음 예는 일반적인 스프링 데이터 리포지터리 인터페이스 정의를 보여준다.

`자바`
```java
import org.springframework.boot.docs.data.sql.jpaandspringdata.entityclasses.City;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.Repository;

public interface CityRepository extends Repository<City, Long> {
    Page<City> findAll(Pageable pageable);
    City findByNameAndStateAllIgnoringCase(String name, String state);
}
```

`코틀린`
```kotlin
import org.springframework.boot.docs.data.sql.jpaandspringdata.entityclasses.City
import org.springframework.data.domain.Page
import org.springframework.data.domain.Pageable
import org.springframework.data.repository.Repository

interface CityRepository : Repository<City?, Long?> {
    fun findAll(pageable: Pageable?): Page<City?>?
    fun findByNameAndStateAllIgnoringCase(name: String?, state: String?): City?
}
```

스프링 데이터 JPA 리포지토리는 default, deferred 및 lazy의 세 가지 부트스트래핑(bootstrapping) 모드를 지원한다. deferred 또는 lazy 부트스트래핑을 활성화하려면,` spring.data.jpa.repositories.bootstrap-mode` 프로퍼티를 각각 deferred 또는 lazy로 설정하자. deferred 혹은 lazy 부트스트래핑을 사용할 때 자동 구성된 엔터티매니저팩토리빌더(EntityManagerFactoryBuilder)는 컨텍스트의 에이싱크태스크익스큐터(AsyncTaskExecutor)(있는 경우)를 부트스트랩 익스큐터로 사용한다. 둘 이상이 존재하는 경우 `applicationTaskExecutor`라는 이름이 사용된다.

{: .note}
deferred 또는 lazy 부트스트랩을 사용하는 경우, 애플리케이션 컨텍스트 부트스트랩 단계 후 JPA 인프라에 대한 접근을 연기(defer) 해야 ​​한다. 스마트이니셜라이징싱글톤(SmartInitializingSingleton)을 사용하여 JPA 인프라가 필요한 모든 초기화를 호출할 수 있다. 스프링 빈으로 생성된 JPA 컴포넌트(예: 컨버터)의 경우 오브젝트프로바이더(ObjectProvider)를 사용하여 의존성을 지연(delay)시킨다.

{: .note}
우리는 스프링 데이터 JPA의 표면만 살펴보았다. 자세한 내용은 스프링 데이터 JPA 레퍼런스 문서를 참고하자.


#### 스프링 데이터 Envers 리포지터리(Spring Data Envers Repositories)
스프링 데이터 Envers를 사용할 수 있는 경우 JPA 리포지터리는 일반적인 Envers 쿼리를 지원하도록 자동 구성된다.

스프링 데이터 Envers를 사용하려면 다음 예제와 같이 리포지토리가 리비전리포지터리(RevisionRepository)에서 상속됐는지 확인하자.

`자바`
```java
import org.springframework.boot.docs.data.sql.jpaandspringdata.entityclasses.Country;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.Repository;
import org.springframework.data.repository.history.RevisionRepository;

public interface CountryRepository extends RevisionRepository<Country, Long, Integer>, Repository<Country, Long> {
    Page<Country> findAll(Pageable pageable);
}
```

`코틀린`
```kotlin
import org.springframework.boot.docs.data.sql.jpaandspringdata.entityclasses.Country
import org.springframework.data.domain.Page
import org.springframework.data.domain.Pageable
import org.springframework.data.repository.Repository
import org.springframework.data.repository.history.RevisionRepository

interface CountryRepository : RevisionRepository<Country?, Long?, Int>, Repository<Country?, Long?> {
    fun findAll(pageable: Pageable?): Page<Country?>?
}
```

{: .note}
자세한 내용은 [스프링 데이터 Envers 레퍼런스 문서](https://docs.spring.io/spring-data/envers/docs/current/reference/html/)를 참고하자.


#### JPA 데이터베이스 생성 및 삭제(Creating and Dropping JPA Databases)
기본적으로 JPA 데이터베이스는 임베디드 데이터베이스(H2, HSQL 또는 Derby)를 사용하는 경우에만 자동으로 생성된다. `spring.jpa.*` 프로퍼티스를 사용하여 JPA 설정을 명시적으로 구성할 수 있다. 예를 들어, 테이블을 생성하고 삭제하려면 `application.properties`에 다음 줄을 추가할 수 있다.

`프로퍼티스(Properties)`
```
spring.jpa.hibernate.ddl-auto=create-drop
```

`Yaml`
```yaml
spring: 
  jpa:
    hibernate.ddl-auto: "create-drop"
```

이에 대한 하이버네이트 자체의 내부 프로퍼티명은 `hibernate.hbm2ddl.auto`이다. `spring.jpa.properties.*`를 사용하여 다른 하이버네이트 기본 프로퍼티와 함께 설정할 수 있다(접두사는 엔터티 매니저(entity manager)에 추가하기 전에 제거된다). 다음 줄은 하이버네이트에 대한 JPA 프로퍼티스을 설정하는 예를 보여준다.

`프로퍼티스(Properties)`
```
spring.jpa.properties.hibernate[globally_quoted_identifiers]=true
```

`Yaml`
```yaml
spring: 
  jpa:
    properties:
      hibernate: 
        "globally_quoted_identifiers": "true"
```

위 예제는 `hibernate.globally_quoted_identifiers` 프로퍼티에 대한 `true` 값을 하이버네이트 엔터티 매니저에 전달한다.

기본적으로, DDL 익스큐션(또는 유효성 검사(validation))은 애플리케이션컨텍스트(ApplicationContext)가 시작될 때까지 연기된다. `spring.jpa.generate-ddl` 플래그도 있지만 하이버네이트 자동 구성이 활성화된 경우에는 사용되지 않는다. `ddl-auto` 설정이 더 세밀하기 때문이다.


#### 뷰에서 엔터티매니저 열기(Open EntityManager in View)
웹 애플리케이션을 실행하는 경우 스프링 부트는 기본적으로 `오픈엔터티매니저인뷰인터셉터(OpenEntityManagerInViewInterceptor)`를 등록하여 "뷰에서 엔터디매니저 열기(Open EntityManager in View)" 패턴을 적용하여 웹 뷰에서 지연 로딩(lazy loading)을 허용한다. 이 동작을 원하지 않으면 `application.properties`에서 `spring.jpa.open-in-view`를 `false`로 설정해야 한다.
