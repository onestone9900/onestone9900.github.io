---
layout: default
title: 13. 프로덕션 준비 기능(Production-ready Features)
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 13
---

[원문 - Production-ready Features](https://docs.spring.io/spring-boot/docs/3.1.1/reference/html/actuator.html#actuator)

***

13. 프로덕션 준비 기능(Production-ready Features)
    - 13.1. 프로덕션에 준비 기능 활성화(Enabling Production-ready Features)
    - 13.2. 엔드포인트(Endpoints)
      - 13.2.1. 엔드포인트 활성화(Enabling Endpoints)
      - 13.2.2. 엔드포인트 노출(Exposing Endpoints)
      - 13.2.3. 보안(Security)
        - 크로스 사이트 요청 위조 방지(Cross Site Request Forgery Protection)
      - 13.2.4. 엔드포인트 구성(Configuring Endpoints)
      - 13.2.5. 액추에이터 웹 엔드포인트를 위한 하이퍼미디어(Hypermedia for Actuator Web Endpoints)
      - 13.2.6. CORS 지원(CORS Support)
      - 13.2.7. 커스텀 엔드포인트 구현(Implementing Custom Endpoints)
        - 입력 받기(Receiving Input)
        - 커스텀 웹 엔드포인트(Custom Web Endpoints)
        - 서블릿 엔드포인트(Servlet Endpoints)
        - 컨트롤러 엔드포인트(Controller Endpoints)
      - 13.2.8. 상태 정보(Health Information)
        - 헬스인디케이터 자동 구성(Auto-configured HealthIndicators)
        - 커스텀 헬스인디케이터 작성. 리액티브 헬스인디케이터(Writing Custom HealthIndicators. Reactive Health Indicators)
        - 자동 구성된 리액티브헬스인디케이터 상태 그룹(Auto-configured ReactiveHealthIndicators Health Groups)
        - 데이터소스 상태(DataSource Health)
      - 13.2.9. 쿠버네티스 프로브(Kubernetes Probes)
        - 쿠버네티스 프로브로 외부 상태 확인(Checking External State With Kubernetes Probes)
        - 애플리케이션 생명주기 및 프로브 상태(Application Lifecycle and Probe States)
      - 13.2.10. 애플리케션 정보(Application Information)
        - 자동 구성된 인포컨트리뷰터(Auto-configured InfoContributors)
        - 커스텀 애플리케이이션 정보(Custom Application Information)
        - 깃 커밋 정보(Git Commit Information)
        - 빌드 정보(Build Information)
        - 자바 정보(Java Information)
        - OS 정보(OS Information)
        - 커스텀 인포컨트리뷰터 개발(Writing Custom InfoContributors)
      - 13.3. HTTP 모니터링과 관리(Monitoring and Management Over HTTP)
        - 13.3.1. 관리 엔드포인트 경로 커스텀(Customizing the Management Endpoint Paths)
        - 13.3.2. 관리 서버 포트 커스텀(Customizing the Management Server Port)
        - 13.3.3. 관리별 SSL 구성(Configuring Management-specific SSL)
        - 13.3.4. 관리 서버 주소 커스텀(Customizing the Management Server Address)
        - 13.3.5. HTTP 엔드포인트 비활성화(Disabling HTTP Endpoints)
      - 13.4. JMX를 통한 모니터링 및 관리(Monitoring and Management over JMX)
        - 13.4.1. Customizing MBean Names
        - 13.4.2. Disabling JMX Endpoints
      - 13.5. Observability
      - 13.6. Loggers
        - 13.6.1. Configure a Logger
      - 13.7. Metrics
        - 13.7.1. Getting started
        - 13.7.2. Supported Monitoring Systems
          - AppOptics 
          - Atlas
          - Datadog
          - Dynatrace
          - Elastic
          - Ganglia
          - Graphite
          - Humio
          - Influx
          - JMX
          - KairosDB
          - New Relic
          - OpenTelemetry
          - Prometheus
          - SignalFx
          - Simple
          - Stackdriver
          - StatsD
          - Wavefront
        - 13.7.3. Supported Metrics and Meters
          - JVM Metrics
          - System Metrics
          - Application Startup Metrics
          - Logger Metrics
          - Task Execution and Scheduling Metrics
          - Spring MVC Metrics
          - Spring WebFlux Metrics
          - Jersey Server Metrics
          - HTTP Client Metrics
          - Tomcat Metrics
          - Cache Metrics
          - Spring Batch Metrics
          - Spring GraphQL Metrics
          - DataSource Metrics 
          - Hibernate Metrics
          - Spring Data Repository Metrics
          - RabbitMQ Metrics
          - Spring Integration Metrics 
          - Kafka Metrics
          - MongoDB Metrics
          - Jetty Metrics
          - @Timed Annotation Support
          - Redis Metrics
        - 13.7.4. Registering Custom Metrics
        - 13.7.5. Customizing Individual Metrics
          - Common Tags
          - Per-meter Properties
        - 13.7.6. Metrics Endpoint
        - 13.7.7. Integration with Micrometer Observation
      - 13.8. Tracing
        - 13.8.1. Supported Tracers
        - 13.8.2. Getting Started
        - 13.8.3. Tracer Implementations
          - OpenTelemetry With Zipkin
          - OpenTelemetry With Wavefront
          - OpenTelemetry With OTLP
          - OpenZipkin Brave With Zipkin
          - OpenZipkin Brave With Wavefront
        - 13.8.4. Integration with Micrometer Observation
        - 13.8.5. Creating Custom Spans
      - 13.9. Auditing
        - 13.9.1. Custom Auditing
      - 13.10. Recording HTTP Exchanges
        - 13.10.1. Custom HTTP Exchange Recording 
      - 13.11. Process Monitoring
        - 13.11.1. Extending Configuration
        - 13.11.2. Programmatically Enabling Process Monitoring 
      - 13.12. Cloud Foundry Support
        - 13.12.1. Disabling Extended Cloud Foundry Actuator Support 
        - 13.12.2. Cloud Foundry Self-signed Certificates
        - 13.12.3. Custom Context Path
      - 13.13. What to Read Next
***


# 13. 프로덕션 준비 기능(Production-ready Features)
스프링 부트에는 애플리케이션을 프로덕션 환경으로 푸시할 때 애플리케이션을 모니터링하고 관리하는 데 도움이 되는 다양한 추가 기능이 포함되어 있다. HTTP 엔드포인트나 JMX를 사용하여 애플리케이션을 관리하고 모니터링하도록 선택할 수 있다. 감사(Auditing), 상태(health) 및 지표 수집(metrics gathering)도 애플리케이션에 자동으로 적용될 수 있다.


## 13.1. 프로덕션 준비 기능 활성화(Enabling Production-ready Features)
`spring-boot-actuator` 모듈은 스프링 부트의 프로덕션 준비 기능을 모두 제공한다. 기능을 활성화하는 권장 방법은 `spring-boot-starter-actuator` "스타터" 의존성을 추가하는 것이다.

<B>액츄에이터 정의</B>

```
액츄에이터(Actuator)는 무언가를 움직이거나 제어하기 위한 기계 장치를 가리키는 제조 용어다. 액추에이터는 작은 변화로 많은 양의 모션을 생성할 수 있다.
```

메이븐 기반 프로젝트에 액추에이터를 추가하려면 다음 "스타터" 의존성을 추가하자.

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
</dependencies>
```

그레이들의 경우 다음 선언을 사용한다.

```groovy
dependencies {
      implementation 'org.springframework.boot:spring-boot-starter-actuator'
}
```

## 13.2. 엔드포인트(Endpoints)
액추에이터 엔드포인트를 사용하면 애플리케이션을 모니터링하고 상호 작용할 수 있다. 스프링 부트에는 여러 내장 엔드포인트가 포함되어 있으며 사용자가 직접 엔드포인트를 추가할 수 있다. 예를 들어 상태(health) 엔트포인트는 기본 애플리케이션의 상태 정보를 제공한다.


각 개별 엔드포인트을 활성화하거나 비활성화하고 HTTP 또는 JMX를 통해 노출(원격 접근 가능)할 ​​수 있다. 엔드포인트는 활성화되고 노출되면 사용 가능한 것으로 간주된다. 기본 제공 엔드포인트는 사용 가능한 경우에만 자동 구성된다. 대부분의 애플리케이션은 엔드포인트 ID와 `/actuator` 접두사가 URL에 매핑되는 HTTP를 통한 노출을 선택한다. 예를 들어 기본적으로 상태 엔드포인트는 `/actuator/health`에 매핑된다.

{: .note}
액추에이터의 엔드포인트와 해당 요청 및 응답 형식에 대해 자세히 알아보려면 별도의 API 설명서(HTML 또는 PDF)를 참고하자.

다음과 같은 기술 독립적인 엔드포인트를 사용할 수 있다

|ID|설명|
|---|---|
|`auditevents`|현재 애플리케이션에 대한 감시(audit) 이벤트 정보를 노출한다. `어디트이벤트리포지터리(AuditEventRepository)` 빈이 필요하다.|
|`beans`|애플리케이션에 있는 모든 스프링 빈 전체 목록을 표시한다.|
|`caches`|사용 가능한 캐시를 노출한다.|
|`conditions`|구성 및 자동 구성 클래스에서 평가된(evaluated) 조건과 일치하거나 일치하지 않는 이유를 표시한다.|
|`configprops`|모든 `@ConfigurationProperties`의 대조 목록을 표시한다.|
|`env`|스프링의 컨피규러블인바이런먼트(ConfigurableEnvironment)에서 프로퍼티를 노출한다.|
|`flyway`|적용된 모든 `Flyway` 데이터베이스 마이그레이션을 표시한다. 하나 이상의 Flyway 빈이 필요하다.|
|`health`|애플리케이션 상태 정보를 표시한다.|
|`httpexchanges`|HTTP 교환 정보(기본적으로 마지막 100개의 HTTP 요청-응답 교환)를 표시한다. `HttpExchangeRepository` 빈이 필요하다.|
|`info`|임의의 애플리케이션 정보를 표시합니다.|
|`integrationgraph`|스프링 인테그레이션 그래프를 표시한다. `spring-integration-core`에 대한 의존성이 필요하다.|
|`loggers`|애플리케이션의 로거 구성을 표시하고 수정한다.|
|`liquibase`|적용된 모든 `Liquibase` 데이터베이스 마이그레이션을 표시한다. 하나 이상의 `Liquibase` 빈이 필요하다.|
|`metrics`|현재 애플리케이션에 대한 "메트릭(metrics)" 정보를 표시한다.|
|`mappings`|모든 `@RequestMapping` 경로의 조합된 목록을 표시한다.|
|`quartz`|쿼츠 스케줄러 잡에 대한 정보를 표시한다.|
|`scheduledtasks`|애플리케이션에 예약된 작업을 표시한다.|
|`sessions`|스프링 세션 지원 세션 리포지터리에서 사용자 세션을 검색하고 삭제할 수 있다. 스프링 세션을 사용하는 서블릿 기반 웹 애플리케이션이 필요하다.|
|`shutdown`|애플리케이션을 정상적으로 종료할 수 있다. jar 패키징을 사용할 때만 작동한다. 일반적으로 비활성화되어 있다.|
|`startup`|`어플리케이션스타드업(ApplicationStartup)`에서 수집한 시작 단계 데이터를 표시한다. `버퍼링애플리케이션스타드업(BufferingApplicationStartup)`으로 구성하려면 `스프링애플리케이션(SpringApplication)`이 필요하다.|
|`threaddump`|스레드덤프를 수행한다.|


애플리케이션이 웹 애플리케이션(스프링 MVC, 스프링 웹플러스 또는 Jersey)인 경우 다음과 같은 추가 엔드포인트를 사용할 수 있다.

|ID|설명|
|---|---|
|`heapdump`|힙 덤프 파일을 반환한다. 핫스팟(HotSpot) JVM에서는 HPROF 타입의 파일이 반환된다. OpenJ9 JVM에서는 PHD 타입의 파일이 반환된다.|
|`logfile`|로그 파일의 내용을 반환한다(`logging.file.name` 또는 `login.file.path` 프로퍼티가 설정된 경우). 로그 파일 콘텐츠의 일부를 검색하기 위해 HTTP Range 헤더 사용을 지원한다.|
|`prometheus`|프로메테우스(Prometheus) 서버에서 스크랩할 수 있는 형식으로 측정항목을 노출한다. `micrometer-registry-prometheus`에 대한 의존성이 필요하다.|


### 13.2.1. 엔드포인트 활성화(Enabling Endpoints)
기본적으로 종료(shutdown)를 제외한 모든 엔드포인트는 활성화되어있다. 엔드포인트 활성화하려면 해당 `management.endpoint.<id>.enabled` 프로퍼티를 사용하자. 다음 예제에서는 종료 엔드포인트를 활성화한다.

`프로퍼티스(Properties)`
```
management.endpoint.shutdown.enabled=true
```

`Yaml`

```yaml
management:
  endpoint:
    shutdown:
      enabled: true
```

옵트아웃(opt-out)이 아닌 옵트인(opt-in)으로 엔드포인트 활성화를 선호하는 경우 `management.endpoints.enabled-by-default` 프로퍼티를 `false`로 설정하고 개별 엔드포인트 활성화 프로퍼티를 사용하여 다시 옵트인한다. 다음 예제에서는 `info` 엔드포인트를 활성화하고 다른 모든 엔드포인트를 비활성화한다.

`프로퍼티스(Properties)`
```
management.endpoints.enabled-by-default=false
management.endpoint.info.enabled=true
```

`Yaml`
```yaml
management:
    endpoints:
      enabled-by-default: false
    endpoint:
      info:
        enabled: true
```

{: .note}
비활성화된 엔드포인트는 애플리케이션 컨텍스트에서 완전히 제거된다. 엔드포인트가 노출되는 기술만 변경하려면 `include` 및 `exclude` 프로퍼티스를 사용하자.


### 13.2.2. 엔드포인트 노출(Exposing Endpoints)
기본적으로 상태 엔드포인트만 HTTP 및 JMX를 통해 노출된다. 엔드포인트에는 민감한 정보가 포함될 수 있으므로 이를 노출을 신중하게 고려해야 한다.

노출되는 엔드포인트를 변경하려면 다음 기술별 `include` 및 `exclude` 프로퍼티스를 사용하자.

|프로퍼티|기본값|
|---|---|
|`management.endpoints.jmx.exposure.exclude`||
|`management.endpoints.jmx.exposure.include`|`health`|
|`management.endpoints.web.exposure.exclude`||
|`management.endpoints.web.exposure.include`|`health`|

`include` 프로퍼티는 노출된 엔드포인트의 ID를 나열한다. `exclude` 프로퍼티는 노출되어서는 안 되는 엔드포인트의 ID를 나열한다. `exclude` 프로퍼티는 `include` 프로퍼티보다 우선된다. 엔드포인트 ID 목록을 사용하여 `include` 프로퍼티 및 `exclude` 프로퍼티을 모두 구성할 수 있다.

예를 들어, JMX를 통해서만 상태(health) 및 정보(info) 엔드포인트를 노출하려면 다음 프로퍼티를 사용한다.

`프로퍼티스(Properties)`
```
management.endpoints.jmx.exposure.include=health,info
```

`Yaml`
```yaml
management:
  endpoints:
    jmx:
      exposure:
        include: "health,info"
```

`*`를 사용하여 모든 엔드포인트를 선택할 수 있다. 예를 들어, `env` 및 `beans` 엔드포인트를 제외한 모든 것을 HTTP를 통해 노출하려면 다음 프로퍼티를 사용하자.

`프로퍼티스(Properties)`
```
management.endpoints.web.exposure.include=*
management.endpoints.web.exposure.exclude=env,beans
```

`Yaml`
```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
        exclude: "env,beans"
```

{: .note}
`*`는 YAML에서 특별한 의미를 가지므로 모든 엔드포인트를 포함(또는 제외)하려면 따옴표를 추가해야 한다.

{: .note}
애플리케이션이 공개적으로 노출되는 경우, 엔드포인트도 보호하는 것이 좋다.

{: .note}
엔드포인트가 노출에 대한 자체 전략을 구현하려면 `EndpointFilter` 빈을 등록할 수 있다.


### 13.2.3. 보안(Security)
보안을 위해 기본적으로 HTTP를 통해 `/health` 엔드포인트만 노출된다. `management.endpoints.web.exposure.include` 프로퍼티를 사용하여 노출되는 엔드포인트를 구성할 수 있다.

{: .note}
`management.endpoints.web.exposure.include`를 설정하기 전에 노출된 액추에이터에 민감한 정보가 포함되어 있지 않은지, 방화벽 뒤에 배치하여 보호되는지 또는 스프링 시큐리티와 같은 것으로 보호되는지 확인하자.

스프링 시큐리티가 클래스패스에 있고 다른 `SecurityFilterChain` 빈이 없는 경우 `/health`를 제외한 모든 액추에이터는 스프링 부트 자동 구성으로 보호된다. 커스텀 `SecurityFilterChain` 빈을 정의하면 스프링 부트 자동 구성이 중단되고 액추에이터 접근 규칙을 완전히 제어할 수 있다.

HTTP 엔드포인트에 대한 커스텀 보안을 구성하려는 경우(예: 특정 역할을 가진 사용자만 접근할 수 있도록 허용) 스프링 부트는 스프링 시큐리티와 함께 사용할 수 있는 몇 가지 편리한 `RequestMatcher` 객체를 제공한다.

일반적인 스프링 시큐리티 구성은 다음 예제와 유사할 수 있다.

`자바`
```java
import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;
import static org.springframework.security.config.Customizer.withDefaults;

@Configuration(proxyBeanMethods = false)
public class MySecurityConfiguration {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.securityMatcher(EndpointRequest.toAnyEndpoint());
        http.authorizeHttpRequests((requests) -> requests.anyRequest().hasRole("ENDPOINT_ADMIN"));
        http.httpBasic(withDefaults());
        return http.build();
    }
}
```

`코틀린`
```kotlin
import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.Customizer.withDefaults
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.web.SecurityFilterChain

@Configuration(proxyBeanMethods = false)
class MySecurityConfiguration {
    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http.securityMatcher(EndpointRequest.toAnyEndpoint()).authorizeHttpRequests { requests ->
            requests.anyRequest().hasRole("ENDPOINT_ADMIN")
        }
        http.httpBasic(withDefaults())
        return http.build()
    }
}
```

이전 예제에서는 `EndpointRequest.toAnyEndpoint()`를 사용하여 요청을 모든 엔드포인트에 일치시킨 다음 모든 엔드포인트에 `ENDPOINT_ADMIN` 역할이 있는지 확인한다. `EndpointRequest`에서는 다른 여러 매처(matcher) 메서드도 사용할 수 있다. 자세한 내용은 API 설명서([HTML](https://docs.spring.io/spring-boot/docs/3.1.1/actuator-api/htmlsingle/) 또는 PDF)를 참고하자.

방화벽 뒤에 애플리케이션을 배포하는 경우 인증 없이 모든 액추에이터 엔드포인트에 접근할 수 있는 것을 선호할 수 있다. 다음과 같이 `management.endpoints.web.exposure.include` 프로퍼티를 변경하면 된다.

`프로퍼티스(Properties)`
```
management.endpoints.web.exposure.include=*
```

`Yaml`
```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
```

또한, 스프링 시큐리티가 있는 경우 다음 예제와 같이 엔드포인트에 대한 인증되지 않은 접근를 허용하는 커스텀 보안 구성을 추가해야 한다.

`자바`
```java
import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration(proxyBeanMethods = false)
public class MySecurityConfiguration {
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http.securityMatcher(EndpointRequest.toAnyEndpoint());
    http.authorizeHttpRequests((requests) -> requests.anyRequest().permitAll());
    return http.build();
  } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.web.SecurityFilterChain

@Configuration(proxyBeanMethods = false)
class MySecurityConfiguration {
  @Bean
  fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
    http.securityMatcher(EndpointRequest.toAnyEndpoint()).authorizeHttpRequests { requests ->
      requests.anyRequest().permitAll()
    }
    return http.build()
  }
}
```

{: .note}
위의 두 예제에서 구성은 액추에이터 엔드포인트에만 적용된다. 스프링 부트의 보안 구성은 `SecurityFilterChain` 빈이 있는 경우 완전히 백오프되므로 애플리케이션의 나머지 부분에 적용되는 규칙을 사용하여 추가 `SecurityFilterChain` 빈을 구성해야 한다.


#### 크로스 사이트 요청 위조 방지(Cross Site Request Forgery Protection)
스프링 부트는 스프링 시큐리티의 기본값을 사용하므로 CSRF 보호는 기본적으로 켜져 있다. 이는 기본 보안 구성이 사용 중일 때 POST(종료 및 로거 엔드포인트), PUT 또는 DELETE가 필요한 액추에이터 엔드포인트에 403(금지됨) 오류가 발생함을 의미한다.

{: .note}
브라우저가 아닌 클라이언트에서 사용되는 서비스를 생성하는 경우에만 CSRF 보호를 완전히 비활성화하는 것이 좋다.

[스프링 시큐리티 레퍼런스 가이드](https://docs.spring.io/spring-security/reference/features/exploits/csrf.html)에서 CSRF 보호에 대한 추가 정보를 찾을 수 있다.


### 13.2.4. 엔드포인트 구성(Configuring Endpoints)
엔드포인트가 응답을 캐시하는 시간을 구성하려면 해당 `cache.time-to-live` 프로퍼티를 사용하자. 다음 예제에서는 빈 엔드포인트 캐시의 TTL(Time-To-Live)을 10초로 설정합니다.

`프로퍼티스(Properties)`
```
management.endpoint.beans.cache.time-to-live=10s
```

`Yaml`
```yaml
management:
  endpoint:
    beans:
      cache:
        time-to-live: "10s"
```

{: .note}
`management.endpoint.<name>` 접두사는 구성 중인 엔드포인트를 고유하게 식별한다.


### 13.2.5. 액추에이터 웹 엔드포인트를 위한 하이퍼미디어(Hypermedia for Actuator Web Endpoints)
모든 엔드포인트에 대한 링크가 포함된 "discovery page"가 ​​추가된다. "discovery page"는 기본적으로 `/actuator`에서 사용할 수 있다.

"discovery page"를 비활성화하려면 애플리케이션 프로퍼티스에서 다음 프로퍼티를 추가해보자.

`프로퍼티스(Properties)`
```
management.endpoints.web.discovery.enabled=false
```

`Yaml`
```yaml
management:
  endpoints:
    web:
      discovery:
        enabled: false
```

커스텀 관리 컨텍스트 패스가 구성되면 "discovery page"가 ​​자동으로 `/actuator`에서 관리 컨텍스트의 루트로 이동한다. 예를 들어 관리 컨텍스트 패스가 `/management`인 경우 `/management`에서 "discovery page"를 사용할 수 있다. 관리 컨텍스트 패스가 `/`로 설정되면 다른 매핑과의 충돌 가능성을 방지하기 위해 discovery page가 비활성화된다.


### 13.2.6. CORS 지원(CORS Support)
[CORS(Cross-Origin Resource Sharing)](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing)는 도메인 간 요청에 대한 승인을 유연하게 지정할 수 있는 [W3C 사양](https://fetch.spec.whatwg.org/)이다. 스프링 MVC 또는 스프링 웹플럭스를 사용하는 경우 이런 상황을 지원하도록 액츄에이터의 웹 엔드포인트를 구성할 수 있다.

CORS 지원은 기본적으로 비활성화되어 있으며 `management.endpoints.web.cors.allowed-origins` 프로퍼티를 설정한 후에만 활성화된다. 다음 구성은 `example.com` 도메인에서 GET 및 POST 호출을 허용한다.

`프로퍼티스(Properties)`
```
management.endpoints.web.cors.allowed-origins=https://example.com
management.endpoints.web.cors.allowed-methods=GET,POST
```

`Yaml`
```yaml
management:
  endpoints:
    web: 
      cors:
        allowed-origins: "https://example.com"
        allowed-methods: "GET,POST"
```

{: .note}
전체 옵션 목록은 [`CorsEndpointProperties`](https://github.com/spring-projects/spring-boot/blob/v3.1.1/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/CorsEndpointProperties.java)를 참고하자.


### 13.2.7. 커스텀 엔드포인트 구현(Implementing Custom Endpoints)
`@Endpoint` 어노테이션이 달린 `@Bean`을 추가하면 `@ReadOperation`, `@WriteOperation` 또는 `@DeleteOperation`으로 어노테이션이 달린 모든 메서드는 자동으로 JMX를 통해 노출되고 웹 애플리케이션에서는 HTTP를 통해서도 노출된다. Jersey, 스프링 MVC 또는 스프링 웹플럭스를 사용하여 HTTP를 통해 엔드포인트를 노출할 수 있다. Jersey와 스프링 MVC를 모두 사용할 수 있는 경우 스프링 MVC가 사용된다.


다음 예제에서는 커스텀 객체를 반환하는 리드 오퍼레이션(read operation)을 노출한다.

`자바`
```java
@ReadOperation
public CustomData getData() {
    return new CustomData("test", 5);
}
```

`코틀린`
```kotlin
@ReadOperation
fun getData(): CustomData {
    return CustomData("test", 5)
}
```

`@JmxEndpoint` 또는 `@WebEndpoint`를 사용하여 기술별 엔드포인트를 작성할 수도 있다. 이러한 엔드포인트는 해당 기술로 제한된다. 예를 들어 `@WebEndpoint`는 JMX가 아닌 HTTP를 통해서만 노출된다.

`@EndpointWebExtension` 및 `@EndpointJmxExtension`을 사용하여 기술별 확장을 작성할 수 있다. 이러한 어노테이션을 사용하면 기존 엔드포인트를 보강하는 기술별 작업을 제공할 수 있다.

마지막으로, 웹 프레임워크 특정 기능에 접근해야 하는 경우 `JMX`를 통해 또는 다른 웹 프레임워크를 사용할 때 사용할 수 없는 서블릿이나 스프링 `@Controller` 및 `@RestController` 엔드포인트를 구현할 수 있다.


#### 입력 받기(Receiving Input)
엔드포인트의 작업은 해당 파라미터를 통해 입력을 받는다. 웹을 통해 노출되면 이러한 파라미터의 값은 URL의 쿼리 파라미터와 JSON 요청 본문에서 가져온다. JMX를 통해 노출되면 파라미터는 MBean 작업의 파라미터에 매핑된다. 파라미터는 기본적으로 필수다. `@javax.annotation.Nullable` 또는 `@org.springframework.lang.Nullable`로 어노테이션을 달아 선택사항으로 만들 수 있다.

JSON 요청 본문(body)의 각 루트 프로퍼티를 엔드포인트의 파라미터에 매핑할 수 있다. 다음 JSON 요청 본문을 보자.

```
{
    "name": "test",
    "counter": 42
}
```

다음 예제와 같이 이를 사용하여 문자열명 및 int 카운터 파라미터를 사용하는 라이트 오퍼레이션(write operation)을 호출할 수 있다.

`자바`
```java
@WriteOperation
public void updateData(String name, int counter) {
    // "test"와 42 주입
}
```

`코틀린`
```kotlin
@WriteOperation
fun updateData(name: String?, counter: Int) {
    // "test"와 42 주입
}
```

{: .note}
엔드포인트는 기술에 구애받지 않으므로 메서드 시그니처에는 단순 타입만 지정할 수 있다. 특히 `CustomData` 타입으로 단일 파라미터를 선언하는 경우 이름 및 카운터 프로퍼티스를 정의하는 것은 지원되지 않는다.

{: .note}
입력이 작업 메서드의 파라미터에 매핑되도록 하려면 엔드포인트를 구현하는 자바 코드는 `-parameters`로 컴파일해야 하고, 엔드포인트를 구현하는 코틀린 코드는 `-java-parameters`로 컴파일해야 한다. 이는 스프링 부트의 그레이들 플러그인을 사용하거나 메이븐 및 `spring-boot-starter-parent`를 사용하는 경우 자동으로 발생한다.


##### 입력 유형 변환
엔드포인트 작업 메서드에 전달된 파라미터는 필요한 경우 필요한 타입으로 자동 변환된다. 작업 메서드를 호출하기 전에 JMX 또는 HTTP를 통해 수신된 입력은 `@EndpointConverter`로 정규화된 모든 컨버터(Converter) 또는 제네릭컨버터(GenericConverter) 빈뿐만 아니라 `ApplicationConversionService` 인스턴스를 사용하여 필요한 타입으로 변환된다.


#### 커스텀 웹 엔드포인트
`@Endpoint`, `@WebEndpoint` 또는 `@EndpointWebExtension`에 대한 작업은 Jersey, 스프링 MVC 또는 스프링 웹플럭스를 사용하여 HTTP를 통해 자동으로 노출된다. Jersey와 스프링 MVC를 모두 사용할 수 있는 경우 스피링 MVC가 사용된다.


##### 웹 엔드포인트 요청 조건자
웹에 노출된 엔드포인트의 각 작업에 대해 요청 조건자(predicate)가 자동으로 생성된다.


##### 경로
조건자의 경로는 엔드포인트의 ID와 웹에 노출된 엔드포인트의 기본 경로에 의해 결정된다. 기본 기본 경로는 `/actuator`다. 예를 들어 세션 ID가 있는 엔드포인트는 `/actuator/sessions`를 조건자의 경로로 사용한다.

`@Selector`를 사용하여 작업 메서드의 하나 이상의 파라미터에 어노테이션을 추가하여 경로를 추가로 커스텀할 수 있다. 이러한 파라미터는 경로 변수로 경로 조건자에 추가된다. 엔드포인트 작업이 호출되면 변수 값이 작업 메서드에 전달된다. 나머지 모든 경로 요소를 캡처하려면 마지막 파라미터에 `@Selector(Match=ALL_REMAINING)`를 추가하고 이를 `String[]`과 변환 ​​가능한 타입으로 만들 수 있다.


##### HTTP 메소드
조건자의 HTTP 메서드는 다음 표에 표시된 대로 작업 유형에 따라 결정된다.

|작업|HTTP 메소드|
|---|---|
|`@ReadOperation`|GET|
|`@WriteOperation`|POST|
|`@DeleteOperation`|DELETE|


###### 소비
요청의 본문을 사용하는 `@WriteOperation(HTTP POST)`의 경우, 조건자의 소비 절은 `application/vnd.spring-boot.actuator.v2+json`, `application/json`다. 다른 모든 작업의 ​​경우 `consumes` 절은 비어 있다.


###### 생산
조건자의 생산 절은 `@DeleteOperation`, `@ReadOperation` 및 `@WriteOperation` 어노테이션의 생산 애트리뷰트에 의해 결정될 수 있다. 애트리뷰트는 선택사항이다. 사용되지 않으면 생산 절이 자동으로 결정된다.

작업 메서드가 void 또는 Void를 반환하는 경우 생성 절은 비어 있다. 작업 메서드가 `org.springframework.core.io.Resource`를 반환하는 경우 생성 절은 `application/octet-stream`이다. 다른 모든 작업의 ​​경우 생산 절은 `application/vnd.spring-boot.actuator.v2+json`, `application/json`이다.


###### 웹 엔드포인트 응답 상태
엔드포인트 작업의 기본 응답 상태는 작업 타입(읽기, 쓰기 또는 삭제)과 작업이 반환하는 항목(있는 경우)에 따라 달라진다.

`@ReadOperation`이 값을 반환하는 경우 응답 상태는 200(정상)이 된다. 값을 반환하지 않는 경우 응답 상태는 404(찾을 수 없음)이다.

`@WriteOperation` 또는 `@DeleteOperation`이 값을 반환하는 경우 응답 상태는 200(정상)이 된다. 값을 반환하지 않는 경우 응답 상태는 204(콘텐츠 없음)이다.

필수 파라미터 없이 또는 필수 타입으로 변환할 수 없는 파라미터를 사용하여 작업을 호출하면 작업 메서드가 호출되지 않고 응답 상태가 400(Bad Request)이 된다.


###### 웹 엔드포인트 범위 요청
HTTP 범위 요청을 사용하여 HTTP 리소스의 일부를 요청할 수 있다. 스프링 MVC 또는 스프링 웹플럭스를 사용할 때 `org.springframework.core.io.Resource`를 반환하는 작업은 자동으로 범위 요청을 지원한다.

{: .note}
Jersey를 사용하는 경우 범위 요청이 지원되지 않는다.


###### 웹 엔드포인트 보안
웹 엔드포인트 또는 웹 특정 엔드포인트 확장에 대한 작업은 현재 `java.security.Principal` 또는 `org.springframework.boot.actuate.endpoint.SecurityContext`를 메서드 파라미터로 받을 수 있다. 전자는 일반적으로 `@Nullable`과 함께 사용되어 인증된 사용자와 인증되지 않은 사용자에게 서로 다른 동작을 제공한다. 후자는 일반적으로 `isUserInRole(String)` 메소드를 사용하여 권한 부여 확인을 수행하는 데 사용된다.


#### 서블릿 엔드포인트(Servlet Endpoints)
`@ServletEndpoint` 어노테이션이 달린 클래스를 구현하고 `@ServletEndpoint`도 구현하는 클래스를 구현하여 서블릿을 엔드포인트로 노출할 수 있다. 서블릿 엔드포인트는 서블릿 컨테이너와의 더 깊은 통합을 제공하지만 이식성은 좋지않다. 이는 기존 서블릿을 엔드포인트로 노출하는 데 사용된다. 새 엔드포인트의 경우 `@Endpoint` 및 `@WebEndpoint` 어노테이션을 선호한다.


#### 컨트롤러 엔드포인트(Controller Endpoints)
`@ControllerEndpoint` 및 `@RestControllerEndpoint`를 사용하여 스프링 MVC 또는 스프링 웹플럭스에 의해서만 노출되는 엔드포인트를 구현할 수 있다. 메서드는 `@RequestMapping` 및 `@GetMapping`과 같은 스프링 MVC 및 스프링 웹플럭스용 표준 어노테이션을 사용하여 매핑되며 엔드포인트의 ID는 경로의 접두사로 사용된다. 컨트롤러 엔드포인트는 스프링의 웹 프레임워크와의 더 깊은 통합을 제공하지만 이식성은 좋지않다. 가능하면 `@Endpoint` 및 `@WebEndpoint` 어노테이션을 선호해야 한다.


### 13.2.8. 상태 정보(Health Information)
상태 정보를 사용하여 실행 중인 애플리케이션의 상태를 확인할 수 있다. 이는 프로덕션 시스템이 다운될 때 누군가에게 경고하기 위해 모니터링 소프트웨어에서 자주 사용된다. 상태 엔드포인트에 의해 노출되는 정보는 다음 값 중 하나로 구성될 수 있는 `management.endpoint.health.show-details` 및 `management.endpoint.health.show-comComponents` 프로퍼티스에 따라 달라진다.


|명칭|설명|
|---|---|
|`never`|세부정보 표시되지 않음.|
|`when-authorized`|세부정보는 승인된 사용자에게만 표시된다. 승인된 역할은 `management.endpoint.health.roles`를 사용하여 구성할 수 있다.|
|`always`|세부정보는 모든 사용자에게 표시된다.|

기본값은 never다. 사용자가 하나 이상의 엔드포인트 역할에 속해 있으면 권한이 부여된 것으로 간주된다. 엔드포인트에 구성된 역할(기본값)이 없으면 인증된 모든 사용자는 권한이 부여된 것으로 간주한다. `management.endpoint.health.roles` 프로퍼티를 사용하여 역할을 구성할 수 있다.

{: .note}
애플리케이션을 보호하고 항상 사용하려면 보안 구성에서 인증된 사용자와 인증되지 않은 사용자 모두에 대해 상태 엔드포인트에 대한 접근를 허용해야 한다.

상태 정보는 `HealthContributorRegistry`(기본적으로 `ApplicationContext`에 정의된 모든 `HealthContributor` 인스턴스)의 콘텐츠에서 수집된다. 스프링 부트에는 자동으로 구성된 여러 `HealthContributors`가 포함되어 있으며 직접 작성할 수도 있다.

`HealthContributor`는 `HealthIndicator` 또는 `CompositeHealthContributor`일 수 있다. `HealthIndicator`는 상태를 포함한 실제 상태 정보를 제공한다. `CompositeHealthContributor`는 다른 `HealthContributors`을 제공한다. 컨트리뷰터는 종합적으로 트리 구조를 형성하여 전체 시스템 상태를 나타낸다.

기본적으로, 최종 시스템 상태는 순서가 지정된 상태 목록을 기반으로 각 `HealthIndicator`의 상태를 정렬하는 `StatusAggregator`에 의해 파생된다. 정렬된 목록의 첫 번째 상태는 전체 상태로 사용된다. `HealthIndicator`가 `StatusAggregator`에 알려진 상태를 반환하지 않으면 `UNKNOWN` 상태가 사용된다.

{: .note}
`HealthContributorRegistry`를 사용하여 런타임 시 `Health indicators`를 등록 및 등록 취소할 수 있다.


#### 헬스인디케이터 자동 구성(Auto-configured HealthIndicators)
적절한 경우, 스프링부트는 다음 표에 나열된 `HealthIndicator`를 자동 구성한다. 다음 표에 나열된 키를 사용하여 `management.health.key.enabled`를 구성하여 선택한 indicators를 활성화하거나 비활성화할 수도 있다.

|키|명칭|설명|
|---|---|---|
|`cassandra`|`CassandraDriverHealthIndicator`|카산드라 데이터베이스가 작동 중인지 확인한다.|
|`couchbase`|`CouchbaseHealthIndicator`|카우치베이스 클러스터가 작동 중인지 확인한다.|
|`db`|`DataSourceHealthIndicator`|데이터소스에 대한 연결을 얻을 수 있는지 확인한다.|
|`diskspace`|`DiskSpaceHealthIndicator`|디스크 공간이 부족한지 확인한다.|
|`elasticsearch`|`ElasticsearchRestHealthIndicator`|엘라스틱서치 클러스터가 작동 중인지 확인한다.|
|`hazelcast`|`HazelcastHealthIndicator`|Hazelcast 서버가 작동 중인지 확인한다.|
|`influxdb`|`InfluxDbHealthIndicator`|InfluxDB 서버가 작동 중인지 확인한다.|
|`jms`|`JmsHealthIndicator`|JMS 브로커가 작동 중인지 확인한다.|
|`ldap`|`LdapHealthIndicator`|LDAP 서버가 작동 중인지 확인한다.|
|`mail`|`MailHealthIndicator`|메일 서버가 작동 중인지 확인한다.|
|`mongo`|`MongoHealthIndicator`|몽고 데이터베이스가 작동 중인지 확인한다.|
|`neo4j`|`Neo4jHealthIndicator`|Neo4j 데이터베이스가 작동 중인지 확인한다.|
|`ping`|`PingHealthIndicator`|항상 UP으로 응답한다.|
|`rabbit`|`RabbitHealthIndicator`|Rabbit 서버가 작동 중인지 확인한다.|
|`redis`|`RedisHealthIndicator`|레디스 서버가 작동 중인지 확인한다.|

{: .note}
`management.health.defaults.enabled` 프로퍼티를 설정하여 이를 모두 비활성화할 수 있다.

추가 `HealthIndicators`를 사용할 수 있지만 기본적으로 활성화되어 있지 않다.


|키|명칭|설명|
|---|---|---|
|`livenessstate`|`LivenessStateHealthIndicator`|"Liveness" 애플리케이션 가용성 상태를 노출한다.|
|`readinessstate`|`ReadinessStateHealthIndicator`|"Readiness" 애플리케이션 가용성 상태를 노출한다.|


#### 커스텀 헬스인디케이터 작성. 리액티브 헬스인디케이터(Writing Custom HealthIndicators. Reactive Health Indicators)
커스텀 상태 정보를 제공하기 위해 `HealthIndicator` 인터페이스를 구현하는 스프링 빈을 등록할 수 있다. `health()` 메서드 구현을 제공하고 `Health` 응답을 반환해야 한다. 상태 응답에는 상태가 포함되어야 하며 선택적으로 표시할 추가 세부 정보를 포함할 수 있다. 다음 코드는 샘플 `HealthIndicator` 구현을 보여준다.

`자바`
```java
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class MyHealthIndicator implements HealthIndicator {
  @Override
  public Health health() {
      int errorCode = check();
      if (errorCode != 0) {
          return Health.down().withDetail("Error Code", errorCode).build();
      }
      return Health.up().build();
  }
  private int check() {
      // 특정 상태 점검을 수행한다.
      return ...
  } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.actuate.health.Health
import org.springframework.boot.actuate.health.HealthIndicator
import org.springframework.stereotype.Component

@Component
class MyHealthIndicator : HealthIndicator {
  override fun health(): Health {
      val errorCode = check()
      if (errorCode != 0) {
          return Health.down().withDetail("Error Code", errorCode).build()
      }
      return Health.up().build()
  }
  private fun check(): Int {
      // 특정 상태 점검을 수행한다.
      return  ...
  } 
}
```

{: .note}
주어진 `HealthIndicator`의 식별자는 `HealthIndicator` 접미사가 없는 빈의 이름이다(존재하는 경우). 앞의 예에서 상태 정보는 my라는 항목에서 사용할 수 있다.

{: .note}
상태 표시기(Health indicator)는 일반적으로 HTTP를 통해 호출되며 연결 시간이 초과되기 전에 응답해야 한다. 스프링 부트는 응답하는 데 10초 이상 걸리는 상태 표시기에 대한 경고 메시지를 기록한다. 이 임계값을 구성하려면 `management.endpoint.health.logging.slow-indicator-threshold` 프로퍼티를 사용할 수 있다.

스프링 부트의 사전 정의된 상태 타입 외에도 `Health`는 새로운 시스템 상태를 나타내는 커스텀 상태를 반환할 수 있다. 이러한 경우 `StatusAggregator` 인터페이스의 커스텀 구현도 제공해야 한다. 또는 `management.endpoint.health.status.order` 구성 프로퍼티를 사용하여 기본 구현을 구성해야 한다.

예를 들어, `HealthIndicator` 구현 중 하나에서 `FATAL` 코드가 포함된 새 상태가 사용되고 있다고 가정하자. 심각도 순서를 구성하려면 애플리케이션 프로퍼티에 다음 프로퍼티스를 추가하자.


`프로퍼티스(Properties)`
```
management.endpoint.health.status.order=fatal,down,out-of-service,unknown,up
```

`Yaml`
```yaml
management:
  endpoint:
    health:
      status:
        order: "fatal,down,out-of-service,unknown,up"
```

응답의 HTTP 상태 코드는 전반적인 상태를 나타낸다. 기본적으로 `OUT_OF_SERVICE` 및 `DOWN`은 `503`에 매핑된다. `UP`을 포함하여 매핑되지 않은 모든 상태는 `200`에 매핑된다. HTTP를 통해 상태 엔드포인트에 접근하는 경우 커스텀 상태 매핑을 등록할 수도 있다. 커스텀 매핑을 구성하면 `DOWN` 및 `OUT_OF_SERVICE에` 대한 기본 매핑이 비활성화된다. 기본 매핑을 유지하려면 사용자 지정 매핑과 함께 이를 명시적으로 구성해야 한다. 예를 들어, 다음 프로퍼티는 `FATAL`을 503(서비스 사용 불가)에 매핑하고 `DOWN` 및 `OUT_OF_SERVICE`에 대한 기본 매핑을 유지한다.

`프로퍼티스(Properties)`
```
management.endpoint.health.status.http-mapping.down=503
management.endpoint.health.status.http-mapping.fatal=503
management.endpoint.health.status.http-mapping.out-of-service=503
```

`Yaml`
```yaml
management:
  endpoint:
    health:
      status:
        http-mapping:
          down: 503
          fatal: 503
          out-of-service: 503
```

{: .note}
더 많은 제어가 필요한 경우, 자체 `HttpCodeStatusMapper` 빈을 정의할 수 있다.

다음 표는 기본 제공 상태에 대한 기본 상태 매핑을 보여준다.

|상태|매핑|
|---|---|
|`DOWN`|`SERVICE_UNAVAILABLE` (`503`)|
|`OUT_OF_SERVICE`|`SERVICE_UNAVAILABLE` (`503`)|
|`UP`|No mapping by default, so HTTP status is `200`|
|`UNKNOWN`|No mapping by default, so HTTP status is `200`|


#### 자동 구성된 리액티브헬스인디케이터 상태 그룹(Auto-configured ReactiveHealthIndicators Health Groups)
적절한 경우 스프링 부트는 다음 리액티브헬스인디케이터(ReactiveHealthIndicator)를 자동 구성한다.

|키|명칭|설명|
|---|---|---|
|`cassandra`|`CassandraDriverReactiveHealthIndicator`|카산드라 데이터베이스가 작동 중인지 확인한다.|
|`couchbase`|`CouchbaseReactiveHealthIndicator`|카우치베이스 클러스터가 작동 중인지 확인한다.|
|`elasticsearch`|`ElasticsearchReactiveHealthIndicator`|엘라스틱서치 클러스터가 작동 중인지 확인한다.|
|`mongo`|`MongoReactiveHealthIndicator`|몽고 데이터베이스가 작동 중인지 확인한다.|
|`neo4j`|`Neo4jReactiveHealthIndicator`|Neo4j 데이터베이스가 작동 중인지 확인한다.|
|`redis`|`RedisReactiveHealthIndicator`|레디스 서버가 작동 중인지 확인한다.|

{: .note}
필요한 경우 리액티브 표시기(indicator)가 일반 표시기를 대체한다. 또한 명시적으로 처리되지 않은 헬스인디케이터(HealthIndicator)는 자동으로 래핑된다.

##### 상태 그룹(Health Groups)
상태 표시기를 다양한 목적으로 사용할 수 있는 그룹으로 구성하는 것이 유용한 경우가 있다.

상태 표시기 그룹을 추가하려면 `management.endpoint.health.group.<name>` 특성을 사용하고, 포함하거나 제외할 상태 표시기 ID 목록을 지정할 수 있다. 예를 들어, 데이터베이스 상태 표시기만 포함하는 그룹을 생성하려면 다음을 정의할 수 있다.

`프로퍼티스(Properties)`
```
management.endpoint.health.group.custom.include=db
```

`Yaml`
```yaml
management:
  endpoint:
    health:
      group:
        custom:
          include: "db"
```

그런 다음 localhost:8080/actuator/health/custom을 눌러 결과를 확인할 수 있다.

마찬가지로, 그룹에서 데이터베이스 상태 표시기를 제외하고, 다른 모든 표시기를 포함하는 그룹을 생성하려면 다음을 정의할 수 있다.

`프로퍼티스(Properties)`
```
management.endpoint.health.group.custom.exclude=db
```

`Yaml`
```yaml
management:
  endpoint:
    health:
      group:
        custom:
          exclude: "db"
```

기본적으로 상태 그룹에 존재하지 않는 상태 표시기가 포함되거나 제외되면 시작이 실패한다. 이 동작을 비활성화하려면 `management.endpoint.health.validate-group-membership`을 `false`로 설정하자.

기본적으로, 그룹은 시스템 상태와 동일한 `StatusAggregator` 및 `HttpCodeStatusMapper` 설정을 상속한다. 그러나 그룹별로 이를 정의할 수도 있다. 필요한 경우 `show-details` 및 `roles` 프로퍼티스을 오버라이드할 수도 있다.

`프로퍼티스(Properties)`
```
management.endpoint.health.group.custom.show-details=when-authorized
management.endpoint.health.group.custom.roles=admin
management.endpoint.health.group.custom.status.order=fatal,up
management.endpoint.health.group.custom.status.http-mapping.fatal=500
management.endpoint.health.group.custom.status.http-mapping.out-of-service=500
```

`Yaml`
```yaml
management:
  endpoint:
    health:
      group:
        custom:
          show-details: "when-authorized"
          roles: "admin"
          status:
            order: "fatal,up"
            http-mapping:
              fatal: 500
              out-of-service: 500
```

{: .note}
그룹과 함께 사용할 커스텀 `StatusAggregator` 또는 `HttpCodeStatusMapper` 빈을 등록해야 하는 경우 `@Qualifier("groupname")`를 사용할 수 있다.

상태 그룹은 `CompositeHealthContributor`를 포함/제외할 수도 있다. `CompositeHealthContributor`의 특정 컴포넌트만 포함/제외할 수도 있다. 이는 다음과 같이 컴포넌트의 정규화된 이름을 사용하여 수행할 수 있다.

```
management.endpoint.health.group.custom.include="test/primary"
management.endpoint.health.group.custom.exclude="test/primary/b"
```


위의 예제에서 커스텀 그룹에는 복합 테스트의 컴포넌트인 `primary`라는 이름의 `HealthContributor`가 포함된다. 여기서 기본 자체는 복합이며 이름이 primary인 `HealthContributor`는 커스텀 그룹에서 제외된다.

상태 그룹은 기본 포트나 관리 포트의 추가 경로에서 사용할 수 있다. 이는 보안 목적으로 액추에이터 엔드포인트에 별도의 관리 포트를 사용하는 것이 일반적으로 쿠버네티스와 같은 클라우드 환경에서 유용하다. 별도의 포트를 사용하면 상태 확인에 성공하더라도 기본 애플리케이션이 제대로 작동하지 않을 수 있으므로 상태 확인을 신뢰할 수 없게 될 수 있다. 상태 그룹은 다음과 같은 추가 경로로 구성할 수 있다.

```
management.endpoint.health.group.live.additional-path="server:/healthz"
```

이렇게 하면 `/healthz`의 기본 서버 포트에서 라이브 상태 그룹을 사용할 수 있다. 접두사는 필수이며 `server:`(기본 서버 포트를 나타냄) 또는 `management:`(구성된 경우 관리 포트를 나타냄)이어야 한다. 경로는 단일 경로 세그먼트여야 한다.

##### 데이터소스 상태(DataSource Health)
`데이터소스(DataSource)` 상태 표시기는 표준 데이터 소스와 라우팅 데이터 소스 빈 모두의 상태를 표시한다. 라우팅 데이터 소스의 상태는 각 대상 데이터 소스의 상태가 포함된다. 상태 엔드포인트의 응답에서 각 라우팅 데이터 원본의 대상은 해당 라우팅 키를 사용하여 이름이 지정된다. 표시기 출력에 라우팅 데이터 소스를 포함하지 않으려면 `management.health.db.ignore-routing-data-sources`를 `true`로 설정하자.


### 13.2.9. 쿠버네티스 프로브(Kubernetes Probes)
쿠버네티스에 배포된 애플리케이션은 컨테이너 프로브를 통해 내부 상태에 대한 정보를 제공할 수 있다. 쿠버네티스 구성에 따라 `kubelet`은 해당 프로브를 호출하고 결과에 반응한다.

기본적으로, 스프링 부트는 애플리케이션 가용성 상태를 관리한다. 쿠버네티스 환경에 배포된 경우 액츄에이터는 `애플리케이션어베일러빌러티(ApplicationAvailability)` 인터페이스에서 "활성" 및 "준비" 정보를 수집하고 전용 상태 표시기인 `LivenessStateHealthIndicator` 및 `ReadinessStateHealthIndicator`에서 해당 정보를 사용한다. 이러한 표시기는 전역 상태 엔드포인트("/actuator/health")에 표시된다. 또한 상태 그룹 "/actuator/health/liveness" 및 "/actuator/health/readiness"를 사용하여 별도의 HTTP 프로브로 노출된다.

그런 다음 다음 엔드포인트 정보를 사용하여 쿠버네티스 인프라를 구성할 수 있다.

```
livenessProbe:
  httpGet:
    path: "/actuator/health/liveness"
    port: <actuator-port>
  failureThreshold: ...
  periodSeconds: ...
readinessProbe:
  httpGet:
    path: "/actuator/health/readiness"
    port: <actuator-port>
  failureThreshold: ...
  periodSeconds: ...
```

{: .note}
`<actuator-port>`는 액츄에이터 엔드포인트를 사용할 수 있는 포트로 설정되어야 한다. 기본 웹 서버 포트일 수도 있고 "management.server.port" 프로퍼티가 설정된 경우 별도의 관리 포트일 수도 있다.


이러한 상태 그룹은 애플리케이션이 쿠버네티스 환경에서 실행되는 경우에만 자동으로 활성화된다. `management.endpoint.health.probes.enabled` 구성 프로퍼티를 사용하여 모든 환경에서 이를 활성화할 수 있다.

{: .note}
>애플리케이션이 구성된 활성 기간보다 시작하는 데 시간이 더 오래 걸리는 경우 쿠버네티스는 솔루션으로 "startupProbe"를 언급한다. 일반적으로 모든 시작 작업이 완료될 때까지 "readinessProbe"가 실패하므로 여기서는 "startupProbe"가 반드시 필요하지는 않다. 이는 애플리케이션이 준비될 때까지 트래픽을 수신하지 않는다는 의미다. 그러나 애플리케이션을 시작하는 데 오랜 시간이 걸리는 경우 "startupProbe"를 사용하여 쿠버네티스가 시작하는 동안 애플리케이션을 종료하지 않도록 하는 것이 좋다. 애플리케이션 생명주기 동안 프로브가 작동하는 방식을 설명하는 장을 참고하자.

액츄에이터 엔드포인트가 별도의 관리 컨텍스트에 배포된 경우 엔드포인트는 기본 애플리케이션과 동일한 웹 인프라(포트, 연결 풀, 프레임워크 컴포넌트)를 사용하지 않는다. 이 경우 기본 애플리케이션이 제대로 작동하지 않더라도(예: 새 연결을 수락할 수 없음) 프로브 검사에 성공할 수 있다. 이러한 이유로 활성 상태 및 준비 상태 그룹을 기본 서버 포트에서 사용할 수 있도록 만드는 것이 좋다. 이는 다음 프로퍼티를 설정하여 수행할 수 있다.

```
management.endpoint.health.probes.add-additional-paths=true
```

이렇게 하면 기본 서버 포트의 `/livez`에서 활성 상태를 사용할 수 있고 `readyz`를 준비 상태로 만들 수 있다.


#### 쿠버네티스 프로브로 외부 상태 확인(Checking External State With Kubernetes Probes)
액추에이터는 "활성" 및 "준비" 프로브를 상태 그룹으로 구성한다. 이는 모든 상태 그룹 기능을 사용할 수 있음을 의미한다. 예를 들어 추가 상태 표시기를 구성할 수 있습니다.

`프로퍼티스(Properties)`
```
management.endpoint.health.group.readiness.include=readinessState,customCheck
```

`Yaml`
```yaml
management:
  endpoint:
    health:
      group:
        readiness:
          include: "readinessState,customCheck"
```

기본적으로, 스프링 부트는 이러한 그룹에 다른 상태 표시기를 추가하지 않는다.

"활성" 프로브는 외부 시스템 상태 확인에 의존해서는 안 된다. 애플리케이션의 활성 상태가 손상된 경우 쿠버네티스는 애플리케이션 인스턴스를 재시작하여 해당 문제를 해결하려고 한다. 이는 외부 시스템(예: 데이터베이스, 웹 API 또는 외부 캐시)에 오류가 발생하면 쿠버네티스가 모든 애플리케이션 인스턴스를 재시작하고 연속적으로 실패할 수 있음을 의미한다.

"준비 상태" 프로브의 경우 애플리케이션 개발자는 외부 시스템 검사를 신중하게 선택해야 한다. 이러한 이유로 스프링 부트는 준비 상태 프로브에 추가 상태 확인을 포함하지 않는다. 애플리케이션 인스턴스의 준비 상태가 준비되지 않은 경우 쿠버네티스는 해당 인스턴스로 트래픽을 라우팅하지 않는다. 일부 외부 시스템은 애플리케이션 인스턴스에서 공유되지 않을 수 있으며, 이 경우 준비 상태 프로브에 포함될 수 있다. 다른 외부 시스템은 애플리케이션에 필수적이지 않을 수 있으며(애플리케이션에 서킷 브레이커(circuit breakers) 및 폴백이 있을 수 있음), 이 경우에는 반드시 포함되어서는 안 된다. 불행하게도 모든 애플리케이션 인스턴스가 공유하는 외부 시스템은 공통적이므로 판단을 내려야 한다. 이를 준비 상태 프로브에 포함하고 외부 서비스가 다운되면 애플리케이션이 서비스에서 제외될 것으로 예상한다. 호출자에서 서킷 브레이커를 사용하여 스택 위쪽의 오류를 처리한다.


{: .note}
>애플리케이션의 모든 인스턴스가 준비되지 않은 경우 `type=ClusterIP` 또는 `NodePort`인 쿠버네티스 서비스는 들어오는 연결을 허용하지 않는다. 연결이 없기 때문에 HTTP 오류 응답(503 등)이 없다. `type=LoadBalancer`인 서비스는 공급자에 따라 연결을 허용할 수도 있고 허용하지 않을 수도 있다. 명시적인 수신이 있는 서비스는 구현에 따라 응답한다. 수신 서비스 자체는 다운스트림에서 "거부된 연결"을 처리하는 방법을 결정해야 한다. 로드 밸런서와 수신 모두에서 HTTP 503이 발생할 가능성이 높다.

또한 애플리케이션이 쿠버네티스 오토스케일링을 사용하는 경우 오토스케일링 구성에 따라 로드 밸런서에서 제거되는 애플리케이션에 다르게 반응할 수 있다.


#### 애플리케이션 생명주기 및 프로브 상태(Application Lifecycle and Probe States)
쿠버네티스 프로브 지원의 중요한 측면은 애플리케이션 생명주기와 일관성이다. `AvailabilityState`(애플리케이션의 인 메모리 내부의 상태)와 실제 프로브(해당 상태를 노출함) 사이에는 상당한 차이가 있다. 애플리케이션 수명주기 단계에 따라 프로브를 사용하지 못할 수도 있습니다.

스프링 부트는 시작 및 종료 중에 애플리케이션 이벤트를 게시하고 프로브는 이러한 이벤트를 수신하고 `AvailabilityState` 정보를 노출할 수 있다.

다음 표는 `AvailabilityState`와 다양한 단계의 HTTP 커넥터 상태를 보여준다.

스프링 부트 애플리케이션이 시작될 때.

|시작 단계|LivenessState|ReadinessState|HTTP server|노트|
|---|---|---|---|---|
|Starting|`BROKEN`|`REFUSING_TRAFFIC`|Not started|쿠버네티스는 "활성" 프로브를 확인하고 시간이 너무 오래 걸리는 경우 애플리케이션을 재시작한다.|
|Started|`CORRECT`|`REFUSING_TRAFFIC`|애플리케이션 컨텍스트가 새로고침된다. 애플리케이션은 시작 작업을 수행하지만 아직 트래픽을 수신하지 않는다.|
|Ready|`CORRECT`|`ACCEPTING_TRAFFIC`|Accepts requests|시작 작업이 완료됐다. 애플리케이션이 트래픽을 수신하고 있다.|

스프링 부트 애플리케이션이 종료될 때.

|종료 단계|Liveness State|Readiness State|HTTP server|노트|
|---|---|---|---|---|
|Running|`CORRECT`|`ACCEPTING_TRAFFIC`|Accepts requests|종료가 요청됐다.|
|Graceful shutdown|`CORRECT`|`REFUSING_TRAFFIC`|New requests are rejected|활성화되면 종료가 단계적으로 요청을 처리한다.|
|Shutdown complete|N/A|N/A|Server is shut down|애플리케이션 컨텍스트가 닫히고 애플리케이션이 종료된다.|

{: .note}
쿠버네티스 디플로이먼트에 대한 자세한 내용은 쿠버네티스 컨테이너 생명 주기 장을 참고하자.


### 13.2.10. 애플리케션 정보(Application Information)
Application information exposes various information collected from all InfoContributor beans defined in your ApplicationContext. Spring Boot includes a number of auto-configured InfoContributor beans, and you can write your own.

#### 자동 구성된 인포컨트리뷰터(Auto-configured InfoContributors)
적절한 경우 스프링은 다음 인포컨트리뷰터(InfoContributor) 빈을 자동 구성한다.

|ID|명칭|설명|전제조건|
|---|---|---|---|
|`build`|`BuildInfoContributor`|빌드 정보를 노출한다.|`META-INF/build-info.properties` 리소스.|
|`env`|`EnvironmentInfoContributor`|이름이 `info..`로 시작하는 `Environment`의 모든 프로퍼티를 노출한다.|None.|
|`git`|`GitInfoContributor`|깃 정보를 노출합니다.|`git.properties` 리소스.|
|`java`|`JavaInfoContributor`|자바 런타임 정보를 노출한다.|None.|
|`os`|`OsInfoContributor`|운영 체제 정보를 노출한다.|None.|

개별 컨트리뷰터 활성화 여부는 `management.info.<id>.enabled` 프로퍼티에 의해 제어된다. 컨트리뷰터마다 전제조건과 노출 정보의 성격에 따라 이 프로퍼티에 대한 기본값이 다르다.

활성화를 나타내는 전제조건이 없으면 `env`, `java` 및 `os` 컨트리뷰터는 기본적으로 비활성화된다. 각각은 `management.info.<id>.enabled` 프로퍼티를 `true`로 설정하여 활성화할 수 있다.

`build` 및 `git` 정보 컨트리뷰터는 기본적으로 활성화된다. 각각은 `management.info.<id>.enabled` 프로퍼티를 `false`로 설정하여 비활성화할 수 있다. 또는 일반적으로 기본적으로 활성화되어 있는 모든 컨트리뷰터를 비활성화하려면 `management.info.defaults.enabled` 프로퍼티를 `false`로 설정하자.


#### 커스텀 애플리케이이션 정보(Custom Application Information)
`env` 컨트리뷰터가 활성화되면 `info.*` 스프링 프로퍼티스를 설정하여 `info` 엔드포인트에서 노출되는 데이터를 커스텀할 수 있다. `info` 키 아래의 모든 `Environment` 프로퍼티스는 자동으로 노출된다. 예를 들어 `application.properties` 파일에 다음 설정을 추가할 수 있다.

`프로퍼티스(Properties)`
```
info.app.encoding=UTF-8
info.app.java.source=17
info.app.java.target=17
```

`Yaml`
```yaml
info: 
  app:
    encoding: "UTF-8"
    java:
      source: "17"
      target: "17"
```

`TIP`

---

해당 값을 하드코딩하는 대신 빌드 시 `info` 프로퍼티스를 확장할 수도 있다.

메이븐을 사용한다고 가정하면 이전 예제를 다음과 같이 재작성할 수 있다.

`프로퍼티스(Properties)`
```
info.app.encoding=@project.build.sourceEncoding@
info.app.java.source=@java.version@
info.app.java.target=@java.version@
```

`Yaml`
```yaml
info: 
  app:
    encoding: "@project.build.sourceEncoding@"
    java:
      source: "@java.version@"
      target: "@java.version@"
```

---

#### 깃 커밋 정보(Git Commit Information)
`info` 엔드포인트의 또 다른 유용한 기능은 프로젝트가 빌드될 때 깃 소스 코드 리포지터리의 상태에 대한 정보를 게시하는 기능이다. `GitProperties` 빈을 사용할 수 있는 경우 `info` 엔드포인트를 사용하여 이러한 프로퍼티스를 노출할 수 있다.

{: .note}
`GitProperties` 빈은 클래스패스의 루트에서 `git.properties` 파일을 사용할 수 있는 경우 자동으로 구성된다. 자세한 내용은 "깃 정보 생성 방법"을 참고하자.

기본적으로, 엔드포인트는 `git.branch`, `git.commit.id` 및 `git.commit.time` 프로퍼티를 노출한다. 엔드포인트 응답에서 이러한 프로퍼티스를 원하지 않는 경우 `git.properties` 파일에서 제외해야 한다. 전체 깃 정보(즉, `git.properties`의 전체 내용)를 표시하려면 다음과 같이 `management.info.git.mode` 프로퍼티를 사용하자.

`프로퍼티스(Properties)`
```
management.info.git.mode=full
```

`Yaml`
```yaml
management:
  info:
    git:
      mode: "full"
```

`info` 엔드포인트에서 깃 커밋 정보를 완전히 비활성화하려면 다음과 같이 `management.info.git.enabled` 프로퍼티를 `false`로 설정한다.

`프로퍼티스(Properties)`
```
management.info.git.enabled=false
```

`Yaml`
```yaml
management:
  info:
    git:
      enabled: false
```


#### 빌드 정보(Build Information)
`BuildProperties` 빈을 사용할 수 있는 경우, `info` 엔드포인트는 빌드에 대한 정보를 게시할 수도 있다. 이는 클래스패스에 `META-INF/build-info.properties` 파일을 사용할 수 있는 경우다.

{. note}
메이븐과 그레이들 플러그인 모두 해당 파일을 생성할 수 있다. 자세한 내용은 "빌드 정보 생성 방법"을 참고하자.


#### 자바 정보(Java Information)
`info` 엔드포인트는 자바 런타임 환경에 대한 정보를 제공한다. 자세한 내용은 `JavaInfo`를 참고하자.
The info endpoint publishes information about your Java runtime environment, see JavaInfo for more details.


#### OS 정보(OS Information)
`info` 엔드포인트는 운영 체제에 대한 정보를 제공한다. 자세한 내용은 `OsInfo`를 참고하자.


#### 커스텀 인포컨트리뷰터 개발(Writing Custom InfoContributors)
애플리케이션의 커스텀 정보를 제공하기 위해 `InfoContributor` 인터페이스를 구현하는 스프링 빈을 등록할 수 있다.

다음 예제에서는 `example` 항목의 한가지 값을 제공한다.

`자바`
```java
import java.util.Collections;
import org.springframework.boot.actuate.info.Info;
import org.springframework.boot.actuate.info.InfoContributor;
import org.springframework.stereotype.Component;

@Component
public class MyInfoContributor implements InfoContributor {
    @Override
    public void contribute(Info.Builder builder) {
        builder.withDetail("example", Collections.singletonMap("key", "value"));
    }
}
```

`코틀린`
```kotlin
import org.springframework.boot.actuate.info.Info
import org.springframework.boot.actuate.info.InfoContributor
import org.springframework.stereotype.Component
import java.util.Collections

@Component
class MyInfoContributor : InfoContributor {
  override fun contribute(builder: Info.Builder) {
      builder.withDetail("example", Collections.singletonMap("key", "value"))
  } 
}
```

`info` 엔드포인트에 도달하면, 다음 추가 항목이 포함된 응답이 표시된다.

If you reach the info endpoint, you should see a response that contains the following additional entry:

```
{
  "example": {
    "key" : "value"
  }
}
```


## 13.3. HTTP 모니터링과 관리(Monitoring and Management Over HTTP)
웹 애플리케이션을 개발하는 경우 스프링 부트 액추에이터는 활성화된 모든 엔드포인트가 HTTP를 통해 노출되도록 자동 구성한다. 기본 규칙은 `/actuator` 접두사가 있는 엔드포인트 ID를 URL 경로로 사용하는 것이다. 예를 들어 상태 정보는 `/actuator/health`로 노출된다.

{: .note}
액추에이터는 스프링 MVC, 스프링 웹플럭스 및 저지(Jersey)에서 기본적으로 지원된다. 저지와 스프링 MVC를 모두 사용할 수 있는 경우 스프링 MVC가 사용된다.

{: .note}
잭슨은 API 문서(HTML 또는 PDF)에 설명된 대로 올바른 JSON 응답을 얻기 위해 필요한 의존성이다.


### 13.3.1. 관리 엔드포인트 경로 커스텀(Customizing the Management Endpoint Paths)
경우에 따라 관리 엔드포인트의 접두사를 커스텀하는 것이 유용한 상황이 있다. 예를 들어 애플리케이션이 이미 다른 목적으로 `/actuator`를 사용하고 있을 수 있다. 다음 예제에 표시된 것처럼 `management.endpoints.web.base-path` 프로퍼티를 사용하여 관리 엔드포인트의 접두사를 변경할 수 있다.

`프로퍼티스(Properties)`
```
management.endpoints.web.base-path=/manage
```

`Yaml`
```yaml
management:
  endpoints:
    web:
      base-path: "/manage"
```

이전 `application.properties` 예제에서는 엔드포인트를 `/actuator/{id}`에서 `/manage/{id}`(예: /manage/info)로 변경한다.

{: .note}
관리 포트가 다른 HTTP 포트를 사용하여 엔드포인트를 노출하도록 구성되지 않은 한, `management.endpoints.web.base-path`는 `server.servlet.context-path`(서블릿 웹 애플리케이션의 경우) 또는 `spring.webflux.base-path`에 상대적이다. (리액티브 웹 애플리케이션의 경우) `management.server.port`가 구성된 경우 `management.endpoints.web.base-path`는 `management.server.base-path`에 상대적이다.

엔드포인트를 다른 경로에 매핑하려면 `management.endpoints.web.path-mapping` 프로퍼티를 사용할 수 있다.

다음 예제에서는 `/actuator/health`를 `/healthcheck`로 다시 매핑한다.

`프로퍼티스(Properties)`
```
management.endpoints.web.base-path=/
management.endpoints.web.path-mapping.health=healthcheck
```

`Yaml`
```yaml
management:
  endpoints:
    web:
      base-path: "/"
      path-mapping:
        health: "healthcheck"
```


### 13.3.2. 관리 서버 포트 커스텀(Customizing the Management Server Port)
기본 HTTP 포트를 사용하여 관리 엔드포인트를 노출하는 것은 클라우드 배포엔 적합한 선택이다. 그러나 애플리케이션이 자체 데이터 센터 내에서 실행되는 경우 다른 HTTP 포트를 사용하여 엔드포인트를 노출하는 것이 좋다.

다음 예제와 같이 `management.server.port` 프로퍼티를 설정하여 HTTP 포트를 변경할 수 있다.

`프로퍼티스(Properties)`
```
management.server.port=8081
```

`Yaml`
```yaml
management:
  server:
    port: 8081
```

{: .note}
클라우드 파운드리에서 기본적으로 애플리케이션은 HTTP 및 TCP 라우팅 모두에 대해 포트 8080에서만 요청을 수신한다. 클라우드 파운드리에서 커스텀 관리 포트를 사용하려면 트래픽을 커스텀 포트로 전달하도록 애플리케이션의 경로를 명시적으로 설정해야 한다.


### 13.3.3. 관리별 SSL 구성(Configuring Management-specific SSL)
커스텀 포트를 사용하도록 구성한 경우 다양한 `management.server.ssl.*` 프로퍼티스를 사용하여 자체 SSL로 관리 서버를 구성할 수도 있다. 예를 들어, 이렇게 하면 다음 프로퍼티 설정에 표시된 것처럼 메인 애플리케이션이 HTTPS를 사용하는 동안 HTTP를 통해 관리 서버를 사용할 수 있다.

`프로퍼티스(Properties)`
```
server.port=8443
server.ssl.enabled=true
server.ssl.key-store=classpath:store.jks
server.ssl.key-password=secret
management.server.port=8080
management.server.ssl.enabled=false
```

`Yaml`
```yaml
server:
    port: 8443
    ssl:
      enabled: true
      key-store: "classpath:store.jks"
      key-password: "secret"
  management:
    server:
      port: 8080
      ssl:
        enabled: false
```

또는, 메인 서버와 관리 서버 모두 SSL을 사용할 수 있지만 다음과 같이 키 저장소가 다르다.

`프로퍼티스(Properties)`
```
server.port=8443
server.ssl.enabled=true
server.ssl.key-store=classpath:main.jks
server.ssl.key-password=secret
management.server.port=8080
management.server.ssl.enabled=true
management.server.ssl.key-store=classpath:management.jks
management.server.ssl.key-password=secret
```

`Yaml`
```yaml
server:
  port: 8443
  ssl:
    enabled: true
    key-store: "classpath:main.jks"
    key-password: "secret"
management:
  server:
    port: 8080
    ssl:
      enabled: true
      key-store: "classpath:management.jks"
      key-password: "secret"
```


### 13.3.4. 관리 서버 주소 커스텀(Customizing the Management Server Address)
`management.server.address` 프로퍼티를 설정하여 관리 엔드포인트를 사용할 수 있는 주소를 커스텀할 수 있다. 이렇게 하면 내부 또는 운영 네트워크에서만 수신 대기하거나 `localhost`의 연결만 수신하려는 경우 유용할 수 있다.

{: .note}
포트가 기본 서버 포트와 다른 경우에만 다른 주소에서 수신 대기할 수 있다.

다음 예제 `application.properties`는 원격 관리에 대한 커넥션을 허용하지 않는다.

`프로퍼티스(Properties)`
```
management.server.port=8081
management.server.address=127.0.0.1
```

`Yaml`
```yaml
management:
  server:
    port: 8081
    address: "127.0.0.1"
```


### 13.3.5. HTTP 엔드포인트 비활성화(Disabling HTTP Endpoints)
HTTP를 통해 엔드포인트를 노출하지 않으려면 다음 예제와 같이 관리 포트를 -1로 설정할 수 있다.

`프로퍼티스(Properties)`
```
management.server.port=-1
```

`Yaml`
```yaml
management:
  server:
    port: -1
```

다음 예제에 표시된 것처럼 `management.endpoints.web.exposure.exclude` 프로퍼티를 사용하여 이를 달성할 수도 있다.

`프로퍼티스(Properties)`
```
management.endpoints.web.exposure.exclude=*
```

`Yaml`
```yaml
management:
  endpoints:
    web:
      exposure:
        exclude: "*"
```


## 13.4. JMX를 통한 모니터링 및 관리(Monitoring and Management over JMX)
JMX(Java Management Extensions)는 애플리케이션을 모니터링하고 관리하는 표준 메커니즘을 제공한다. 기본적으로 이 기능은 활성화되어 있지 않다. `spring.jmx.enabled` 프로퍼티를 `true`로 설정하여 이를 켤 수 있다. 스프링 부트는 ID가 `mbeanServer`인 빈으로 가장 적합한 `MBeanServer`를 노출한다. 스프링 JMX 어노테이션(`@ManagedResource`, `@ManagedAttribute` 또는 `@ManagedOperation`)으로 어노테이션이 달린 모든 빈이 여기에 노출된다.

플랫폼이 표준 `MBeanServer`를 제공하는 경우 스프링 부트는 이를 사용하고 필요한 경우 VM `MBeanServer`를 기본값으로 사용한다. 모든 작업이 실패하면 새 `MBeanServer`가 생성된다.

자세한 내용은 JmxAutoConfiguration 클래스를 참고하자.

기본적으로 스프링 부트는 `org.springframework.boot` 도메인 아래에 JMX MBean으로 `management` 엔드포인트도 노출한다. JMX 도메인의 엔드포인트 등록을 완전히 제어하려면 자체 `EndpointObjectNameFactory` 구현체 등록을 고려해보자.


### 13.4.1. MBean 이름 커스텀(Customizing MBean Names)
MBean의 이름은 일반적으로 엔드포인트의 ID에서 생성된다. 예를 들어 상태(health) 엔드포인트는 `org.springframework.boot:type=Endpoint,name=Health`로 노출된다.

애플리케이션에 하나 이상의 스프링 애플리케이션컨텍스트(ApplicationContext)가 포함되어 있으면 이름이 충돌할 수 있다. 이 문제를 해결하려면 `spring.jmx.unique-names` 프로퍼티를 `true`로 설정하여 MBean 이름이 항상 고유하도록 할 수 있다.

엔드포인트가 노출되는 JMX 도메인을 커스텀할 수도 있다. 다음 설정은 `application.properties`에서 이를 수행하는 예제를 보여준다.

`프로퍼티스(Properties)`
```
spring.jmx.unique-names=true
management.endpoints.jmx.domain=com.example.myapp
```

`Yaml`
```yaml
spring: 
  jmx:
    unique-names: true
  management:
    endpoints:
      jmx:
        domain: "com.example.myapp"
```

### 13.4.2. JMX 엔드포인트 비활성화(Disabling JMX Endpoints)
JMX를 통해 엔드포인트를 노출하지 않으려면 다음 예제에 표시된 대로 `management.endpoints.jmx.exposure.exclude` 프로퍼티를 `*`로 설정할 수 있다.

`프로퍼티스(Properties)`
```
management.endpoints.jmx.exposure.exclude=*
```

`Yaml`
```yaml

management:
  endpoints:
    jmx:
      exposure:
        exclude: "*"
```