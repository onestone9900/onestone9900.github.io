---
layout: default
title: 13. 프로덕션 준비 기능(Production-ready Features)
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 13
---

[원문 - Production-ready Features](https://docs.spring.io/spring-boot/docs/3.1.1/reference/html/actuator.html#actuator)

***

13. 프로덕션 준비 기능(Production-ready Features)
    - 13.1. 프로덕션에 준비 기능 활성화(Enabling Production-ready Features)
    - 13.2. 엔드포인트(Endpoints)
      - 13.2.1. 엔드포인트 활성화(Enabling Endpoints)
      - 13.2.2. 엔드포인트 노출(Exposing Endpoints)
      - 13.2.3. 보안(Security)
        - 크로스 사이트 요청 위조 방지(Cross Site Request Forgery Protection)
      - 13.2.4. 엔드포인트 구성(Configuring Endpoints)
      - 13.2.5. 액추에이터 웹 엔드포인트를 위한 하이퍼미디어(Hypermedia for Actuator Web Endpoints)
      - 13.2.6. CORS 지원(CORS Support)
      - 13.2.7. 커스텀 엔드포인트 구현(Implementing Custom Endpoints)
        - 입력 받기(Receiving Input)
        - 커스텀 웹 엔드포인트(Custom Web Endpoints)
        - 서블릿 엔드포인트(Servlet Endpoints)
        - 컨트롤러 엔드포인트(Controller Endpoints)
      - 13.2.8. 상태 정보(Health Information)
        - 헬스인디케이터 자동 구성(Auto-configured HealthIndicators)
        - 커스텀 헬스인디케이터 작성. 리액티브 헬스인디케이터(Writing Custom HealthIndicators. Reactive Health Indicators)
        - 자동 구성된 리액티브헬스인디케이터 상태 그룹(Auto-configured ReactiveHealthIndicators Health Groups)
        - 데이터소스 상태(DataSource Health)
      - 13.2.9. Kubernetes Probes
        - Checking External State With Kubernetes Probes
        - Application Lifecycle and Probe States
      - 13.2.10. Application Information
        - Auto-configured InfoContributors
        - Custom Application Information
        - Git Commit Information
        - Build Information
        - Java Information
        - OS Information
        - Writing Custom InfoContributors
      - 13.3. Monitoring and Management Over HTTP
        - 13.3.1. Customizing the Management Endpoint Paths
        - 13.3.2. Customizing the Management Server Port
        - 13.3.3. Configuring Management-specific SSL
        - 13.3.4. Customizing the Management Server Address
        - 13.3.5. Disabling HTTP Endpoints
      - 13.4. Monitoring and Management over JMX
        - 13.4.1. Customizing MBean Names
        - 13.4.2. Disabling JMX Endpoints
      - 13.5. Observability
      - 13.6. Loggers
        - 13.6.1. Configure a Logger
      - 13.7. Metrics
        - 13.7.1. Getting started
        - 13.7.2. Supported Monitoring Systems
          - AppOptics 
          - Atlas
          - Datadog
          - Dynatrace
          - Elastic
          - Ganglia
          - Graphite
          - Humio
          - Influx
          - JMX
          - KairosDB
          - New Relic
          - OpenTelemetry
          - Prometheus
          - SignalFx
          - Simple
          - Stackdriver
          - StatsD
          - Wavefront
        - 13.7.3. Supported Metrics and Meters
          - JVM Metrics
          - System Metrics
          - Application Startup Metrics
          - Logger Metrics
          - Task Execution and Scheduling Metrics
          - Spring MVC Metrics
          - Spring WebFlux Metrics
          - Jersey Server Metrics
          - HTTP Client Metrics
          - Tomcat Metrics
          - Cache Metrics
          - Spring Batch Metrics
          - Spring GraphQL Metrics
          - DataSource Metrics 
          - Hibernate Metrics
          - Spring Data Repository Metrics
          - RabbitMQ Metrics
          - Spring Integration Metrics 
          - Kafka Metrics
          - MongoDB Metrics
          - Jetty Metrics
          - @Timed Annotation Support
          - Redis Metrics
        - 13.7.4. Registering Custom Metrics
        - 13.7.5. Customizing Individual Metrics
          - Common Tags
          - Per-meter Properties
        - 13.7.6. Metrics Endpoint
        - 13.7.7. Integration with Micrometer Observation
      - 13.8. Tracing
        - 13.8.1. Supported Tracers
        - 13.8.2. Getting Started
        - 13.8.3. Tracer Implementations
          - OpenTelemetry With Zipkin
          - OpenTelemetry With Wavefront
          - OpenTelemetry With OTLP
          - OpenZipkin Brave With Zipkin
          - OpenZipkin Brave With Wavefront
        - 13.8.4. Integration with Micrometer Observation
        - 13.8.5. Creating Custom Spans
      - 13.9. Auditing
        - 13.9.1. Custom Auditing
      - 13.10. Recording HTTP Exchanges
        - 13.10.1. Custom HTTP Exchange Recording 
      - 13.11. Process Monitoring
        - 13.11.1. Extending Configuration
        - 13.11.2. Programmatically Enabling Process Monitoring 
      - 13.12. Cloud Foundry Support
        - 13.12.1. Disabling Extended Cloud Foundry Actuator Support 
        - 13.12.2. Cloud Foundry Self-signed Certificates
        - 13.12.3. Custom Context Path
      - 13.13. What to Read Next
***


# 13. 프로덕션 준비 기능(Production-ready Features)
스프링 부트에는 애플리케이션을 프로덕션 환경으로 푸시할 때 애플리케이션을 모니터링하고 관리하는 데 도움이 되는 다양한 추가 기능이 포함되어 있다. HTTP 엔드포인트나 JMX를 사용하여 애플리케이션을 관리하고 모니터링하도록 선택할 수 있다. 감사(Auditing), 상태(health) 및 지표 수집(metrics gathering)도 애플리케이션에 자동으로 적용될 수 있다.


## 13.1. 프로덕션 준비 기능 활성화(Enabling Production-ready Features)
`spring-boot-actuator` 모듈은 스프링 부트의 프로덕션 준비 기능을 모두 제공한다. 기능을 활성화하는 권장 방법은 `spring-boot-starter-actuator` "스타터" 의존성을 추가하는 것이다.

<B>액츄에이터 정의</B>

```
액츄에이터(Actuator)는 무언가를 움직이거나 제어하기 위한 기계 장치를 가리키는 제조 용어다. 액추에이터는 작은 변화로 많은 양의 모션을 생성할 수 있다.
```

메이븐 기반 프로젝트에 액추에이터를 추가하려면 다음 "스타터" 의존성을 추가하자.

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
</dependencies>
```

그레이들의 경우 다음 선언을 사용한다.

```groovy
dependencies {
      implementation 'org.springframework.boot:spring-boot-starter-actuator'
}
```

## 13.2. 엔드포인트(Endpoints)
액추에이터 엔드포인트를 사용하면 애플리케이션을 모니터링하고 상호 작용할 수 있다. 스프링 부트에는 여러 내장 엔드포인트가 포함되어 있으며 사용자가 직접 엔드포인트를 추가할 수 있다. 예를 들어 상태(health) 엔트포인트는 기본 애플리케이션의 상태 정보를 제공한다.


각 개별 엔드포인트을 활성화하거나 비활성화하고 HTTP 또는 JMX를 통해 노출(원격 접근 가능)할 ​​수 있다. 엔드포인트는 활성화되고 노출되면 사용 가능한 것으로 간주된다. 기본 제공 엔드포인트는 사용 가능한 경우에만 자동 구성된다. 대부분의 애플리케이션은 엔드포인트 ID와 `/actuator` 접두사가 URL에 매핑되는 HTTP를 통한 노출을 선택한다. 예를 들어 기본적으로 상태 엔드포인트는 `/actuator/health`에 매핑된다.

{: .note}
액추에이터의 엔드포인트와 해당 요청 및 응답 형식에 대해 자세히 알아보려면 별도의 API 설명서(HTML 또는 PDF)를 참고하자.

다음과 같은 기술 독립적인 엔드포인트를 사용할 수 있다

|ID|설명|
|---|---|
|`auditevents`|현재 애플리케이션에 대한 감시(audit) 이벤트 정보를 노출한다. `어디트이벤트리포지터리(AuditEventRepository)` 빈이 필요하다.|
|`beans`|애플리케이션에 있는 모든 스프링 빈 전체 목록을 표시한다.|
|`caches`|사용 가능한 캐시를 노출한다.|
|`conditions`|구성 및 자동 구성 클래스에서 평가된(evaluated) 조건과 일치하거나 일치하지 않는 이유를 표시한다.|
|`configprops`|모든 `@ConfigurationProperties`의 대조 목록을 표시한다.|
|`env`|스프링의 컨피규러블인바이런먼트(ConfigurableEnvironment)에서 프로퍼티를 노출한다.|
|`flyway`|적용된 모든 `Flyway` 데이터베이스 마이그레이션을 표시한다. 하나 이상의 Flyway 빈이 필요하다.|
|`health`|애플리케이션 상태 정보를 표시한다.|
|`httpexchanges`|HTTP 교환 정보(기본적으로 마지막 100개의 HTTP 요청-응답 교환)를 표시한다. `HttpExchangeRepository` 빈이 필요하다.|
|`info`|임의의 애플리케이션 정보를 표시합니다.|
|`integrationgraph`|스프링 인테그레이션 그래프를 표시한다. `spring-integration-core`에 대한 의존성이 필요하다.|
|`loggers`|애플리케이션의 로거 구성을 표시하고 수정한다.|
|`liquibase`|적용된 모든 `Liquibase` 데이터베이스 마이그레이션을 표시한다. 하나 이상의 `Liquibase` 빈이 필요하다.|
|`metrics`|현재 애플리케이션에 대한 "메트릭(metrics)" 정보를 표시한다.|
|`mappings`|모든 `@RequestMapping` 경로의 조합된 목록을 표시한다.|
|`quartz`|쿼츠 스케줄러 잡에 대한 정보를 표시한다.|
|`scheduledtasks`|애플리케이션에 예약된 작업을 표시한다.|
|`sessions`|스프링 세션 지원 세션 리포지터리에서 사용자 세션을 검색하고 삭제할 수 있다. 스프링 세션을 사용하는 서블릿 기반 웹 애플리케이션이 필요하다.|
|`shutdown`|애플리케이션을 정상적으로 종료할 수 있다. jar 패키징을 사용할 때만 작동한다. 일반적으로 비활성화되어 있다.|
|`startup`|`어플리케이션스타드업(ApplicationStartup)`에서 수집한 시작 단계 데이터를 표시한다. `버퍼링애플리케이션스타드업(BufferingApplicationStartup)`으로 구성하려면 `스프링애플리케이션(SpringApplication)`이 필요하다.|
|`threaddump`|스레드덤프를 수행한다.|


애플리케이션이 웹 애플리케이션(스프링 MVC, 스프링 웹플러스 또는 Jersey)인 경우 다음과 같은 추가 엔드포인트를 사용할 수 있다.

|ID|설명|
|---|---|
|`heapdump`|힙 덤프 파일을 반환한다. 핫스팟(HotSpot) JVM에서는 HPROF 타입의 파일이 반환된다. OpenJ9 JVM에서는 PHD 타입의 파일이 반환된다.|
|`logfile`|로그 파일의 내용을 반환한다(`logging.file.name` 또는 `login.file.path` 프로퍼티가 설정된 경우). 로그 파일 콘텐츠의 일부를 검색하기 위해 HTTP Range 헤더 사용을 지원한다.|
|`prometheus`|프로메테우스(Prometheus) 서버에서 스크랩할 수 있는 형식으로 측정항목을 노출한다. `micrometer-registry-prometheus`에 대한 의존성이 필요하다.|


### 13.2.1. 엔드포인트 활성화(Enabling Endpoints)
기본적으로 종료(shutdown)를 제외한 모든 엔드포인트는 활성화되어있다. 엔드포인트 활성화하려면 해당 `management.endpoint.<id>.enabled` 프로퍼티를 사용하자. 다음 예제에서는 종료 엔드포인트를 활성화한다.

`프로퍼티스(Properties)`
```
management.endpoint.shutdown.enabled=true
```

`Yaml`

```yaml
management:
  endpoint:
    shutdown:
      enabled: true
```

옵트아웃(opt-out)이 아닌 옵트인(opt-in)으로 엔드포인트 활성화를 선호하는 경우 `management.endpoints.enabled-by-default` 프로퍼티를 `false`로 설정하고 개별 엔드포인트 활성화 프로퍼티를 사용하여 다시 옵트인한다. 다음 예제에서는 `info` 엔드포인트를 활성화하고 다른 모든 엔드포인트를 비활성화한다.

`프로퍼티스(Properties)`
```
management.endpoints.enabled-by-default=false
management.endpoint.info.enabled=true
```

`Yaml`
```yaml
management:
    endpoints:
      enabled-by-default: false
    endpoint:
      info:
        enabled: true
```

{: .note}
비활성화된 엔드포인트는 애플리케이션 컨텍스트에서 완전히 제거된다. 엔드포인트가 노출되는 기술만 변경하려면 `include` 및 `exclude` 프로퍼티스를 사용하자.


### 13.2.2. 엔드포인트 노출(Exposing Endpoints)
기본적으로 상태 엔드포인트만 HTTP 및 JMX를 통해 노출된다. 엔드포인트에는 민감한 정보가 포함될 수 있으므로 이를 노출을 신중하게 고려해야 한다.

노출되는 엔드포인트를 변경하려면 다음 기술별 `include` 및 `exclude` 프로퍼티스를 사용하자.

|프로퍼티|기본값|
|---|---|
|`management.endpoints.jmx.exposure.exclude`||
|`management.endpoints.jmx.exposure.include`|`health`|
|`management.endpoints.web.exposure.exclude`||
|`management.endpoints.web.exposure.include`|`health`|

`include` 프로퍼티는 노출된 엔드포인트의 ID를 나열한다. `exclude` 프로퍼티는 노출되어서는 안 되는 엔드포인트의 ID를 나열한다. `exclude` 프로퍼티는 `include` 프로퍼티보다 우선된다. 엔드포인트 ID 목록을 사용하여 `include` 프로퍼티 및 `exclude` 프로퍼티을 모두 구성할 수 있다.

예를 들어, JMX를 통해서만 상태(health) 및 정보(info) 엔드포인트를 노출하려면 다음 프로퍼티를 사용한다.

`프로퍼티스(Properties)`
```
management.endpoints.jmx.exposure.include=health,info
```

`Yaml`
```yaml
management:
  endpoints:
    jmx:
      exposure:
        include: "health,info"
```

`*`를 사용하여 모든 엔드포인트를 선택할 수 있다. 예를 들어, `env` 및 `beans` 엔드포인트를 제외한 모든 것을 HTTP를 통해 노출하려면 다음 프로퍼티를 사용하자.

`프로퍼티스(Properties)`
```
management.endpoints.web.exposure.include=*
management.endpoints.web.exposure.exclude=env,beans
```

`Yaml`
```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
        exclude: "env,beans"
```

{: .note}
`*`는 YAML에서 특별한 의미를 가지므로 모든 엔드포인트를 포함(또는 제외)하려면 따옴표를 추가해야 한다.

{: .note}
애플리케이션이 공개적으로 노출되는 경우, 엔드포인트도 보호하는 것이 좋다.

{: .note}
엔드포인트가 노출에 대한 자체 전략을 구현하려면 `EndpointFilter` 빈을 등록할 수 있다.


### 13.2.3. 보안(Security)
보안을 위해 기본적으로 HTTP를 통해 `/health` 엔드포인트만 노출된다. `management.endpoints.web.exposure.include` 프로퍼티를 사용하여 노출되는 엔드포인트를 구성할 수 있다.

{: .note}
`management.endpoints.web.exposure.include`를 설정하기 전에 노출된 액추에이터에 민감한 정보가 포함되어 있지 않은지, 방화벽 뒤에 배치하여 보호되는지 또는 스프링 시큐리티와 같은 것으로 보호되는지 확인하자.

스프링 시큐리티가 클래스패스에 있고 다른 `SecurityFilterChain` 빈이 없는 경우 `/health`를 제외한 모든 액추에이터는 스프링 부트 자동 구성으로 보호된다. 커스텀 `SecurityFilterChain` 빈을 정의하면 스프링 부트 자동 구성이 중단되고 액추에이터 접근 규칙을 완전히 제어할 수 있다.

HTTP 엔드포인트에 대한 커스텀 보안을 구성하려는 경우(예: 특정 역할을 가진 사용자만 접근할 수 있도록 허용) 스프링 부트는 스프링 시큐리티와 함께 사용할 수 있는 몇 가지 편리한 `RequestMatcher` 객체를 제공한다.

일반적인 스프링 시큐리티 구성은 다음 예제와 유사할 수 있다.

`자바`
```java
import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;
import static org.springframework.security.config.Customizer.withDefaults;

@Configuration(proxyBeanMethods = false)
public class MySecurityConfiguration {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.securityMatcher(EndpointRequest.toAnyEndpoint());
        http.authorizeHttpRequests((requests) -> requests.anyRequest().hasRole("ENDPOINT_ADMIN"));
        http.httpBasic(withDefaults());
        return http.build();
    }
}
```

`코틀린`
```kotlin
import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.Customizer.withDefaults
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.web.SecurityFilterChain

@Configuration(proxyBeanMethods = false)
class MySecurityConfiguration {
    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http.securityMatcher(EndpointRequest.toAnyEndpoint()).authorizeHttpRequests { requests ->
            requests.anyRequest().hasRole("ENDPOINT_ADMIN")
        }
        http.httpBasic(withDefaults())
        return http.build()
    }
}
```

이전 예제에서는 `EndpointRequest.toAnyEndpoint()`를 사용하여 요청을 모든 엔드포인트에 일치시킨 다음 모든 엔드포인트에 `ENDPOINT_ADMIN` 역할이 있는지 확인한다. `EndpointRequest`에서는 다른 여러 매처(matcher) 메서드도 사용할 수 있다. 자세한 내용은 API 설명서([HTML](https://docs.spring.io/spring-boot/docs/3.1.1/actuator-api/htmlsingle/) 또는 PDF)를 참고하자.

방화벽 뒤에 애플리케이션을 배포하는 경우 인증 없이 모든 액추에이터 엔드포인트에 접근할 수 있는 것을 선호할 수 있다. 다음과 같이 `management.endpoints.web.exposure.include` 프로퍼티를 변경하면 된다.

`프로퍼티스(Properties)`
```
management.endpoints.web.exposure.include=*
```

`Yaml`
```yaml
management:
  endpoints:
    web:
      exposure:
        include: "*"
```

또한, 스프링 시큐리티가 있는 경우 다음 예제와 같이 엔드포인트에 대한 인증되지 않은 접근를 허용하는 커스텀 보안 구성을 추가해야 한다.

`자바`
```java
import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

@Configuration(proxyBeanMethods = false)
public class MySecurityConfiguration {
  @Bean
  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http.securityMatcher(EndpointRequest.toAnyEndpoint());
    http.authorizeHttpRequests((requests) -> requests.anyRequest().permitAll());
    return http.build();
  } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.actuate.autoconfigure.security.servlet.EndpointRequest
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.web.SecurityFilterChain

@Configuration(proxyBeanMethods = false)
class MySecurityConfiguration {
  @Bean
  fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
    http.securityMatcher(EndpointRequest.toAnyEndpoint()).authorizeHttpRequests { requests ->
      requests.anyRequest().permitAll()
    }
    return http.build()
  }
}
```

{: .note}
위의 두 예제에서 구성은 액추에이터 엔드포인트에만 적용된다. 스프링 부트의 보안 구성은 `SecurityFilterChain` 빈이 있는 경우 완전히 백오프되므로 애플리케이션의 나머지 부분에 적용되는 규칙을 사용하여 추가 `SecurityFilterChain` 빈을 구성해야 한다.


#### 크로스 사이트 요청 위조 방지(Cross Site Request Forgery Protection)
스프링 부트는 스프링 시큐리티의 기본값을 사용하므로 CSRF 보호는 기본적으로 켜져 있다. 이는 기본 보안 구성이 사용 중일 때 POST(종료 및 로거 엔드포인트), PUT 또는 DELETE가 필요한 액추에이터 엔드포인트에 403(금지됨) 오류가 발생함을 의미한다.

{: .note}
브라우저가 아닌 클라이언트에서 사용되는 서비스를 생성하는 경우에만 CSRF 보호를 완전히 비활성화하는 것이 좋다.

[스프링 시큐리티 레퍼런스 가이드](https://docs.spring.io/spring-security/reference/features/exploits/csrf.html)에서 CSRF 보호에 대한 추가 정보를 찾을 수 있다.


### 13.2.4. 엔드포인트 구성(Configuring Endpoints)
엔드포인트가 응답을 캐시하는 시간을 구성하려면 해당 `cache.time-to-live` 프로퍼티를 사용하자. 다음 예제에서는 빈 엔드포인트 캐시의 TTL(Time-To-Live)을 10초로 설정합니다.

`프로퍼티스(Properties)`
```
management.endpoint.beans.cache.time-to-live=10s
```

`Yaml`
```yaml
management:
  endpoint:
    beans:
      cache:
        time-to-live: "10s"
```

{: .note}
`management.endpoint.<name>` 접두사는 구성 중인 엔드포인트를 고유하게 식별한다.


### 13.2.5. 액추에이터 웹 엔드포인트를 위한 하이퍼미디어(Hypermedia for Actuator Web Endpoints)
모든 엔드포인트에 대한 링크가 포함된 "discovery page"가 ​​추가된다. "discovery page"는 기본적으로 `/actuator`에서 사용할 수 있다.

"discovery page"를 비활성화하려면 애플리케이션 프로퍼티스에서 다음 프로퍼티를 추가해보자.

`프로퍼티스(Properties)`
```
management.endpoints.web.discovery.enabled=false
```

`Yaml`
```yaml
management:
  endpoints:
    web:
      discovery:
        enabled: false
```

커스텀 관리 컨텍스트 패스가 구성되면 "discovery page"가 ​​자동으로 `/actuator`에서 관리 컨텍스트의 루트로 이동한다. 예를 들어 관리 컨텍스트 패스가 `/management`인 경우 `/management`에서 "discovery page"를 사용할 수 있다. 관리 컨텍스트 패스가 `/`로 설정되면 다른 매핑과의 충돌 가능성을 방지하기 위해 discovery page가 비활성화된다.


### 13.2.6. CORS 지원(CORS Support)
[CORS(Cross-Origin Resource Sharing)](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing)는 도메인 간 요청에 대한 승인을 유연하게 지정할 수 있는 [W3C 사양](https://fetch.spec.whatwg.org/)이다. 스프링 MVC 또는 스프링 웹플럭스를 사용하는 경우 이런 상황을 지원하도록 액츄에이터의 웹 엔드포인트를 구성할 수 있다.

CORS 지원은 기본적으로 비활성화되어 있으며 `management.endpoints.web.cors.allowed-origins` 프로퍼티를 설정한 후에만 활성화된다. 다음 구성은 `example.com` 도메인에서 GET 및 POST 호출을 허용한다.

`프로퍼티스(Properties)`
```
management.endpoints.web.cors.allowed-origins=https://example.com
management.endpoints.web.cors.allowed-methods=GET,POST
```

`Yaml`
```yaml
management:
  endpoints:
    web: 
      cors:
        allowed-origins: "https://example.com"
        allowed-methods: "GET,POST"
```

{: .note}
전체 옵션 목록은 [`CorsEndpointProperties`](https://github.com/spring-projects/spring-boot/blob/v3.1.1/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/endpoint/web/CorsEndpointProperties.java)를 참고하자.


### 13.2.7. 커스텀 엔드포인트 구현(Implementing Custom Endpoints)
`@Endpoint` 어노테이션이 달린 `@Bean`을 추가하면 `@ReadOperation`, `@WriteOperation` 또는 `@DeleteOperation`으로 어노테이션이 달린 모든 메서드는 자동으로 JMX를 통해 노출되고 웹 애플리케이션에서는 HTTP를 통해서도 노출된다. Jersey, 스프링 MVC 또는 스프링 웹플럭스를 사용하여 HTTP를 통해 엔드포인트를 노출할 수 있다. Jersey와 스프링 MVC를 모두 사용할 수 있는 경우 스프링 MVC가 사용된다.


다음 예제에서는 커스텀 객체를 반환하는 리드 오퍼레이션(read operation)을 노출한다.

`자바`
```java
@ReadOperation
public CustomData getData() {
    return new CustomData("test", 5);
}
```

`코틀린`
```kotlin
@ReadOperation
fun getData(): CustomData {
    return CustomData("test", 5)
}
```

`@JmxEndpoint` 또는 `@WebEndpoint`를 사용하여 기술별 엔드포인트를 작성할 수도 있다. 이러한 엔드포인트는 해당 기술로 제한된다. 예를 들어 `@WebEndpoint`는 JMX가 아닌 HTTP를 통해서만 노출된다.

`@EndpointWebExtension` 및 `@EndpointJmxExtension`을 사용하여 기술별 확장을 작성할 수 있다. 이러한 어노테이션을 사용하면 기존 엔드포인트를 보강하는 기술별 작업을 제공할 수 있다.

마지막으로, 웹 프레임워크 특정 기능에 접근해야 하는 경우 `JMX`를 통해 또는 다른 웹 프레임워크를 사용할 때 사용할 수 없는 서블릿이나 스프링 `@Controller` 및 `@RestController` 엔드포인트를 구현할 수 있다.


#### 입력 받기(Receiving Input)
엔드포인트의 작업은 해당 파라미터를 통해 입력을 받는다. 웹을 통해 노출되면 이러한 파라미터의 값은 URL의 쿼리 파라미터와 JSON 요청 본문에서 가져온다. JMX를 통해 노출되면 파라미터는 MBean 작업의 파라미터에 매핑된다. 파라미터는 기본적으로 필수다. `@javax.annotation.Nullable` 또는 `@org.springframework.lang.Nullable`로 어노테이션을 달아 선택사항으로 만들 수 있다.

JSON 요청 본문(body)의 각 루트 프로퍼티를 엔드포인트의 파라미터에 매핑할 수 있다. 다음 JSON 요청 본문을 보자.

```
{
    "name": "test",
    "counter": 42
}
```

다음 예제와 같이 이를 사용하여 문자열명 및 int 카운터 파라미터를 사용하는 라이트 오퍼레이션(write operation)을 호출할 수 있다.

`자바`
```java
@WriteOperation
public void updateData(String name, int counter) {
    // "test"와 42 주입
}
```

`코틀린`
```kotlin
@WriteOperation
fun updateData(name: String?, counter: Int) {
    // "test"와 42 주입
}
```

{: .note}
엔드포인트는 기술에 구애받지 않으므로 메서드 시그니처에는 단순 타입만 지정할 수 있다. 특히 `CustomData` 타입으로 단일 파라미터를 선언하는 경우 이름 및 카운터 프로퍼티스를 정의하는 것은 지원되지 않는다.

{: .note}
입력이 작업 메서드의 파라미터에 매핑되도록 하려면 엔드포인트를 구현하는 자바 코드는 `-parameters`로 컴파일해야 하고, 엔드포인트를 구현하는 코틀린 코드는 `-java-parameters`로 컴파일해야 한다. 이는 스프링 부트의 그레이들 플러그인을 사용하거나 메이븐 및 `spring-boot-starter-parent`를 사용하는 경우 자동으로 발생한다.


##### 입력 유형 변환
엔드포인트 작업 메서드에 전달된 파라미터는 필요한 경우 필요한 타입으로 자동 변환된다. 작업 메서드를 호출하기 전에 JMX 또는 HTTP를 통해 수신된 입력은 `@EndpointConverter`로 정규화된 모든 컨버터(Converter) 또는 제네릭컨버터(GenericConverter) 빈뿐만 아니라 `ApplicationConversionService` 인스턴스를 사용하여 필요한 타입으로 변환된다.


#### 커스텀 웹 엔드포인트
`@Endpoint`, `@WebEndpoint` 또는 `@EndpointWebExtension`에 대한 작업은 Jersey, 스프링 MVC 또는 스프링 웹플럭스를 사용하여 HTTP를 통해 자동으로 노출된다. Jersey와 스프링 MVC를 모두 사용할 수 있는 경우 스피링 MVC가 사용된다.


##### 웹 엔드포인트 요청 조건자
웹에 노출된 엔드포인트의 각 작업에 대해 요청 조건자(predicate)가 자동으로 생성된다.


##### 경로
조건자의 경로는 엔드포인트의 ID와 웹에 노출된 엔드포인트의 기본 경로에 의해 결정된다. 기본 기본 경로는 `/actuator`다. 예를 들어 세션 ID가 있는 엔드포인트는 `/actuator/sessions`를 조건자의 경로로 사용한다.

`@Selector`를 사용하여 작업 메서드의 하나 이상의 파라미터에 어노테이션을 추가하여 경로를 추가로 커스텀할 수 있다. 이러한 파라미터는 경로 변수로 경로 조건자에 추가된다. 엔드포인트 작업이 호출되면 변수 값이 작업 메서드에 전달된다. 나머지 모든 경로 요소를 캡처하려면 마지막 파라미터에 `@Selector(Match=ALL_REMAINING)`를 추가하고 이를 `String[]`과 변환 ​​가능한 타입으로 만들 수 있다.


##### HTTP 메소드
조건자의 HTTP 메서드는 다음 표에 표시된 대로 작업 유형에 따라 결정된다.

|작업|HTTP 메소드|
|---|---|
|`@ReadOperation`|GET|
|`@WriteOperation`|POST|
|`@DeleteOperation`|DELETE|


###### 소비
요청의 본문을 사용하는 `@WriteOperation(HTTP POST)`의 경우, 조건자의 소비 절은 `application/vnd.spring-boot.actuator.v2+json`, `application/json`다. 다른 모든 작업의 ​​경우 `consumes` 절은 비어 있다.


###### 생산
조건자의 생산 절은 `@DeleteOperation`, `@ReadOperation` 및 `@WriteOperation` 어노테이션의 생산 애트리뷰트에 의해 결정될 수 있다. 애트리뷰트는 선택사항이다. 사용되지 않으면 생산 절이 자동으로 결정된다.

작업 메서드가 void 또는 Void를 반환하는 경우 생성 절은 비어 있다. 작업 메서드가 `org.springframework.core.io.Resource`를 반환하는 경우 생성 절은 `application/octet-stream`이다. 다른 모든 작업의 ​​경우 생산 절은 `application/vnd.spring-boot.actuator.v2+json`, `application/json`이다.


###### 웹 엔드포인트 응답 상태
엔드포인트 작업의 기본 응답 상태는 작업 타입(읽기, 쓰기 또는 삭제)과 작업이 반환하는 항목(있는 경우)에 따라 달라진다.

`@ReadOperation`이 값을 반환하는 경우 응답 상태는 200(정상)이 된다. 값을 반환하지 않는 경우 응답 상태는 404(찾을 수 없음)이다.

`@WriteOperation` 또는 `@DeleteOperation`이 값을 반환하는 경우 응답 상태는 200(정상)이 된다. 값을 반환하지 않는 경우 응답 상태는 204(콘텐츠 없음)이다.

필수 파라미터 없이 또는 필수 타입으로 변환할 수 없는 파라미터를 사용하여 작업을 호출하면 작업 메서드가 호출되지 않고 응답 상태가 400(Bad Request)이 된다.


###### 웹 엔드포인트 범위 요청
HTTP 범위 요청을 사용하여 HTTP 리소스의 일부를 요청할 수 있다. 스프링 MVC 또는 스프링 웹플럭스를 사용할 때 `org.springframework.core.io.Resource`를 반환하는 작업은 자동으로 범위 요청을 지원한다.

{: .note}
Jersey를 사용하는 경우 범위 요청이 지원되지 않는다.


###### 웹 엔드포인트 보안
웹 엔드포인트 또는 웹 특정 엔드포인트 확장에 대한 작업은 현재 `java.security.Principal` 또는 `org.springframework.boot.actuate.endpoint.SecurityContext`를 메서드 파라미터로 받을 수 있다. 전자는 일반적으로 `@Nullable`과 함께 사용되어 인증된 사용자와 인증되지 않은 사용자에게 서로 다른 동작을 제공한다. 후자는 일반적으로 `isUserInRole(String)` 메소드를 사용하여 권한 부여 확인을 수행하는 데 사용된다.


#### 서블릿 엔드포인트(Servlet Endpoints)
`@ServletEndpoint` 어노테이션이 달린 클래스를 구현하고 `@ServletEndpoint`도 구현하는 클래스를 구현하여 서블릿을 엔드포인트로 노출할 수 있다. 서블릿 엔드포인트는 서블릿 컨테이너와의 더 깊은 통합을 제공하지만 이식성은 좋지않다. 이는 기존 서블릿을 엔드포인트로 노출하는 데 사용된다. 새 엔드포인트의 경우 `@Endpoint` 및 `@WebEndpoint` 어노테이션을 선호한다.


#### 컨트롤러 엔드포인트(Controller Endpoints)
`@ControllerEndpoint` 및 `@RestControllerEndpoint`를 사용하여 스프링 MVC 또는 스프링 웹플럭스에 의해서만 노출되는 엔드포인트를 구현할 수 있다. 메서드는 `@RequestMapping` 및 `@GetMapping`과 같은 스프링 MVC 및 스프링 웹플럭스용 표준 어노테이션을 사용하여 매핑되며 엔드포인트의 ID는 경로의 접두사로 사용된다. 컨트롤러 엔드포인트는 스프링의 웹 프레임워크와의 더 깊은 통합을 제공하지만 이식성은 좋지않다. 가능하면 `@Endpoint` 및 `@WebEndpoint` 어노테이션을 선호해야 한다.


### 13.2.8. 상태 정보(Health Information)
상태 정보를 사용하여 실행 중인 애플리케이션의 상태를 확인할 수 있다. 이는 프로덕션 시스템이 다운될 때 누군가에게 경고하기 위해 모니터링 소프트웨어에서 자주 사용된다. 상태 엔드포인트에 의해 노출되는 정보는 다음 값 중 하나로 구성될 수 있는 `management.endpoint.health.show-details` 및 `management.endpoint.health.show-comComponents` 프로퍼티스에 따라 달라진다.


|명칭|설명|
|---|---|
|`never`|세부정보 표시되지 않음.|
|`when-authorized`|세부정보는 승인된 사용자에게만 표시된다. 승인된 역할은 `management.endpoint.health.roles`를 사용하여 구성할 수 있다.|
|`always`|세부정보는 모든 사용자에게 표시된다.|

기본값은 never다. 사용자가 하나 이상의 엔드포인트 역할에 속해 있으면 권한이 부여된 것으로 간주된다. 엔드포인트에 구성된 역할(기본값)이 없으면 인증된 모든 사용자는 권한이 부여된 것으로 간주한다. `management.endpoint.health.roles` 프로퍼티를 사용하여 역할을 구성할 수 있다.

{: .note}
애플리케이션을 보호하고 항상 사용하려면 보안 구성에서 인증된 사용자와 인증되지 않은 사용자 모두에 대해 상태 엔드포인트에 대한 접근를 허용해야 한다.

상태 정보는 `HealthContributorRegistry`(기본적으로 `ApplicationContext`에 정의된 모든 `HealthContributor` 인스턴스)의 콘텐츠에서 수집된다. 스프링 부트에는 자동으로 구성된 여러 `HealthContributors`가 포함되어 있으며 직접 작성할 수도 있다.

`HealthContributor`는 `HealthIndicator` 또는 `CompositeHealthContributor`일 수 있다. `HealthIndicator`는 상태를 포함한 실제 상태 정보를 제공한다. `CompositeHealthContributor`는 다른 `HealthContributors`을 제공한다. 컨트리뷰터는 종합적으로 트리 구조를 형성하여 전체 시스템 상태를 나타낸다.

기본적으로, 최종 시스템 상태는 순서가 지정된 상태 목록을 기반으로 각 `HealthIndicator`의 상태를 정렬하는 `StatusAggregator`에 의해 파생된다. 정렬된 목록의 첫 번째 상태는 전체 상태로 사용된다. `HealthIndicator`가 `StatusAggregator`에 알려진 상태를 반환하지 않으면 `UNKNOWN` 상태가 사용된다.

{: .note}
`HealthContributorRegistry`를 사용하여 런타임 시 `Health indicators`를 등록 및 등록 취소할 수 있다.


#### 헬스인디케이터 자동 구성(Auto-configured HealthIndicators)
적절한 경우, 스프링부트는 다음 표에 나열된 `HealthIndicator`를 자동 구성한다. 다음 표에 나열된 키를 사용하여 `management.health.key.enabled`를 구성하여 선택한 indicators를 활성화하거나 비활성화할 수도 있다.

|키|명칭|설명|
|---|---|---|
|`cassandra`|`CassandraDriverHealthIndicator`|카산드라 데이터베이스가 작동 중인지 확인한다.|
|`couchbase`|`CouchbaseHealthIndicator`|카우치베이스 클러스터가 작동 중인지 확인한다.|
|`db`|`DataSourceHealthIndicator`|데이터소스에 대한 연결을 얻을 수 있는지 확인한다.|
|`diskspace`|`DiskSpaceHealthIndicator`|디스크 공간이 부족한지 확인한다.|
|`elasticsearch`|`ElasticsearchRestHealthIndicator`|엘라스틱서치 클러스터가 작동 중인지 확인한다.|
|`hazelcast`|`HazelcastHealthIndicator`|Hazelcast 서버가 작동 중인지 확인한다.|
|`influxdb`|`InfluxDbHealthIndicator`|InfluxDB 서버가 작동 중인지 확인한다.|
|`jms`|`JmsHealthIndicator`|JMS 브로커가 작동 중인지 확인한다.|
|`ldap`|`LdapHealthIndicator`|LDAP 서버가 작동 중인지 확인한다.|
|`mail`|`MailHealthIndicator`|메일 서버가 작동 중인지 확인한다.|
|`mongo`|`MongoHealthIndicator`|몽고 데이터베이스가 작동 중인지 확인한다.|
|`neo4j`|`Neo4jHealthIndicator`|Neo4j 데이터베이스가 작동 중인지 확인한다.|
|`ping`|`PingHealthIndicator`|항상 UP으로 응답한다.|
|`rabbit`|`RabbitHealthIndicator`|Rabbit 서버가 작동 중인지 확인한다.|
|`redis`|`RedisHealthIndicator`|레디스 서버가 작동 중인지 확인한다.|

{: .note}
`management.health.defaults.enabled` 프로퍼티를 설정하여 이를 모두 비활성화할 수 있다.

추가 `HealthIndicators`를 사용할 수 있지만 기본적으로 활성화되어 있지 않다.


|키|명칭|설명|
|---|---|---|
|`livenessstate`|`LivenessStateHealthIndicator`|"Liveness" 애플리케이션 가용성 상태를 노출한다.|
|`readinessstate`|`ReadinessStateHealthIndicator`|"Readiness" 애플리케이션 가용성 상태를 노출한다.|


#### 커스텀 헬스인디케이터 작성. 리액티브 헬스인디케이터(Writing Custom HealthIndicators. Reactive Health Indicators)
커스텀 상태 정보를 제공하기 위해 `HealthIndicator` 인터페이스를 구현하는 스프링 빈을 등록할 수 있다. `health()` 메서드 구현을 제공하고 `Health` 응답을 반환해야 한다. 상태 응답에는 상태가 포함되어야 하며 선택적으로 표시할 추가 세부 정보를 포함할 수 있다. 다음 코드는 샘플 `HealthIndicator` 구현을 보여준다.

`자바`
```java
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class MyHealthIndicator implements HealthIndicator {
  @Override
  public Health health() {
      int errorCode = check();
      if (errorCode != 0) {
          return Health.down().withDetail("Error Code", errorCode).build();
      }
      return Health.up().build();
  }
  private int check() {
      // 특정 상태 점검을 수행한다.
      return ...
  } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.actuate.health.Health
import org.springframework.boot.actuate.health.HealthIndicator
import org.springframework.stereotype.Component

@Component
class MyHealthIndicator : HealthIndicator {
  override fun health(): Health {
      val errorCode = check()
      if (errorCode != 0) {
          return Health.down().withDetail("Error Code", errorCode).build()
      }
      return Health.up().build()
  }
  private fun check(): Int {
      // 특정 상태 점검을 수행한다.
      return  ...
  } 
}
```

{: .note}
주어진 `HealthIndicator`의 식별자는 `HealthIndicator` 접미사가 없는 빈의 이름이다(존재하는 경우). 앞의 예에서 상태 정보는 my라는 항목에서 사용할 수 있다.

{: .note}
상태 표시기(Health indicator)는 일반적으로 HTTP를 통해 호출되며 연결 시간이 초과되기 전에 응답해야 한다. 스프링 부트는 응답하는 데 10초 이상 걸리는 상태 표시기에 대한 경고 메시지를 기록한다. 이 임계값을 구성하려면 `management.endpoint.health.logging.slow-indicator-threshold` 프로퍼티를 사용할 수 있다.

스프링 부트의 사전 정의된 상태 타입 외에도 `Health`는 새로운 시스템 상태를 나타내는 커스텀 상태를 반환할 수 있다. 이러한 경우 `StatusAggregator` 인터페이스의 커스텀 구현도 제공해야 한다. 또는 `management.endpoint.health.status.order` 구성 프로퍼티를 사용하여 기본 구현을 구성해야 한다.

예를 들어, `HealthIndicator` 구현 중 하나에서 `FATAL` 코드가 포함된 새 상태가 사용되고 있다고 가정하자. 심각도 순서를 구성하려면 애플리케이션 프로퍼티에 다음 프로퍼티스를 추가하자.


`프로퍼티스(Properties)`
```
management.endpoint.health.status.order=fatal,down,out-of-service,unknown,up
```

`Yaml`
```yaml
management:
  endpoint:
    health:
      status:
        order: "fatal,down,out-of-service,unknown,up"
```

응답의 HTTP 상태 코드는 전반적인 상태를 나타낸다. 기본적으로 `OUT_OF_SERVICE` 및 `DOWN`은 `503`에 매핑된다. `UP`을 포함하여 매핑되지 않은 모든 상태는 `200`에 매핑된다. HTTP를 통해 상태 엔드포인트에 접근하는 경우 커스텀 상태 매핑을 등록할 수도 있다. 커스텀 매핑을 구성하면 `DOWN` 및 `OUT_OF_SERVICE에` 대한 기본 매핑이 비활성화된다. 기본 매핑을 유지하려면 사용자 지정 매핑과 함께 이를 명시적으로 구성해야 한다. 예를 들어, 다음 프로퍼티는 `FATAL`을 503(서비스 사용 불가)에 매핑하고 `DOWN` 및 `OUT_OF_SERVICE`에 대한 기본 매핑을 유지한다.

`프로퍼티스(Properties)`
```
management.endpoint.health.status.http-mapping.down=503
management.endpoint.health.status.http-mapping.fatal=503
management.endpoint.health.status.http-mapping.out-of-service=503
```

`Yaml`
```yaml
management:
  endpoint:
    health:
      status:
        http-mapping:
          down: 503
          fatal: 503
          out-of-service: 503
```

{: .note}
더 많은 제어가 필요한 경우, 자체 `HttpCodeStatusMapper` 빈을 정의할 수 있다.

다음 표는 기본 제공 상태에 대한 기본 상태 매핑을 보여준다.

|상태|매핑|
|---|---|
|`DOWN`|`SERVICE_UNAVAILABLE` (`503`)|
|`OUT_OF_SERVICE`|`SERVICE_UNAVAILABLE` (`503`)|
|`UP`|No mapping by default, so HTTP status is `200`|
|`UNKNOWN`|No mapping by default, so HTTP status is `200`|


#### 자동 구성된 리액티브헬스인디케이터 상태 그룹(Auto-configured ReactiveHealthIndicators Health Groups)
적절한 경우 스프링 부트는 다음 리액티브헬스인디케이터(ReactiveHealthIndicator)를 자동 구성한다.

|키|명칭|설명|
|---|---|---|
|`cassandra`|`CassandraDriverReactiveHealthIndicator`|카산드라 데이터베이스가 작동 중인지 확인한다.|
|`couchbase`|`CouchbaseReactiveHealthIndicator`|카우치베이스 클러스터가 작동 중인지 확인한다.|
|`elasticsearch`|`ElasticsearchReactiveHealthIndicator`|엘라스틱서치 클러스터가 작동 중인지 확인한다.|
|`mongo`|`MongoReactiveHealthIndicator`|몽고 데이터베이스가 작동 중인지 확인한다.|
|`neo4j`|`Neo4jReactiveHealthIndicator`|Neo4j 데이터베이스가 작동 중인지 확인한다.|
|`redis`|`RedisReactiveHealthIndicator`|레디스 서버가 작동 중인지 확인한다.|

{: .note}
필요한 경우 리액티브 표시기(indicator)가 일반 표시기를 대체한다. 또한 명시적으로 처리되지 않은 헬스인디케이터(HealthIndicator)는 자동으로 래핑된다.

##### 상태 그룹(Health Groups)
상태 표시기를 다양한 목적으로 사용할 수 있는 그룹으로 구성하는 것이 유용한 경우가 있다.

상태 표시기 그룹을 추가하려면 `management.endpoint.health.group.<name>` 특성을 사용하고, 포함하거나 제외할 상태 표시기 ID 목록을 지정할 수 있다. 예를 들어, 데이터베이스 상태 표시기만 포함하는 그룹을 생성하려면 다음을 정의할 수 있다.

`프로퍼티스(Properties)`
```
management.endpoint.health.group.custom.include=db
```

`Yaml`
```yaml
management:
  endpoint:
    health:
      group:
        custom:
          include: "db"
```

그런 다음 localhost:8080/actuator/health/custom을 눌러 결과를 확인할 수 있다.

마찬가지로, 그룹에서 데이터베이스 상태 표시기를 제외하고, 다른 모든 표시기를 포함하는 그룹을 생성하려면 다음을 정의할 수 있다.

`프로퍼티스(Properties)`
```
management.endpoint.health.group.custom.exclude=db
```

`Yaml`
```yaml
management:
  endpoint:
    health:
      group:
        custom:
          exclude: "db"
```

기본적으로 상태 그룹에 존재하지 않는 상태 표시기가 포함되거나 제외되면 시작이 실패한다. 이 동작을 비활성화하려면 `management.endpoint.health.validate-group-membership`을 `false`로 설정하자.

기본적으로, 그룹은 시스템 상태와 동일한 `StatusAggregator` 및 `HttpCodeStatusMapper` 설정을 상속한다. 그러나 그룹별로 이를 정의할 수도 있다. 필요한 경우 `show-details` 및 `roles` 프로퍼티스을 오버라이드할 수도 있다.

`프로퍼티스(Properties)`
```
management.endpoint.health.group.custom.show-details=when-authorized
management.endpoint.health.group.custom.roles=admin
management.endpoint.health.group.custom.status.order=fatal,up
management.endpoint.health.group.custom.status.http-mapping.fatal=500
management.endpoint.health.group.custom.status.http-mapping.out-of-service=500
```

`Yaml`
```yaml
management:
  endpoint:
    health:
      group:
        custom:
          show-details: "when-authorized"
          roles: "admin"
          status:
            order: "fatal,up"
            http-mapping:
              fatal: 500
              out-of-service: 500
```

{: .note}
그룹과 함께 사용할 커스텀 `StatusAggregator` 또는 `HttpCodeStatusMapper` 빈을 등록해야 하는 경우 `@Qualifier("groupname")`를 사용할 수 있다.

상태 그룹은 `CompositeHealthContributor`를 포함/제외할 수도 있다. `CompositeHealthContributor`의 특정 컴포넌트만 포함/제외할 수도 있다. 이는 다음과 같이 컴포넌트의 정규화된 이름을 사용하여 수행할 수 있다.

```
management.endpoint.health.group.custom.include="test/primary"
management.endpoint.health.group.custom.exclude="test/primary/b"
```


위의 예제에서 커스텀 그룹에는 복합 테스트의 컴포넌트인 `primary`라는 이름의 `HealthContributor`가 포함된다. 여기서 기본 자체는 복합이며 이름이 primary인 `HealthContributor`는 커스텀 그룹에서 제외된다.

상태 그룹은 기본 포트나 관리 포트의 추가 경로에서 사용할 수 있다. 이는 보안 목적으로 액추에이터 엔드포인트에 별도의 관리 포트를 사용하는 것이 일반적으로 쿠버네티스와 같은 클라우드 환경에서 유용하다. 별도의 포트를 사용하면 상태 확인에 성공하더라도 기본 애플리케이션이 제대로 작동하지 않을 수 있으므로 상태 확인을 신뢰할 수 없게 될 수 있다. 상태 그룹은 다음과 같은 추가 경로로 구성할 수 있다.

```
management.endpoint.health.group.live.additional-path="server:/healthz"
```

이렇게 하면 `/healthz`의 기본 서버 포트에서 라이브 상태 그룹을 사용할 수 있다. 접두사는 필수이며 `server:`(기본 서버 포트를 나타냄) 또는 `management:`(구성된 경우 관리 포트를 나타냄)이어야 한다. 경로는 단일 경로 세그먼트여야 한다.

