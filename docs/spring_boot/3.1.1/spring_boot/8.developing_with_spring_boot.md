---
layout: default
title: 8. 웹(Web)
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 8
---

***
8. 웹
    - 8.1. 서블릿 웹 애플리케이션(Servlet Web Applications)
        - 8.1.1. 스프링 웹 MVC 프레임워크(The “Spring Web MVC Framework”)
            Spring MVC 자동 구성(Spring MVC Auto-configuration)
            Http메세지컨버터(HttpMessageConverters)
            메세지코드리졸버(MessageCodesResolver)
            스태틱 컨텐트(Static Content)
            웰컴 페이지(Welcome Page)
            커스텀 파비콘(Custom Favicon)
            패스 매칭 앤 컨텐트 네고시에이션(Path Matching and Content Negotiation)
            컨피규러블웹바인딩이니셜라이저(ConfigurableWebBindingInitializer)
            템플릿 엔진(Template Engines)
            에러 핸들링(Error Handling)
            CORS 지원(CORS Support)
        - 8.1.2. JAX-RS and Jersey
        - 8.1.3. Embedded Servlet Container Support
            Servlets, Filters, and Listeners
            Servlet Context Initialization
            The ServletWebServerApplicationContext
            Customizing Embedded Servlet Containers
            JSP Limitations
    - 8.2. Reactive Web Applications
        - 8.2.1. The “Spring WebFlux Framework”
            Spring WebFlux Auto-configuration
            HTTP Codecs with HttpMessageReaders and HttpMessageWriters
            Static Content
            Welcome Page
            Template Engines
            Error Handling 
            Web Filters
        - 8.2.2. Embedded Reactive Server Support
        - 8.2.3. Reactive Server Resources Configuration
    - 8.3. Graceful Shutdown
    - 8.4. Spring Security
        - 8.4.1. MVC Security
        - 8.4.2. WebFlux Security
        - 8.4.3. OAuth2
            Client
            Resource Server
            Authorization Server
        - 8.4.4. SAML 2.0
            Relying Party
    - 8.5. Spring Session
    - 8.6. Spring for GraphQL
        - 8.6.1. GraphQL Schema
        - 8.6.2. GraphQL RuntimeWiring
        - 8.6.3. Querydsl and QueryByExample Repositories Support
        - 8.6.4. Transports
            HTTP and WebSocket
            RSocket
        - 8.6.5. Exception Handling
        - 8.6.6. GraphiQL and Schema printer
    - 8.7. Spring HATEOAS
    - 8.8. What to Read Next
***


# 8. 웹(Web)
스프링 부트는 웹 애플리케이션 개발에 매우 ​​적합하다. 임베디드 톰캣, 제티(Jetty), 언더토우(Undertow) 또는 네티(Netty)를 사용하여 독립형 HTTP 서버를 생성할 수 있다. 대부분의 웹 애플리케이션은 `spring-boot-starter-web` 모듈을 사용하여 빠르게 시작하고 실행한다. `spring-boot-starter-webflux` 모듈을 사용하여 리액티브 웹 애플리케이션을 구축하도록 선택할 수도 있다.

아직 스프링 부트 웹 애플리케이션을 개발하지 않았다면 [시작하기(Getting Started)](https://onestone9900.github.io/docs/spring_boot/3.1.1/spring_boot/4.getting_started/#4-getting-started) 장의 예제인 "Hello World!"를 따라할 수 있다.


## 8.1. 서블릿 웹 애플리케이션(Servlet Web Applications)
서블릿 기반 웹 애플리케이션을 구축하려는 경우 스프링MVC 또는 저지(Jersey)에 대한 스프링 부트 자동 구성(auto-configuration)을 활용할 수 있다.


### 8.1.1. 스프링 웹 MVC 프레임워크(The “Spring Web MVC Framework”)
스프링 웹 MVC 프레임워크(종종 “스프링 MVC”라고도 함)는 풍부한 “모델 뷰 컨트롤러” 웹 프레임워크이다. 스프링 MVC를 사용하면 들어오는 HTTP 요청(request)을 처리하기 위해 특별한 `@Controller` 또는 `@RestController` 빈을 생성할 수 있다. 컨트롤러의 메서드는 `@RequestMapping` 어노테이션을 사용하여 HTTP에 매핑된다.

다음 코드는 제이슨(JSON) 데이터를 제공하는 일반적인 `@RestController`를 보여준다.

`자바`
```java
import java.util.List;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/users")
public class MyRestController {
    private final UserRepository userRepository;
    private final CustomerRepository customerRepository;
    public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) {
        this.userRepository = userRepository;
        this.customerRepository = customerRepository;
    }

    @GetMapping("/{userId}")
    public User getUser(@PathVariable Long userId) {
        return this.userRepository.findById(userId).get();
    }

    @GetMapping("/{userId}/customers")
    public List<Customer> getUserCustomers(@PathVariable Long userId) {
        return this.userRepository.findById(userId).map(this.customerRepository::findByUser).get();
    }

    @DeleteMapping("/{userId}")
    public void deleteUser(@PathVariable Long userId) {
        this.userRepository.deleteById(userId);
    }
}
```

`코틀린`
```kotlin
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/users")
class MyRestController(private val userRepository: UserRepository, private val customerRepository: CustomerRepository) {
    @GetMapping("/{userId}")
    fun getUser(@PathVariable userId: Long): User {
        return userRepository.findById(userId).get()
    }

    @GetMapping("/{userId}/customers")
    fun getUserCustomers(@PathVariable userId: Long): List<Customer> {
        return userRepository.findById(userId).map(customerRepository::findByUser).get()
    }

    @DeleteMapping("/{userId}")
    fun deleteUser(@PathVariable userId: Long) {
        userRepository.deleteById(userId)
    }
}
```

기능적 변형인 "WebMvc.fn"은 다음 예제와 같이 라우팅 구성을 요청의 실제 처리와 분리한다.

`자바`
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.web.servlet.function.RequestPredicate;
import org.springframework.web.servlet.function.RouterFunction;
import org.springframework.web.servlet.function.ServerResponse;
import static org.springframework.web.servlet.function.RequestPredicates.accept;
import static org.springframework.web.servlet.function.RouterFunctions.route;

@Configuration(proxyBeanMethods = false)
public class MyRoutingConfiguration {
    private static final RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);

    @Bean
    public RouterFunction<ServerResponse> routerFunction(MyUserHandler userHandler) {
        return route()
                .GET("/{user}", ACCEPT_JSON, userHandler::getUser)
                .GET("/{user}/customers", ACCEPT_JSON, userHandler::getUserCustomers)
                .DELETE("/{user}", ACCEPT_JSON, userHandler::deleteUser)
                .build();
    } 
}
```

`코틀린`
```kotlin
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.MediaType
import org.springframework.web.servlet.function.RequestPredicates.accept
import org.springframework.web.servlet.function.RouterFunction
import org.springframework.web.servlet.function.RouterFunctions
import org.springframework.web.servlet.function.ServerResponse

@Configuration(proxyBeanMethods = false)
class MyRoutingConfiguration {
    @Bean
    fun routerFunction(userHandler: MyUserHandler): RouterFunction<ServerResponse> {
        return RouterFunctions.route()
            .GET("/{user}", ACCEPT_JSON, userHandler::getUser)
            .GET("/{user}/customers", ACCEPT_JSON, userHandler::getUserCustomers)
            .DELETE("/{user}", ACCEPT_JSON, userHandler::deleteUser)
            .build()
    }

    companion object {
        private val ACCEPT_JSON = accept(MediaType.APPLICATION_JSON)
    } 
}
```

`자바`
```java
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.function.ServerRequest;
import org.springframework.web.servlet.function.ServerResponse;

@Component
public class MyUserHandler {
    public ServerResponse getUser(ServerRequest request) {
        ...
        return ServerResponse.ok().build();
    }

    public ServerResponse getUserCustomers(ServerRequest request) {
        ...
        return ServerResponse.ok().build();
    }

    public ServerResponse deleteUser(ServerRequest request) {
        ...
        return ServerResponse.ok().build();
    }
}
```

`코틀린`
```kotlin
import org.springframework.stereotype.Component
import org.springframework.web.servlet.function.ServerRequest
import org.springframework.web.servlet.function.ServerResponse

@Component
class MyUserHandler {
    fun getUser(request: ServerRequest?): ServerResponse {
        return ServerResponse.ok().build()
    }

    fun getUserCustomers(request: ServerRequest?): ServerResponse {
        return ServerResponse.ok().build()
    }

    fun deleteUser(request: ServerRequest?): ServerResponse {
        return ServerResponse.ok().build()
    } 
}
```

스프링 MVC는 코어 스프링 프레임워크의 일부이며 자세한 정보는 [레퍼런스 문서](https://docs.spring.io/spring-framework/docs/6.0.10/reference/html/web.html#mvc)에서 확인할 수 있다. [`spring.io/guides`](https://spring.io/guides)에는 스프링 MVC를 다루는 여러 가이드도 있다.

{: .note }
라우터 정의를 모듈화하기 위해 원하는 만큼 `라우터펑션(RouterFunction)` 빈을 정의할 수 있다. 우선순위를 적용해야 하는 경우 빈의 순위를 정할 수 있다.


#### 스프링 MVC 자동 구성(Spring MVC Auto-configuration)
스프링 부트는 대부분의 애플리케이션에서 잘 작동하는 스프링 MVC에 대한 자동 구성(auto-configuration)을 제공한다.

자동 구성은 스프링의 기본값 위에 다음 기능을 추가한다.
- `콘텐트네고시에이팅뷰리졸버(ContentNegotiatingViewResolver)` 및 `빈네임뷰리졸버(BeanNameViewResolver)` 빈이 포함된다.
- `WebJars` 지원을 포함하여, 스태틱(Static) 리소스 제공을 지원한다(문서의 뒷부분에서 설명).
- `컨버터(Converter)`, `제네릭컨버터(GenericConverter)` 및 `포매터(Formatter)` 빈의 자동 등록.
- `Http메세지컨버터(HttpMessageConverters)` 지원(문서의 뒷부분에서 설명)
- `메세지코드리졸버(MessageCodesResolver)` 자동 등록(문서의 뒷부분에서 설명)
- 스태틱(Static) index.html 지원.
- `컨피규러블웹바인딩이셜라이저(ConfigurableWebBindingInitializer)` 빈의 자동 사용(이 문서의 뒷부분에서 설명)

이러한 스프링 부트 MVC 커스텀(customization)을 유지하고 더 많은 MVC 커스텀(인터셉터(interceptor), 포맷터(formatter), 뷰 컨트롤러(view controller) 및 기타 기능)를 수행하려는 경우 `@EnableWebMvc` 없이 웹Mvc컨피규어러(WebMvcConfigurer) 타입의 고유한 `@Configuration `클래스를 추가할 수 있다.

`리퀘스트매핑핸들러매핑(RequestMappingHandlerMapping)`, `리퀘스트매핑핸들러어댑터(RequestMappingHandlerAdapter)` 또는 `익셉션핸들러익셉션리졸버(ExceptionHandlerExceptionResolver)`의 커스텀 인스턴스를 제공하고 여전히 스프링 부트 MVC 커스텀를 유지하려는 경우 웹Mvc레지스트레이션(WebMvcRegistrations) 타입의 빈을 선언하고 이를 사용하여 해당 컴포넌트의 커스텀 인스턴스를 제공할 수 있다.

스프링 MVC를 완전히 제어하려면, `@EnableWebMvc` 어노테이션이 달린 고유한 `@Configuration`을 추가하거나 `@EnableWebMvc`의 자바독(Javadoc)에 설명된 대로 고유한 `@Configuration` 어노테이션이 달린 `델리게이팅웹Mvc컨피규레이션(DelegatingWebMvcConfiguration)`을 추가할 수 있다.

***
`노트`

스프링 MVC는 `application.properties` 또는 `application.yaml` 파일의 값을 변환하는 데 사용되는 것과 다른 `컨버전서비스(ConversionService)`를 사용한다. 이는 피리어드(Period), 듀레이션(Duration) 및 데이터사이즈(DataSize) 컨버터를 사용할 수 없으며 `@DurationUnit` 및 `@DataSizeUnit` 어노테이션이 무시된다는 의미다.

스프링 MVC에서 사용되는 컨버전서비스(ConversionService)를 커스텀하려면 `addFormatters` 메소드와 함께 `웹Mvc컨피규어러(WebMvcConfigurer)` 빈을 제공할 수 있다. 이 메서드에서 원하는 컨버터를 등록하거나 `애플리케이션컨버전서비스(ApplicationConversionService)`에서 사용 가능한 스태틱 메서드에 위임할 수 있다.
***


#### Http메시지컨버터(HttpMessageConverters)
스프링 MVC는 Http메세지컨버터(HttpMessageConverter) 인터페이스를 사용하여 HTTP 요청(request)과 응답(responses)을 변환(convert)한다. 기본적으로 합리적인 기본값이 포함되어 있다. 예를 들어 객체는 자동으로 JSON(잭슨(Jackson) 라이브러리 사용) 또는 XML(사용 가능한 경우 잭슨(Jackson) XML 확장 사용 또는 잭슨(Jackson) XML 확장을 사용할 수 없는 경우 JAXB 사용)로 변환할 수 있다. 기본적으로 문자열은 UTF-8로 인코딩된다.

컨버터를 추가하거나 커스텀해야 하는 경우 다음 목록에 표시된 것처럼 스프링 부트의 Http메세지컨버터(HttpMessageConverters) 클래스를 사용할 수 있다.

`자바`
```java
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;

@Configuration(proxyBeanMethods = false)
public class MyHttpMessageConvertersConfiguration {
    @Bean
    public HttpMessageConverters customConverters() {
        HttpMessageConverter<?> additional = new AdditionalHttpMessageConverter();
        HttpMessageConverter<?> another = new AnotherHttpMessageConverter();
        return new HttpMessageConverters(additional, another);
    } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.autoconfigure.http.HttpMessageConverters
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.converter.HttpMessageConverter

@Configuration(proxyBeanMethods = false)
class MyHttpMessageConvertersConfiguration {
    @Bean
    fun customConverters(): HttpMessageConverters {
        val additional: HttpMessageConverter<*> = AdditionalHttpMessageConverter()
        val another: HttpMessageConverter<*> = AnotherHttpMessageConverter()
        return HttpMessageConverters(additional, another)
    } 
}
```

컨텍스트에 존재하는 모든 Http메세지컨버터(HttpMessageConverter) 빈은 컨버터 목록에 추가된다. 동일한 방식으로 기본 컨버터를 오버라이드할 수도 있다.


#### 메세지코드리졸버(MessageCodesResolver)
스프링 MVC에는 바인딩 오류로부터 오류 메시지를 렌더링하기 위한 오류 코드(메세지코드리졸버(MessageCodesResolver))를 생성하는 전략이 있다. `spring.mvc.message-codes-resolver-format` 프로퍼티 `PREFIX_ERROR_CODE` 또는 `POSTFIX_ERROR_CODE`를 설정하면 스프링 부트가 자동으로 하나를 생성한다(`DefaultMessageCodesResolver.Format`의 이넘 참조).

Spring MVC has a strategy for generating error codes for rendering error messages from binding errors: MessageCodesResolver. If you set the spring.mvc.message-codes-resolver-format property PREFIX_ERROR_CODE or POSTFIX_ERROR_CODE, Spring Boot creates one for you (see the enumeration in DefaultMessageCodesResolver.Format).


#### 스태틱 컨텐트(Static Content)
기본적으로 스프링 부트는 클래스패스의 `/static`(또는 `/public`, `/resources` 또는 `/META-INF/resources`)이라는 디렉터리나 `서블릿컨텍스트(ServletContext)` 루트에서 스태틱 콘텐츠를 제공한다. 이는 스프링 MVC의 `리소스Http리퀘스트핸들러(ResourceHttpRequestHandler)`를 사용하므로 사용자는 자체 `웹Mvc컨피규어러(WebMvcConfigurer)`를 추가하고 `addResourceHandlers` 메서드를 오버라이드하여 해당 동작을 수정할 수 있다.

독립형(stand-alone) 웹 애플리케이션에서는 컨테이너의 기본 서블릿이 활성화되지 않는다. `server.servlet.register-default-servlet` 프로퍼티를 사용하여 활성화할 수 있다.

기본 서블릿은 스프링이 처리하지 않기로 결정한 경우 서블릿컨텍스트(ServletContext)의 루트에서 콘텐츠를 제공하는 폴백(fallback) 역할을 한다. 기본 MVC 구성을 수정하지 않는 한 대부분은 발생하지 않는다. 왜냐하면 스프링은 항상 `디스패처서블릿(DispatcherServlet)`을 통해 요청(request)을 처리할 수 있기 때문이다.

기본적으로 리소스는 `/**`에 매핑되지만 `spring.mvc.static-path-pattern` 프로퍼티을 사용하여 이를 조정할 수 있다. 예를 들어 모든 리소스를 `/resources/**`에 재배치하는 방법은 다음과 같다.

`프로퍼티스`
```Properties
spring.mvc.static-path-pattern=/resources/**
```

`Yaml`
```yaml
spring: 
  mvc:
    static-path-pattern: "/resources/**"
```

`spring.web.resources.static-location` 프로퍼티스를 사용하여 스태틱 리소스 위치를 커스텀할 수도 있다(기본값을 디렉터리 위치 리스트로 대체). 루트 서블릿 컨텍스트 패스인 "/"도 해당위치로 추가된다.

앞서 언급한 "표준" 스태틱 리소스 위치 외에도 [`Webjars` 컨텐트]에 대한 특별한 경우가 있다. 기본적으로 `/webjars/**`에 패스가 있는 모든 리소스는 `Webjars` 포맷으로 패키지된 경우 jar 파일에서 제공된다. 패스는 `spring.mvc.webjars-path-pattern` 프로퍼티를 사용하여 커스텀할 수 있다.

{: .note}
애플리케이션이 jar로 패키지된 경우 `src/main/webapp` 디렉토리를 사용하지 말자. 이 디렉토리는 일반적인 표준이지만 `war` 패키징에서만 작동하며 jar을 생성하는 경우 대부분의 빌드 도구에서 자동으로 무시된다.

스프링 부트는 또한 스프링 MVC에서 제공하는 고급 리소스 처리 기능을 지원하여 캐시 버스팅 스태틱 리소스(cache-busting static resources) 또는 `Webjar` 버전에 구애받지 않는 URL 사용과 같은 사례를 허용한다.

`Webjars`에 대해 버전에 구애받지 않는 URL을 사용하려면 `webjars-locator-core` 의존성을 추가하자. 그런 다음 `Webjar`을 선언하자. 예를 들어 `jQuery`를 사용하면 "/webjars/jquery/jquery.min.js"를 추가했을 때 "/webjars/jquery/x.y.z/jquery.min.js"가 된다. 여기서 x.y.z는 Webjar 버전이다.

{: .note }
제이보스(JBoss)를 사용하는 경우 `webjars-locator-core` 대신 `webjars-locator-jboss-vfs` 의존성성을 선언해야 한다. 그렇지 않으면 모든 Webjar가 404로 처리된다.

캐시 무효화를 사용하기 위해 다음 구성은 모든 스태틱 리소스에 대한 캐시 무효화 솔루션을 구성하여 <link href="/css/spring- 2a2d595e6ed9a0b24f027f2b63b134d6.css"/>와 같은 콘텐츠 해시를 URL에 효과적으로 추가한다.

`프로퍼티스(Properties)`
```
spring.web.resources.chain.strategy.content.enabled=true
spring.web.resources.chain.strategy.content.paths=/**
```

`Yaml`
```yaml
spring: 
  web:
    resources:
      chain:
        strategy:
          content:
            enabled: true
            paths: "/**"
```

{: .note }
Thymeleaf 및 FreeMarker에 대해 자동으로 구성된 `리소스Url인코딩필터(ResourceUrlEncodingFilter)` 덕분에 리소스에 대한 링크는 런타임 시 템플릿에 재작성된다. JSP를 사용할 때 이 필터를 수동으로 선언해야 한다. 다른 템플릿 엔진은 현재 자동으로 지원되지 않지만 커스텀 템플릿 macros/helpers 및 `리소스Url프로바이더(ResourceUrlProvider)`를 사용할 수 있다.

예를 들어 자바스크립트 모듈 로더를 사용하여 리소스를 동적으로 로드할 때 파일명을 바꾸는 것은 옵션이 아니다. 그렇기 때문에 다른 전략도 지원되고 결합될 수 있다. "고정(fixed)" 전략은 다음 예와 같이 파일명을 변경하지 않고 URL에 스태틱 버전 문자열을 추가한다.

`프로퍼티스(Properties)`
```
spring.web.resources.chain.strategy.content.enabled=true
spring.web.resources.chain.strategy.content.paths=/**
spring.web.resources.chain.strategy.fixed.enabled=true
spring.web.resources.chain.strategy.fixed.paths=/js/lib/
spring.web.resources.chain.strategy.fixed.version=v12
```

`Yaml`
```yaml
spring: 
  web:
    resources:
      chain:
        strategy:
          content:
            enabled: true
            paths: "/**"
          fixed:
            enabled: true
            paths: "/js/lib/"
            version: "v12"
```

이 구성을 사용하면 "/js/lib/" 아래에 있는 자바스크립트 모듈은 고정 버전 관리 전략("/v12/js/lib/mymodule.js")을 사용하는 반면, 다른 리소스는 여전히 컨텐트 전략(<link href="/ css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>)을 사용한다.

지원되는 추가 옵션은 `WebProperties.Resources`를 참고하자.

{: .note }
이 기능은 [블로그 게시물](https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources)과 [스프링 프레임워크의 레퍼런스 문서](https://docs.spring.io/spring-framework/docs/6.0.10/reference/html/web.html#mvc-config-static-resources)에 자세히 설명되어 있다.


#### 웰컴 페이지(Welcome Page)
스프링 부트는 스태틱 및 템플릿 웰컴 페이지를 모두 지원한다. 먼저 구성된 스태틱 콘텐츠 위치에서 index.html 파일을 찾는다. 찾을 수 없으면 인덱스 템플릿을 찾는다. 둘 중 하나가 발견되면 자동으로 애플리케이션의 웰컴 페이지로 사용된다.


#### 커스텀 파비콘(Custom Favicon)
다른 정적 리소스와 마찬가지로, 스프링 부트는 구성된 스태틱 콘텐츠 위치에서 favicon.ico를 확인한다. 해당 파일이 있으면 자동으로 애플리케이션의 파비콘으로 사용된다.


#### 패스 매칭 앤 컨텐트 협상(Path Matching and Content Negotiation)
스프링 MVC는 요청(request) 패스를 보고 이를 애플리케이션에 정의된 매핑(예: 컨트롤러 메서드의 @GetMapping 어노테이션)과 일치시켜 들어오는 HTTP 요청(request)을 핸들러에 매핑할 수 있다.

스프링 부트는 기본적으로 접미사 패턴 일치를 비활성화하도록 한다. 이는 "GET /projects/spring-boot.json"과 같은 요청이 @GetMapping("/projects/spring-boot") 매핑과 일치하지 않음을 의미한다. 이는 스프링 MVC 애플리케이션의 [모범 사례](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-requestmapping.html#mvc-ann-requestmapping-suffix-pattern-match)로 여겨진다. 이 기능은 과거에 적절한 "Accept" 요청 헤더를 보내지 않은 HTTP 클라이언트에 주로 유용했다. 우리는 올바른 콘텐츠 타입을 클라이언트에 보내야 했다. 요즘에는 컨텐트 협상이 훨씬 더 안정적이다.

적절한 "Accept" 요청 헤더를 일관되게 보내지 않는 HTTP 클라이언트를 처리하는 다른 방법이 있다. 접미사 일치를 사용하는 대신 쿼리 파라미터를 사용하여 "GET /projects/spring-boot?format=json"과 같은 요청이 @GetMapping("/projects/spring-boot")에 매핑되도록 할 수 있다.

`프로퍼티스(Properties)`
```
spring.mvc.contentnegotiation.favor-parameter=true
```

`Yaml`
```yaml
spring: 
  mvc:
    contentnegotiation:
      favor-parameter: true
```


또는 다른 파라미터명을 사용하려는 경우.

`프로퍼티스(Properties)`
```
spring.mvc.contentnegotiation.favor-parameter=true
spring.mvc.contentnegotiation.parameter-name=myparam
```

`Yaml`
```yaml
spring: 
  mvc:
    contentnegotiation:
      favor-parameter: true
      parameter-name: "myparam"
```

대부분의 표준 미디어 타입(media types)은 기본적으로 지원되지만, 새로운 타입을 정의할 수도 있다.

`프로퍼티스(Properties)`
```
spring.mvc.contentnegotiation.media-types.markdown=text/markdown
```

`Yaml`
```yaml
spring: 
  mvc:
    contentnegotiation:
      media-types:
        markdown: "text/markdown"
```

스프링 프레임워크 5.3부터 스프링 MVC는 요청 패스를 컨트롤러 핸들러와 일치시키기 위한 여러 구현 전략을 지원한다. 이전에는 `앤트패스매처(AntPathMatcher)` 전략만 지원했지만 이제는 `패스패턴파서(PathPatternParser)`도 제공한다. 이제 스프링 부트는 새로운 전략을 선택하고 선택할 수 있는 구성 프로퍼티를 제공한다.

`프로퍼티스(Properties)`
```
spring.mvc.pathmatch.matching-strategy=path-pattern-parser
```

`Yaml`
```yaml
spring: 
  mvc:
    pathmatch:
      matching-strategy: "path-pattern-parser"
```

이 새로운 구현을 고려해야 하는 이유에 대한 자세한 내용은 [전용 블로그 게시물](https://spring.io/blog/2020/06/30/url-matching-with-pathpattern-in-spring-mvc)을 참고하자.

{: .note }
`패스패턴파서(PathPatternParser)`는 최적화된 구현이지만 일부 패스 패턴 변형(path patterns variants)의 사용을 제한한다. 서블릿 접두사(spring.mvc.servlet.path)를 사용하여 `디스패처서블릿(DispatcherServlet)`을 매핑하거나 접미사 패턴을 매핑하는 것과 호환되지 않는다.

기본적으로, 스프링 MVC는 요청에 대한 핸들러를 찾을 수 없으면 `404 Not Found` 오류 응답을 보낸다. 대신 `노핸들러파운드익셉션(NoHandlerFoundException)`을 발생시키려면 `configprop:spring.mvc.throw-Exception-if-no-handler-found`를 true로 설정하자. 기본적으로 스태틱 콘텐츠 제공은 `/**`에 매핑되므로 모든 요청에 ​​대한 핸들러를 제공한다. `노핸들러파운드익셉션(NoHandlerFoundException)`이 발생하려면 `spring.mvc.static-path-pattern`을 `/resources/**`와 같은 보다 구체적인 값으로 설정하거나 `spring.web.resources.add-mappings`를 false로 설정하여 스태틱 서비스 제공을 비활성화해야 한다.


#### 컨피규러블웹바인딩이니셜라이저(ConfigurableWebBindingInitializer)
스프링 MVC는 `웹바인딩이니셜라이저(WebBindingInitializer)`를 사용하여 특정 요청에 대한 `웹데이터바인더(WebDataBinder)`를 초기화한다. 자신만의 `컨피규러블웹바인딩이니셜라이저(ConfigurableWebBindingInitializer)` @Bean을 생성하면 스프링 부트는 이를 사용하도록 스프링 MVC를 자동으로 구성한다.


#### 템플릿 엔진(Template Engines)
REST 웹 서비스뿐만 아니라, 스프링 MVC를 사용하여 동적(dynamic) HTML 콘텐츠를 제공할 수도 있다. 스프링 MVC는 Thymeleaf, FreeMarker 및 JSP를 포함한 다양한 템플릿 기술을 지원한다. 또한 다른 많은 템플릿 엔진에는 자체 스프링 MVC 통합이 포함되어 있다.

스프링 부트에는 다음 템플릿 엔진에 대한 자동 구성 지원이 포함되어 있다.
- [FreeMarker](https://freemarker.apache.org/docs/)
- [Groovy](https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine)
- [Thymeleaf](https://www.thymeleaf.org/)
- [Mustache](https://mustache.github.io/)

{: .note }
가능하다면 JSP는 피해야 한다. 임베디드 서블릿 컨테이너와 함께 사용할 때 몇 가지 알려진 제한 사항이 있다.

기본 구성으로 이러한 템플릿 엔진 중 하나를 사용하면 템플릿이 `src/main/resources/templates`에서 자동 선택된다.

{: .note }
애플리케이션을 실행하는 방법에 따라 IDE에서 클래스패스 순서를 다르게 지정할 수 있다. IDE의 메인 메서드에서 애플리케이션을 실행하면 메이븐이나 그레이들을 사용하거나 패키지된 jar에서 애플리케이션을 실행할 때와 순서가 달라진다. 이로 인해 스프링 부트가 예상 템플릿을 찾지 못할 수 있다. 이 문제가 발생하면 IDE에서 클래스패스의 순서를 변경하여 모듈의 클래스와 리소스를 먼저 배치할 수 있다.


#### 에러 핸들링(Error Handling)
기본적으로, 스프링 부트는 모든 오류를 합리적인 방식으로 처리하는 `/error` 매핑을 제공하며 이는 서블릿 컨테이너에 "전역(“global”)" 오류 페이지로 등록된다. 머신 클라이언트의 경우 오류 세부정보, HTTP 상태 및 예외 메시지가 포함된 JSON 응답을 생성한다. 브라우저 클라이언트의 경우 동일한 데이터를 HTML 형식으로 렌더링하는 "화이트라벨(whitelabel)" 오류 뷰가 있다(커스텀하려면 `에러`를 해결하는 `뷰`를 추가하자).

기본 오류 처리 동작을 커스텀하려는 경우 설정할 수 있는 다양한 `server.error` 프로퍼티가 있다. 부록의 "서버 프로퍼티스(Server Properties)" 절을 참고하자.

{: .note}
기본 동작을 완전히 대체하려면 `에러컨트롤러(ErrorController)`를 구현하고 해당 타입의 빈을 등록하거나 에러애트리뷰트(ErrorAttributes) 타입의 빈을 추가하여 기존 메커니즘을 사용하되 내용을 대체할 수 있다.

스프링 프레임워크 6.0부터 [RFC 7807 상세 문제](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-ann-rest-exceptions.html)가 지원된다. 스프링 MVC는 다음과 같이 `application/problem+json` 미디어 타입을 사용하여 커스텀 오류 메시지를 생성할 수 있다.

```
{
    "type": "https://example.org/problems/unknown-project",
    "title": "Unknown project",
    "status": 404,
    "detail": "No project found for id 'spring-unknown'",
    "instance": "/projects/spring-unknown"
}
```

이 지원은 `spring.mvc.problemdetails.enabled`를 `true`로 설정하여 활성화할 수 있다.


다음 예제와 같이 `@ControllerAdvice` 어노테이션이 달린 클래스를 정의하여 특정 컨트롤러 및/또는 예외 타입을 반환하도록 JSON 문서를 커스텀할 수도 있다.

`자바`
```java
import jakarta.servlet.RequestDispatcher;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

@ControllerAdvice(basePackageClasses = SomeController.class)
public class MyControllerAdvice extends ResponseEntityExceptionHandler {
    @ResponseBody
    @ExceptionHandler(MyException.class)
    public ResponseEntity<?> handleControllerException(HttpServletRequest request, Throwable ex) {
        HttpStatus status = getStatus(request);
        return new ResponseEntity<>(new MyErrorBody(status.value(), ex.getMessage()), status); 
    }

    private HttpStatus getStatus(HttpServletRequest request) {
        Integer code = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);
        HttpStatus status = HttpStatus.resolve(code);
        return (status != null) ? status : HttpStatus.INTERNAL_SERVER_ERROR;
    } 
}
```

`코틀린`
```kotlin
import jakarta.servlet.RequestDispatcher
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.ResponseBody
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler

@ControllerAdvice(basePackageClasses = [SomeController::class])
class MyControllerAdvice : ResponseEntityExceptionHandler() {
    @ResponseBody
    @ExceptionHandler(MyException::class)
    fun handleControllerException(request: HttpServletRequest, ex: Throwable): ResponseEntity<*> {
        val status = getStatus(request)
        return ResponseEntity(MyErrorBody(status.value(), ex.message), status)
    }

    private fun getStatus(request: HttpServletRequest): HttpStatus {
        val code = request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE) as Int
        val status = HttpStatus.resolve(code)
        return status ?: HttpStatus.INTERNAL_SERVER_ERROR
    } 
}
```

이전 예제에서, `SomeController`와 동일한 패키지에 정의된 컨트롤러에 의해 `MyException`이 발생하는 경우 `에러애트리뷰트(ErrorAttributes)` 표현 대신 `MyErrorBody` POJO의 JSON 표현이 사용된다.

컨트롤러 레벨에서 처리된 오류가 메트릭 인프라에 기록되지 않는 경우도 있다. 애플리케이션은 처리된 예외를 요청 애트리뷰트로 설정하여 이러한 예외가 요청 메트릭과 함께 기록되도록 할 수 있다.

```java
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.boot.web.servlet.error.ErrorAttributes;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Controller
public class MyController {
    @ExceptionHandler(CustomException.class)
    String handleCustomException(HttpServletRequest request, CustomException ex) {
        request.setAttribute(ErrorAttributes.ERROR_ATTRIBUTE, ex);
        return "errorView";
    }
}
```

```kotlin
import jakarta.servlet.http.HttpServletRequest
import org.springframework.boot.web.servlet.error.ErrorAttributes
import org.springframework.stereotype.Controller
import org.springframework.web.bind.annotation.ExceptionHandler

@Controller
class MyController {
    @ExceptionHandler(CustomException::class)
    fun handleCustomException(request: HttpServletRequest, ex: CustomException?): String {
        request.setAttribute(ErrorAttributes.ERROR_ATTRIBUTE, ex)
        return "errorView"
    }
}
```

##### 커스텀 에러 페이지(Custom Error Pages)
특정 상태 코드에 대한 커스텀 HTML 오류 페이지를 표시하려면 /error 디렉터리에 파일을 추가하면 된다. 오류 페이지는 스태틱 HTML(즉, 스태틱 리소스 디렉터리에 추가됨)이거나 템플릿을 사용하여 작성될 수 있다. 파일명은 정확한 상태 코드이거나 시리즈 마스크(series mask)여야 한다.

예를 들어, 404를 스태틱 HTML 파일에 매핑하려면 디렉터리 구조는 다음과 같다.
```
src/
  +- main/
       +- java/
       |   + <source code>
       +- resources/
           +- public/
               +- error/
               |   +- 404.html
               +- <other public assets>
```

`프리매이커(FreeMarker)` 템플릿을 사용하여 모든 5xx 오류를 매핑하려면 디렉터리 구조는 다음과 같다.

```
src/
  +- main/
       +- java/
       |   + <source code>
       +- resources/
           +- templates/
               +- error/
               |   +- 5xx.ftlh
               +- <other templates>
```

보다 복잡한 매핑의 경우 다음 예제와 같이 `에러뷰리졸버(ErrorViewResolver)` 인터페이스를 구현하는 빈을 추가할 수도 있다.

`자바`
```java
import java.util.Map;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.boot.autoconfigure.web.servlet.error.ErrorViewResolver;
import org.springframework.http.HttpStatus;
import org.springframework.web.servlet.ModelAndView;

public class MyErrorViewResolver implements ErrorViewResolver {
    @Override
    public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map<String, Object> model) {
        // 요청 또는 상태를 사용하여 선택적으로 ModelAndView를 반환한다.
        if (status == HttpStatus.INSUFFICIENT_STORAGE) {
            // 여기에 커스텀 모델 값을 추가할 수 있다.
            new ModelAndView("myview");
        }
        return null;
    }
}
```

`코틀린`
```kotlin
import jakarta.servlet.http.HttpServletRequest
import org.springframework.boot.autoconfigure.web.servlet.error.ErrorViewResolver
import org.springframework.http.HttpStatus
import org.springframework.web.servlet.ModelAndView

class MyErrorViewResolver : ErrorViewResolver {
    override fun resolveErrorView(request: HttpServletRequest, status: HttpStatus, model: Map<String, Any>): ModelAndView? {
        // 요청 또는 상태를 사용하여 선택적으로 ModelAndView를 반환한다.
        if (status == HttpStatus.INSUFFICIENT_STORAGE) {
            // 여기에 커스텀 모델 값을 추가할 수 있다.
            return ModelAndView("myview")
        }

        return null 
    }
}
```

`@ExceptionHandler` 메서드 및 `@ControllerAdvice`와 같은 일반 스프링 MVC 기능을 사용할 수도 있다. 그런 다음 `에러컨트롤러(ErrorController)`는 처리되지 않은 예외를 선택한다.


##### 스프링 MVC 외부의 오류 페이지 매핑(Mapping Error Pages Outside of Spring MVC)
스프링 MVC를 사용하지 않는 애플리케이션의 경우 `에러페이지레지스트라(ErrorPageRegistrar)` 인터페이스를 사용하여 에러페이지(ErrorPages)를 직접 등록할 수 있다. 이 추상화는 기본 임베디드 서블릿 컨테이너와 직접 작동하며 스프링 MVC 디스패처서블릿(DispatcherServlet)이 없어도 작동한다.

`자바`
```java
import org.springframework.boot.web.server.ErrorPage;
import org.springframework.boot.web.server.ErrorPageRegistrar;
import org.springframework.boot.web.server.ErrorPageRegistry;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpStatus;

@Configuration(proxyBeanMethods = false)
public class MyErrorPagesConfiguration {
    @Bean
    public ErrorPageRegistrar errorPageRegistrar() {
        return this::registerErrorPages;
    }

    private void registerErrorPages(ErrorPageRegistry registry) {
        registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400"));
    } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.web.server.ErrorPage
import org.springframework.boot.web.server.ErrorPageRegistrar
import org.springframework.boot.web.server.ErrorPageRegistry
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.HttpStatus

@Configuration(proxyBeanMethods = false)
class MyErrorPagesConfiguration {
    @Bean
    fun errorPageRegistrar(): ErrorPageRegistrar {
        return ErrorPageRegistrar { registry: ErrorPageRegistry -> registerErrorPages(registry) }
    }

    private fun registerErrorPages(registry: ErrorPageRegistry) {
        registry.addErrorPages(ErrorPage(HttpStatus.BAD_REQUEST, "/400"))
    } 
}
```

{: .note }
필터에 의해 처리되는 패스로 에러페이지(ErrorPage)를 등록하는 경우(저지(Jersey) 및 위켓(Wicket)과 같은 일부 스프링이 아닌 웹 프레임워크에서 일반적으로 발생함) 필터는 다음 예제와 같이 ERROR 디스패처로 명시적으로 등록되어야 한다.

`자바`
```java
import java.util.EnumSet;
import jakarta.servlet.DispatcherType;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
public class MyFilterConfiguration {
    @Bean
    public FilterRegistrationBean<MyFilter> myFilter() {
        FilterRegistrationBean<MyFilter> registration = new FilterRegistrationBean<>(new MyFilter());
        // ...
        registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
        return registration;
    } 
}
```

`코틀린`
```kotlin
import jakarta.servlet.DispatcherType
import org.springframework.boot.web.servlet.FilterRegistrationBean
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import java.util.EnumSet

@Configuration(proxyBeanMethods = false)
class MyFilterConfiguration {
    @Bean
    fun myFilter(): FilterRegistrationBean<MyFilter> {
        val registration = FilterRegistrationBean(MyFilter())
        // ...
        registration.setDispatcherTypes(EnumSet.allOf(DispatcherType::class.java))
        return registration
    } 
}
```
기본 `필터레지스트레이션빈(FilterRegistrationBean)`에는 ERROR 디스패처 타입이 포함되어 있지 않다.


#### War 배포 시 오류 처리(Error Handling in a WAR Deployment)
서블릿 컨테이너에 배포되면 스프링 부트는 오류 페이지 필터를 사용하여 오류 상태가 있는 요청을 적절한 오류 페이지로 전달한다. 이는 서블릿 사양이 오류 페이지 등록을 위한 API를 제공하지 않기 때문에 필요하다. war 파일을 배포하는 컨테이너와 애플리케이션에서 사용하는 기술에 따라 몇 가지 추가 구성이 필요할 수 있다.

오류 페이지 필터는 응답이 아직 커밋되지 않은 경우에만 요청을 올바른 오류 페이지로 전달할 수 있다. 기본적으로 웹스피어 애플리케이션 서버(WebSphere Application Server) 8.0 이상에서는 서블릿의 서비스 메소드가 성공적으로 완료되면 응답을 커밋한다. `com.ibm.ws.webcontainer.invokeFlushAfterService`를 `false`로 설정하여 이 동작을 비활성화해야 한다.


#### CORS 지원(CORS Support)
CORS(Cross-origin resource sharing)는 IFRAME 또는 JSONP와 같이 덜 안전하고 덜 강력한 접근 방식을 사용하는 대신 어떤 종류의 도메인 간 요청이 승인되는지 유연한 방식으로 지정할 수 있도록 대부분의 브라우저에서 구현되는 W3C 사양이다.

버전 4.2부터 스프링 MVC는 CORS를 지원합니다. 스프링 부트 애플리케이션에서 `@CrossOrigin` 어노테이션과 함께 컨트롤러 메서드 CORS 구성을 사용하면 특정 구성이 필요하지 않다. 다음 예제와 같이 커스텀 `addCorsMappings(CorsRegistry)` 메소드를 사용하여 `웹Mvc컨피규어러(WebMvcConfigurer)` 빈을 등록하여 스태틱 CORS 구성을 정의할 수 있다.

`자바`
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration(proxyBeanMethods = false)
public class MyCorsConfiguration {
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**");
            }
        }; 
    }
}
```

`코틀린`
```kotlin
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.servlet.config.annotation.CorsRegistry
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer

@Configuration(proxyBeanMethods = false)
class MyCorsConfiguration {
    @Bean
    fun corsConfigurer(): WebMvcConfigurer {
        return object : WebMvcConfigurer {
            override fun addCorsMappings(registry: CorsRegistry) {
                registry.addMapping("/api/**")
            }
        } 
    }
}

```