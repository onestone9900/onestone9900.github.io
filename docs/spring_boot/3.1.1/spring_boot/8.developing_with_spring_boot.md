---
layout: default
title: 8. 웹(Web)
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 8
---

***
8. 웹
    - 8.1. 서블릿 웹 애플리케이션(Servlet Web Applications)
        - 8.1.1. 스프링 웹 MVC 프레임워크(The “Spring Web MVC Framework”)
            Spring MVC 자동 구성(Spring MVC Auto-configuration)
            Http메세지컨버터(HttpMessageConverters)
            메세지코드리졸버(MessageCodesResolver)
            정적 콘텐츠(Static Content)
            웰컴 페이지(Welcome Page)
            커스텀 파비콘(Custom Favicon)
            패스 매칭 앤 컨텐츠 협상(Path Matching and Content Negotiation)
            컨피규러블웹바인딩이니셜라이저(ConfigurableWebBindingInitializer)
            템플릿 엔진(Template Engines)
            에러 핸들링(Error Handling)
            CORS 지원(CORS Support)
        - 8.1.2. JAX-RS 및 저지(JAX-RS and Jersey)
        - 8.1.3. 임베디드 서블릿 컨테이너 지원(Embedded Servlet Container Support)
            서블릿, 필터, 리스너(Servlets, Filters, and Listeners)Servlets, Filters, and Listeners
            서블릿 컨텍스트 초기화(Servlet Context Initialization)
            서블릿웹서버애플리케이션컨텍스트(The ServletWebServerApplicationContext)
            임베디드 서블릿 컨테이너 커스텀(Customizing Embedded Servlet Containers)
            JSP 제한사항(JSP Limitations)
    - 8.2. 리액티브 웹 애플리케이션(Reactive Web Applications)
        - 8.2.1. 스프링 웹플럭스 프레임워크(The “Spring WebFlux Framework”)
            스프링 웹 플럭스 자동구성(Spring WebFlux Auto-configuration)
            HttpMessageReaders 및 HttpMessageWriters가 포함된 HTTP 코덱(HTTP Codecs with HttpMessageReaders and HttpMessageWriters)
            정적 콘텐츠(Static Content)
            웰컴 페이지(Welcome Page)
            템플릿 엔진(Template Engines)
            에러 핸들링(Error Handling)
            웹 필터(Web Filters)
        - 8.2.2. 임베디드 리액티브 서버 지원(Embedded Reactive Server Support)
        - 8.2.3. 리액티브 서버 리소스 컨피규레이션(Reactive Server Resources Configuration)
    - 8.3. 정상 종료(Graceful Shutdown)
    - 8.4. Spring Security
        - 8.4.1. MVC Security
        - 8.4.2. WebFlux Security
        - 8.4.3. OAuth2
            Client
            Resource Server
            Authorization Server
        - 8.4.4. SAML 2.0
            Relying Party
    - 8.5. Spring Session
    - 8.6. Spring for GraphQL
        - 8.6.1. GraphQL Schema
        - 8.6.2. GraphQL RuntimeWiring
        - 8.6.3. Querydsl and QueryByExample Repositories Support
        - 8.6.4. Transports
            HTTP and WebSocket
            RSocket
        - 8.6.5. Exception Handling
        - 8.6.6. GraphiQL and Schema printer
    - 8.7. Spring HATEOAS
    - 8.8. What to Read Next
***


# 8. 웹(Web)
스프링 부트는 웹 애플리케이션 개발에 매우 ​​적합하다. 임베디드 톰캣, 제티(Jetty), 언더토우(Undertow) 또는 네티(Netty)를 사용하여 독립형 HTTP 서버를 생성할 수 있다. 대부분의 웹 애플리케이션은 `spring-boot-starter-web` 모듈을 사용하여 빠르게 시작하고 실행한다. `spring-boot-starter-webflux` 모듈을 사용하여 리액티브 웹 애플리케이션을 구축하도록 선택할 수도 있다.

아직 스프링 부트 웹 애플리케이션을 개발하지 않았다면 [시작하기(Getting Started)](https://onestone9900.github.io/docs/spring_boot/3.1.1/spring_boot/4.getting_started/#4-getting-started) 장의 예제인 "Hello World!"를 따라할 수 있다.


## 8.1. 서블릿 웹 애플리케이션(Servlet Web Applications)
서블릿 기반 웹 애플리케이션을 구축하려는 경우 스프링MVC 또는 저지(Jersey)에 대한 스프링 부트 자동 구성(auto-configuration)을 활용할 수 있다.


### 8.1.1. 스프링 웹 MVC 프레임워크(The “Spring Web MVC Framework”)
스프링 웹 MVC 프레임워크(종종 “스프링 MVC”라고도 함)는 풍부한 “모델 뷰 컨트롤러” 웹 프레임워크이다. 스프링 MVC를 사용하면 들어오는 HTTP 요청(request)을 처리하기 위해 특별한 `@Controller` 또는 `@RestController` 빈을 생성할 수 있다. 컨트롤러의 메서드는 `@RequestMapping` 어노테이션을 사용하여 HTTP에 매핑된다.

다음 코드는 제이슨(JSON) 데이터를 제공하는 일반적인 `@RestController`를 보여준다.

`자바`
```java
import java.util.List;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/users")
public class MyRestController {
    private final UserRepository userRepository;
    private final CustomerRepository customerRepository;
    public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) {
        this.userRepository = userRepository;
        this.customerRepository = customerRepository;
    }

    @GetMapping("/{userId}")
    public User getUser(@PathVariable Long userId) {
        return this.userRepository.findById(userId).get();
    }

    @GetMapping("/{userId}/customers")
    public List<Customer> getUserCustomers(@PathVariable Long userId) {
        return this.userRepository.findById(userId).map(this.customerRepository::findByUser).get();
    }

    @DeleteMapping("/{userId}")
    public void deleteUser(@PathVariable Long userId) {
        this.userRepository.deleteById(userId);
    }
}
```

`코틀린`
```kotlin
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/users")
class MyRestController(private val userRepository: UserRepository, private val customerRepository: CustomerRepository) {
    @GetMapping("/{userId}")
    fun getUser(@PathVariable userId: Long): User {
        return userRepository.findById(userId).get()
    }

    @GetMapping("/{userId}/customers")
    fun getUserCustomers(@PathVariable userId: Long): List<Customer> {
        return userRepository.findById(userId).map(customerRepository::findByUser).get()
    }

    @DeleteMapping("/{userId}")
    fun deleteUser(@PathVariable userId: Long) {
        userRepository.deleteById(userId)
    }
}
```

기능적 변형인 "WebMvc.fn"은 다음 예제와 같이 라우팅 구성을 요청의 실제 처리와 분리한다.

`자바`
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.web.servlet.function.RequestPredicate;
import org.springframework.web.servlet.function.RouterFunction;
import org.springframework.web.servlet.function.ServerResponse;
import static org.springframework.web.servlet.function.RequestPredicates.accept;
import static org.springframework.web.servlet.function.RouterFunctions.route;

@Configuration(proxyBeanMethods = false)
public class MyRoutingConfiguration {
    private static final RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);

    @Bean
    public RouterFunction<ServerResponse> routerFunction(MyUserHandler userHandler) {
        return route()
                .GET("/{user}", ACCEPT_JSON, userHandler::getUser)
                .GET("/{user}/customers", ACCEPT_JSON, userHandler::getUserCustomers)
                .DELETE("/{user}", ACCEPT_JSON, userHandler::deleteUser)
                .build();
    } 
}
```

`코틀린`
```kotlin
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.MediaType
import org.springframework.web.servlet.function.RequestPredicates.accept
import org.springframework.web.servlet.function.RouterFunction
import org.springframework.web.servlet.function.RouterFunctions
import org.springframework.web.servlet.function.ServerResponse

@Configuration(proxyBeanMethods = false)
class MyRoutingConfiguration {
    @Bean
    fun routerFunction(userHandler: MyUserHandler): RouterFunction<ServerResponse> {
        return RouterFunctions.route()
            .GET("/{user}", ACCEPT_JSON, userHandler::getUser)
            .GET("/{user}/customers", ACCEPT_JSON, userHandler::getUserCustomers)
            .DELETE("/{user}", ACCEPT_JSON, userHandler::deleteUser)
            .build()
    }

    companion object {
        private val ACCEPT_JSON = accept(MediaType.APPLICATION_JSON)
    } 
}
```

`자바`
```java
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.function.ServerRequest;
import org.springframework.web.servlet.function.ServerResponse;

@Component
public class MyUserHandler {
    public ServerResponse getUser(ServerRequest request) {
        ...
        return ServerResponse.ok().build();
    }

    public ServerResponse getUserCustomers(ServerRequest request) {
        ...
        return ServerResponse.ok().build();
    }

    public ServerResponse deleteUser(ServerRequest request) {
        ...
        return ServerResponse.ok().build();
    }
}
```

`코틀린`
```kotlin
import org.springframework.stereotype.Component
import org.springframework.web.servlet.function.ServerRequest
import org.springframework.web.servlet.function.ServerResponse

@Component
class MyUserHandler {
    fun getUser(request: ServerRequest?): ServerResponse {
        return ServerResponse.ok().build()
    }

    fun getUserCustomers(request: ServerRequest?): ServerResponse {
        return ServerResponse.ok().build()
    }

    fun deleteUser(request: ServerRequest?): ServerResponse {
        return ServerResponse.ok().build()
    } 
}
```

스프링 MVC는 코어 스프링 프레임워크의 일부이며 자세한 정보는 [레퍼런스 문서](https://docs.spring.io/spring-framework/docs/6.0.10/reference/html/web.html#mvc)에서 확인할 수 있다. [`spring.io/guides`](https://spring.io/guides)에는 스프링 MVC를 다루는 여러 가이드도 있다.

{: .note }
라우터 정의를 모듈화하기 위해 원하는 만큼 `라우터펑션(RouterFunction)` 빈을 정의할 수 있다. 우선순위를 적용해야 하는 경우 빈의 순위를 정할 수 있다.


#### 스프링 MVC 자동 구성(Spring MVC Auto-configuration)
스프링 부트는 대부분의 애플리케이션에서 잘 작동하는 스프링 MVC에 대한 자동 구성(auto-configuration)을 제공한다.

자동 구성은 스프링의 기본값 위에 다음 기능을 추가한다.
- `콘텐트네고시에이팅뷰리졸버(ContentNegotiatingViewResolver)` 및 `빈네임뷰리졸버(BeanNameViewResolver)` 빈이 포함된다.
- `WebJars` 지원을 포함하여, 스태틱(Static) 리소스 제공을 지원한다(문서의 뒷부분에서 설명).
- `컨버터(Converter)`, `제네릭컨버터(GenericConverter)` 및 `포매터(Formatter)` 빈의 자동 등록.
- `Http메세지컨버터(HttpMessageConverters)` 지원(문서의 뒷부분에서 설명)
- `메세지코드리졸버(MessageCodesResolver)` 자동 등록(문서의 뒷부분에서 설명)
- 스태틱(Static) index.html 지원.
- `컨피규러블웹바인딩이셜라이저(ConfigurableWebBindingInitializer)` 빈의 자동 사용(이 문서의 뒷부분에서 설명)

이러한 스프링 부트 MVC 커스텀(customization)을 유지하고 더 많은 MVC 커스텀(인터셉터(interceptor), 포맷터(formatter), 뷰 컨트롤러(view controller) 및 기타 기능)를 수행하려는 경우 `@EnableWebMvc` 없이 웹Mvc컨피규어러(WebMvcConfigurer) 타입의 고유한 `@Configuration `클래스를 추가할 수 있다.

`리퀘스트매핑핸들러매핑(RequestMappingHandlerMapping)`, `리퀘스트매핑핸들러어댑터(RequestMappingHandlerAdapter)` 또는 `익셉션핸들러익셉션리졸버(ExceptionHandlerExceptionResolver)`의 커스텀 인스턴스를 제공하고 여전히 스프링 부트 MVC 커스텀를 유지하려는 경우 웹Mvc레지스트레이션(WebMvcRegistrations) 타입의 빈을 선언하고 이를 사용하여 해당 컴포넌트의 커스텀 인스턴스를 제공할 수 있다.

스프링 MVC를 완전히 제어하려면, `@EnableWebMvc` 어노테이션이 달린 고유한 `@Configuration`을 추가하거나 `@EnableWebMvc`의 자바독(Javadoc)에 설명된 대로 고유한 `@Configuration` 어노테이션이 달린 `델리게이팅웹Mvc컨피규레이션(DelegatingWebMvcConfiguration)`을 추가할 수 있다.

***
`노트`

스프링 MVC는 `application.properties` 또는 `application.yaml` 파일의 값을 변환하는 데 사용되는 것과 다른 `컨버전서비스(ConversionService)`를 사용한다. 이는 피리어드(Period), 듀레이션(Duration) 및 데이터사이즈(DataSize) 컨버터를 사용할 수 없으며 `@DurationUnit` 및 `@DataSizeUnit` 어노테이션이 무시된다는 의미다.

스프링 MVC에서 사용되는 컨버전서비스(ConversionService)를 커스텀하려면 `addFormatters` 메소드와 함께 `웹Mvc컨피규어러(WebMvcConfigurer)` 빈을 제공할 수 있다. 이 메서드에서 원하는 컨버터를 등록하거나 `애플리케이션컨버전서비스(ApplicationConversionService)`에서 사용 가능한 스태틱 메서드에 위임할 수 있다.
***


#### Http메시지컨버터(HttpMessageConverters)
스프링 MVC는 Http메세지컨버터(HttpMessageConverter) 인터페이스를 사용하여 HTTP 요청(request)과 응답(responses)을 변환(convert)한다. 기본적으로 합리적인 기본값이 포함되어 있다. 예를 들어 객체는 자동으로 JSON(잭슨(Jackson) 라이브러리 사용) 또는 XML(사용 가능한 경우 잭슨(Jackson) XML 확장 사용 또는 잭슨(Jackson) XML 확장을 사용할 수 없는 경우 JAXB 사용)로 변환할 수 있다. 기본적으로 문자열은 UTF-8로 인코딩된다.

컨버터를 추가하거나 커스텀해야 하는 경우 다음 목록에 표시된 것처럼 스프링 부트의 Http메세지컨버터(HttpMessageConverters) 클래스를 사용할 수 있다.

`자바`
```java
import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;

@Configuration(proxyBeanMethods = false)
public class MyHttpMessageConvertersConfiguration {
    @Bean
    public HttpMessageConverters customConverters() {
        HttpMessageConverter<?> additional = new AdditionalHttpMessageConverter();
        HttpMessageConverter<?> another = new AnotherHttpMessageConverter();
        return new HttpMessageConverters(additional, another);
    } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.autoconfigure.http.HttpMessageConverters
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.converter.HttpMessageConverter

@Configuration(proxyBeanMethods = false)
class MyHttpMessageConvertersConfiguration {
    @Bean
    fun customConverters(): HttpMessageConverters {
        val additional: HttpMessageConverter<*> = AdditionalHttpMessageConverter()
        val another: HttpMessageConverter<*> = AnotherHttpMessageConverter()
        return HttpMessageConverters(additional, another)
    } 
}
```

컨텍스트에 존재하는 모든 Http메세지컨버터(HttpMessageConverter) 빈은 컨버터 목록에 추가된다. 동일한 방식으로 기본 컨버터를 오버라이드할 수도 있다.


#### 메세지코드리졸버(MessageCodesResolver)
스프링 MVC에는 바인딩 오류로부터 오류 메시지를 렌더링하기 위한 오류 코드(메세지코드리졸버(MessageCodesResolver))를 생성하는 전략이 있다. `spring.mvc.message-codes-resolver-format` 프로퍼티 `PREFIX_ERROR_CODE` 또는 `POSTFIX_ERROR_CODE`를 설정하면 스프링 부트가 자동으로 하나를 생성한다(`DefaultMessageCodesResolver.Format`의 이넘 참조).

Spring MVC has a strategy for generating error codes for rendering error messages from binding errors: MessageCodesResolver. If you set the spring.mvc.message-codes-resolver-format property PREFIX_ERROR_CODE or POSTFIX_ERROR_CODE, Spring Boot creates one for you (see the enumeration in DefaultMessageCodesResolver.Format).


#### 정적 컨텐츠(Static Content)
기본적으로 스프링 부트는 클래스패스의 `/static`(또는 `/public`, `/resources` 또는 `/META-INF/resources`)이라는 디렉터리나 `서블릿컨텍스트(ServletContext)` 루트에서 스태틱 콘텐츠를 제공한다. 이는 스프링 MVC의 `리소스Http리퀘스트핸들러(ResourceHttpRequestHandler)`를 사용하므로 사용자는 자체 `웹Mvc컨피규어러(WebMvcConfigurer)`를 추가하고 `addResourceHandlers` 메서드를 오버라이드하여 해당 동작을 수정할 수 있다.

독립형(stand-alone) 웹 애플리케이션에서는 컨테이너의 기본 서블릿이 활성화되지 않는다. `server.servlet.register-default-servlet` 프로퍼티를 사용하여 활성화할 수 있다.

기본 서블릿은 스프링이 처리하지 않기로 결정한 경우 서블릿컨텍스트(ServletContext)의 루트에서 콘텐츠를 제공하는 폴백(fallback) 역할을 한다. 기본 MVC 구성을 수정하지 않는 한 대부분은 발생하지 않는다. 왜냐하면 스프링은 항상 `디스패처서블릿(DispatcherServlet)`을 통해 요청(request)을 처리할 수 있기 때문이다.

기본적으로 리소스는 `/**`에 매핑되지만 `spring.mvc.static-path-pattern` 프로퍼티을 사용하여 이를 조정할 수 있다. 예를 들어 모든 리소스를 `/resources/**`에 재배치하는 방법은 다음과 같다.

`프로퍼티스`
```Properties
spring.mvc.static-path-pattern=/resources/**
```

`Yaml`
```yaml
spring: 
  mvc:
    static-path-pattern: "/resources/**"
```

`spring.web.resources.static-location` 프로퍼티스를 사용하여 스태틱 리소스 위치를 커스텀할 수도 있다(기본값을 디렉터리 위치 리스트로 대체). 루트 서블릿 컨텍스트 패스인 "/"도 해당위치로 추가된다.

앞서 언급한 "표준" 스태틱 리소스 위치 외에도 [`Webjars` 컨텐트]에 대한 특별한 경우가 있다. 기본적으로 `/webjars/**`에 패스가 있는 모든 리소스는 `Webjars` 포맷으로 패키지된 경우 jar 파일에서 제공된다. 패스는 `spring.mvc.webjars-path-pattern` 프로퍼티를 사용하여 커스텀할 수 있다.

{: .note}
애플리케이션이 jar로 패키지된 경우 `src/main/webapp` 디렉토리를 사용하지 말자. 이 디렉토리는 일반적인 표준이지만 `war` 패키징에서만 작동하며 jar을 생성하는 경우 대부분의 빌드 도구에서 자동으로 무시된다.

스프링 부트는 또한 스프링 MVC에서 제공하는 고급 리소스 처리 기능을 지원하여 캐시 버스팅 스태틱 리소스(cache-busting static resources) 또는 `Webjar` 버전에 구애받지 않는 URL 사용과 같은 사례를 허용한다.

`Webjars`에 대해 버전에 구애받지 않는 URL을 사용하려면 `webjars-locator-core` 의존성을 추가하자. 그런 다음 `Webjar`을 선언하자. 예를 들어 `jQuery`를 사용하면 "/webjars/jquery/jquery.min.js"를 추가했을 때 "/webjars/jquery/x.y.z/jquery.min.js"가 된다. 여기서 x.y.z는 Webjar 버전이다.

{: .note }
제이보스(JBoss)를 사용하는 경우 `webjars-locator-core` 대신 `webjars-locator-jboss-vfs` 의존성성을 선언해야 한다. 그렇지 않으면 모든 Webjar가 404로 처리된다.

캐시 무효화를 사용하기 위해 다음 구성은 모든 스태틱 리소스에 대한 캐시 무효화 솔루션을 구성하여 <link href="/css/spring- 2a2d595e6ed9a0b24f027f2b63b134d6.css"/>와 같은 콘텐츠 해시를 URL에 효과적으로 추가한다.

`프로퍼티스(Properties)`
```
spring.web.resources.chain.strategy.content.enabled=true
spring.web.resources.chain.strategy.content.paths=/**
```

`Yaml`
```yaml
spring: 
  web:
    resources:
      chain:
        strategy:
          content:
            enabled: true
            paths: "/**"
```

{: .note }
Thymeleaf 및 FreeMarker에 대해 자동으로 구성된 `리소스Url인코딩필터(ResourceUrlEncodingFilter)` 덕분에 리소스에 대한 링크는 런타임 시 템플릿에 재작성된다. JSP를 사용할 때 이 필터를 수동으로 선언해야 한다. 다른 템플릿 엔진은 현재 자동으로 지원되지 않지만 커스텀 템플릿 macros/helpers 및 `리소스Url프로바이더(ResourceUrlProvider)`를 사용할 수 있다.

예를 들어 자바스크립트 모듈 로더를 사용하여 리소스를 동적으로 로드할 때 파일명을 바꾸는 것은 옵션이 아니다. 그렇기 때문에 다른 전략도 지원되고 결합될 수 있다. "고정(fixed)" 전략은 다음 예와 같이 파일명을 변경하지 않고 URL에 스태틱 버전 문자열을 추가한다.

`프로퍼티스(Properties)`
```
spring.web.resources.chain.strategy.content.enabled=true
spring.web.resources.chain.strategy.content.paths=/**
spring.web.resources.chain.strategy.fixed.enabled=true
spring.web.resources.chain.strategy.fixed.paths=/js/lib/
spring.web.resources.chain.strategy.fixed.version=v12
```

`Yaml`
```yaml
spring: 
  web:
    resources:
      chain:
        strategy:
          content:
            enabled: true
            paths: "/**"
          fixed:
            enabled: true
            paths: "/js/lib/"
            version: "v12"
```

이 구성을 사용하면 "/js/lib/" 아래에 있는 자바스크립트 모듈은 고정 버전 관리 전략("/v12/js/lib/mymodule.js")을 사용하는 반면, 다른 리소스는 여전히 컨텐트 전략(<link href="/ css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/>)을 사용한다.

지원되는 추가 옵션은 `WebProperties.Resources`를 참고하자.

{: .note }
이 기능은 [블로그 게시물](https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources)과 [스프링 프레임워크의 레퍼런스 문서](https://docs.spring.io/spring-framework/docs/6.0.10/reference/html/web.html#mvc-config-static-resources)에 자세히 설명되어 있다.


#### 웰컴 페이지(Welcome Page)
스프링 부트는 스태틱 및 템플릿 웰컴 페이지를 모두 지원한다. 먼저 구성된 스태틱 콘텐츠 위치에서 index.html 파일을 찾는다. 찾을 수 없으면 인덱스 템플릿을 찾는다. 둘 중 하나가 발견되면 자동으로 애플리케이션의 웰컴 페이지로 사용된다.


#### 커스텀 파비콘(Custom Favicon)
다른 정적 리소스와 마찬가지로, 스프링 부트는 구성된 스태틱 콘텐츠 위치에서 favicon.ico를 확인한다. 해당 파일이 있으면 자동으로 애플리케이션의 파비콘으로 사용된다.


#### 패스 매칭 앤 컨텐트 협상(Path Matching and Content Negotiation)
스프링 MVC는 요청(request) 패스를 보고 이를 애플리케이션에 정의된 매핑(예: 컨트롤러 메서드의 @GetMapping 어노테이션)과 일치시켜 들어오는 HTTP 요청(request)을 핸들러에 매핑할 수 있다.

스프링 부트는 기본적으로 접미사 패턴 일치를 비활성화하도록 한다. 이는 "GET /projects/spring-boot.json"과 같은 요청이 @GetMapping("/projects/spring-boot") 매핑과 일치하지 않음을 의미한다. 이는 스프링 MVC 애플리케이션의 [모범 사례](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-requestmapping.html#mvc-ann-requestmapping-suffix-pattern-match)로 여겨진다. 이 기능은 과거에 적절한 "Accept" 요청 헤더를 보내지 않은 HTTP 클라이언트에 주로 유용했다. 우리는 올바른 콘텐츠 타입을 클라이언트에 보내야 했다. 요즘에는 컨텐트 협상이 훨씬 더 안정적이다.

적절한 "Accept" 요청 헤더를 일관되게 보내지 않는 HTTP 클라이언트를 처리하는 다른 방법이 있다. 접미사 일치를 사용하는 대신 쿼리 파라미터를 사용하여 "GET /projects/spring-boot?format=json"과 같은 요청이 @GetMapping("/projects/spring-boot")에 매핑되도록 할 수 있다.

`프로퍼티스(Properties)`
```
spring.mvc.contentnegotiation.favor-parameter=true
```

`Yaml`
```yaml
spring: 
  mvc:
    contentnegotiation:
      favor-parameter: true
```


또는 다른 파라미터명을 사용하려는 경우.

`프로퍼티스(Properties)`
```
spring.mvc.contentnegotiation.favor-parameter=true
spring.mvc.contentnegotiation.parameter-name=myparam
```

`Yaml`
```yaml
spring: 
  mvc:
    contentnegotiation:
      favor-parameter: true
      parameter-name: "myparam"
```

대부분의 표준 미디어 타입(media types)은 기본적으로 지원되지만, 새로운 타입을 정의할 수도 있다.

`프로퍼티스(Properties)`
```
spring.mvc.contentnegotiation.media-types.markdown=text/markdown
```

`Yaml`
```yaml
spring: 
  mvc:
    contentnegotiation:
      media-types:
        markdown: "text/markdown"
```

스프링 프레임워크 5.3부터 스프링 MVC는 요청 패스를 컨트롤러 핸들러와 일치시키기 위한 여러 구현 전략을 지원한다. 이전에는 `앤트패스매처(AntPathMatcher)` 전략만 지원했지만 이제는 `패스패턴파서(PathPatternParser)`도 제공한다. 이제 스프링 부트는 새로운 전략을 선택하고 선택할 수 있는 구성 프로퍼티를 제공한다.

`프로퍼티스(Properties)`
```
spring.mvc.pathmatch.matching-strategy=path-pattern-parser
```

`Yaml`
```yaml
spring: 
  mvc:
    pathmatch:
      matching-strategy: "path-pattern-parser"
```

이 새로운 구현을 고려해야 하는 이유에 대한 자세한 내용은 [전용 블로그 게시물](https://spring.io/blog/2020/06/30/url-matching-with-pathpattern-in-spring-mvc)을 참고하자.

{: .note }
`패스패턴파서(PathPatternParser)`는 최적화된 구현이지만 일부 패스 패턴 변형(path patterns variants)의 사용을 제한한다. 서블릿 접두사(spring.mvc.servlet.path)를 사용하여 `디스패처서블릿(DispatcherServlet)`을 매핑하거나 접미사 패턴을 매핑하는 것과 호환되지 않는다.

기본적으로, 스프링 MVC는 요청에 대한 핸들러를 찾을 수 없으면 `404 Not Found` 오류 응답을 보낸다. 대신 `노핸들러파운드익셉션(NoHandlerFoundException)`을 발생시키려면 `configprop:spring.mvc.throw-Exception-if-no-handler-found`를 true로 설정하자. 기본적으로 스태틱 콘텐츠 제공은 `/**`에 매핑되므로 모든 요청에 ​​대한 핸들러를 제공한다. `노핸들러파운드익셉션(NoHandlerFoundException)`이 발생하려면 `spring.mvc.static-path-pattern`을 `/resources/**`와 같은 보다 구체적인 값으로 설정하거나 `spring.web.resources.add-mappings`를 false로 설정하여 스태틱 서비스 제공을 비활성화해야 한다.


#### 컨피규러블웹바인딩이니셜라이저(ConfigurableWebBindingInitializer)
스프링 MVC는 `웹바인딩이니셜라이저(WebBindingInitializer)`를 사용하여 특정 요청에 대한 `웹데이터바인더(WebDataBinder)`를 초기화한다. 자신만의 `컨피규러블웹바인딩이니셜라이저(ConfigurableWebBindingInitializer)` @Bean을 생성하면 스프링 부트는 이를 사용하도록 스프링 MVC를 자동으로 구성한다.


#### 템플릿 엔진(Template Engines)
REST 웹 서비스뿐만 아니라, 스프링 MVC를 사용하여 동적(dynamic) HTML 콘텐츠를 제공할 수도 있다. 스프링 MVC는 Thymeleaf, FreeMarker 및 JSP를 포함한 다양한 템플릿 기술을 지원한다. 또한 다른 많은 템플릿 엔진에는 자체 스프링 MVC 통합이 포함되어 있다.

스프링 부트에는 다음 템플릿 엔진에 대한 자동 구성 지원이 포함되어 있다.
- [FreeMarker](https://freemarker.apache.org/docs/)
- [Groovy](https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine)
- [Thymeleaf](https://www.thymeleaf.org/)
- [Mustache](https://mustache.github.io/)

{: .note }
가능하다면 JSP는 피해야 한다. 임베디드 서블릿 컨테이너와 함께 사용할 때 몇 가지 알려진 제한 사항이 있다.

기본 구성으로 이러한 템플릿 엔진 중 하나를 사용하면 템플릿이 `src/main/resources/templates`에서 자동 선택된다.

{: .note }
애플리케이션을 실행하는 방법에 따라 IDE에서 클래스패스 순서를 다르게 지정할 수 있다. IDE의 메인 메서드에서 애플리케이션을 실행하면 메이븐이나 그레이들을 사용하거나 패키지된 jar에서 애플리케이션을 실행할 때와 순서가 달라진다. 이로 인해 스프링 부트가 예상 템플릿을 찾지 못할 수 있다. 이 문제가 발생하면 IDE에서 클래스패스의 순서를 변경하여 모듈의 클래스와 리소스를 먼저 배치할 수 있다.


#### 에러 핸들링(Error Handling)
기본적으로, 스프링 부트는 모든 오류를 합리적인 방식으로 처리하는 `/error` 매핑을 제공하며 이는 서블릿 컨테이너에 "전역(“global”)" 오류 페이지로 등록된다. 머신 클라이언트의 경우 오류 세부정보, HTTP 상태 및 예외 메시지가 포함된 JSON 응답을 생성한다. 브라우저 클라이언트의 경우 동일한 데이터를 HTML 형식으로 렌더링하는 "화이트라벨(whitelabel)" 오류 뷰가 있다(커스텀하려면 `에러`를 해결하는 `뷰`를 추가하자).

기본 오류 처리 동작을 커스텀하려는 경우 설정할 수 있는 다양한 `server.error` 프로퍼티가 있다. 부록의 "서버 프로퍼티스(Server Properties)" 절을 참고하자.

{: .note}
기본 동작을 완전히 대체하려면 `에러컨트롤러(ErrorController)`를 구현하고 해당 타입의 빈을 등록하거나 에러애트리뷰트(ErrorAttributes) 타입의 빈을 추가하여 기존 메커니즘을 사용하되 내용을 대체할 수 있다.

스프링 프레임워크 6.0부터 [RFC 7807 상세 문제](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-ann-rest-exceptions.html)가 지원된다. 스프링 MVC는 다음과 같이 `application/problem+json` 미디어 타입을 사용하여 커스텀 오류 메시지를 생성할 수 있다.

```
{
    "type": "https://example.org/problems/unknown-project",
    "title": "Unknown project",
    "status": 404,
    "detail": "No project found for id 'spring-unknown'",
    "instance": "/projects/spring-unknown"
}
```

이 지원은 `spring.mvc.problemdetails.enabled`를 `true`로 설정하여 활성화할 수 있다.


다음 예제와 같이 `@ControllerAdvice` 어노테이션이 달린 클래스를 정의하여 특정 컨트롤러 및/또는 예외 타입을 반환하도록 JSON 문서를 커스텀할 수도 있다.

`자바`
```java
import jakarta.servlet.RequestDispatcher;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

@ControllerAdvice(basePackageClasses = SomeController.class)
public class MyControllerAdvice extends ResponseEntityExceptionHandler {
    @ResponseBody
    @ExceptionHandler(MyException.class)
    public ResponseEntity<?> handleControllerException(HttpServletRequest request, Throwable ex) {
        HttpStatus status = getStatus(request);
        return new ResponseEntity<>(new MyErrorBody(status.value(), ex.getMessage()), status); 
    }

    private HttpStatus getStatus(HttpServletRequest request) {
        Integer code = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);
        HttpStatus status = HttpStatus.resolve(code);
        return (status != null) ? status : HttpStatus.INTERNAL_SERVER_ERROR;
    } 
}
```

`코틀린`
```kotlin
import jakarta.servlet.RequestDispatcher
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.ResponseBody
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler

@ControllerAdvice(basePackageClasses = [SomeController::class])
class MyControllerAdvice : ResponseEntityExceptionHandler() {
    @ResponseBody
    @ExceptionHandler(MyException::class)
    fun handleControllerException(request: HttpServletRequest, ex: Throwable): ResponseEntity<*> {
        val status = getStatus(request)
        return ResponseEntity(MyErrorBody(status.value(), ex.message), status)
    }

    private fun getStatus(request: HttpServletRequest): HttpStatus {
        val code = request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE) as Int
        val status = HttpStatus.resolve(code)
        return status ?: HttpStatus.INTERNAL_SERVER_ERROR
    } 
}
```

이전 예제에서, `SomeController`와 동일한 패키지에 정의된 컨트롤러에 의해 `MyException`이 발생하는 경우 `에러애트리뷰트(ErrorAttributes)` 표현 대신 `MyErrorBody` POJO의 JSON 표현이 사용된다.

컨트롤러 레벨에서 처리된 오류가 메트릭 인프라에 기록되지 않는 경우도 있다. 애플리케이션은 처리된 예외를 요청 애트리뷰트로 설정하여 이러한 예외가 요청 메트릭과 함께 기록되도록 할 수 있다.

```java
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.boot.web.servlet.error.ErrorAttributes;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ExceptionHandler;

@Controller
public class MyController {
    @ExceptionHandler(CustomException.class)
    String handleCustomException(HttpServletRequest request, CustomException ex) {
        request.setAttribute(ErrorAttributes.ERROR_ATTRIBUTE, ex);
        return "errorView";
    }
}
```

```kotlin
import jakarta.servlet.http.HttpServletRequest
import org.springframework.boot.web.servlet.error.ErrorAttributes
import org.springframework.stereotype.Controller
import org.springframework.web.bind.annotation.ExceptionHandler

@Controller
class MyController {
    @ExceptionHandler(CustomException::class)
    fun handleCustomException(request: HttpServletRequest, ex: CustomException?): String {
        request.setAttribute(ErrorAttributes.ERROR_ATTRIBUTE, ex)
        return "errorView"
    }
}
```

##### 커스텀 에러 페이지(Custom Error Pages)
특정 상태 코드에 대한 커스텀 HTML 오류 페이지를 표시하려면 /error 디렉터리에 파일을 추가하면 된다. 오류 페이지는 스태틱 HTML(즉, 스태틱 리소스 디렉터리에 추가됨)이거나 템플릿을 사용하여 작성될 수 있다. 파일명은 정확한 상태 코드이거나 시리즈 마스크(series mask)여야 한다.

예를 들어, 404를 스태틱 HTML 파일에 매핑하려면 디렉터리 구조는 다음과 같다.
```
src/
  +- main/
       +- java/
       |   + <source code>
       +- resources/
           +- public/
               +- error/
               |   +- 404.html
               +- <other public assets>
```

`프리매이커(FreeMarker)` 템플릿을 사용하여 모든 5xx 오류를 매핑하려면 디렉터리 구조는 다음과 같다.

```
src/
  +- main/
       +- java/
       |   + <source code>
       +- resources/
           +- templates/
               +- error/
               |   +- 5xx.ftlh
               +- <other templates>
```

보다 복잡한 매핑의 경우 다음 예제와 같이 `에러뷰리졸버(ErrorViewResolver)` 인터페이스를 구현하는 빈을 추가할 수도 있다.

`자바`
```java
import java.util.Map;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.boot.autoconfigure.web.servlet.error.ErrorViewResolver;
import org.springframework.http.HttpStatus;
import org.springframework.web.servlet.ModelAndView;

public class MyErrorViewResolver implements ErrorViewResolver {
    @Override
    public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map<String, Object> model) {
        // 요청 또는 상태를 사용하여 선택적으로 ModelAndView를 반환한다.
        if (status == HttpStatus.INSUFFICIENT_STORAGE) {
            // 여기에 커스텀 모델 값을 추가할 수 있다.
            new ModelAndView("myview");
        }
        return null;
    }
}
```

`코틀린`
```kotlin
import jakarta.servlet.http.HttpServletRequest
import org.springframework.boot.autoconfigure.web.servlet.error.ErrorViewResolver
import org.springframework.http.HttpStatus
import org.springframework.web.servlet.ModelAndView

class MyErrorViewResolver : ErrorViewResolver {
    override fun resolveErrorView(request: HttpServletRequest, status: HttpStatus, model: Map<String, Any>): ModelAndView? {
        // 요청 또는 상태를 사용하여 선택적으로 ModelAndView를 반환한다.
        if (status == HttpStatus.INSUFFICIENT_STORAGE) {
            // 여기에 커스텀 모델 값을 추가할 수 있다.
            return ModelAndView("myview")
        }

        return null 
    }
}
```

`@ExceptionHandler` 메서드 및 `@ControllerAdvice`와 같은 일반 스프링 MVC 기능을 사용할 수도 있다. 그런 다음 `에러컨트롤러(ErrorController)`는 처리되지 않은 예외를 선택한다.


##### 스프링 MVC 외부의 오류 페이지 매핑(Mapping Error Pages Outside of Spring MVC)
스프링 MVC를 사용하지 않는 애플리케이션의 경우 `에러페이지레지스트라(ErrorPageRegistrar)` 인터페이스를 사용하여 에러페이지(ErrorPages)를 직접 등록할 수 있다. 이 추상화는 기본 임베디드 서블릿 컨테이너와 직접 작동하며 스프링 MVC 디스패처서블릿(DispatcherServlet)이 없어도 작동한다.

`자바`
```java
import org.springframework.boot.web.server.ErrorPage;
import org.springframework.boot.web.server.ErrorPageRegistrar;
import org.springframework.boot.web.server.ErrorPageRegistry;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpStatus;

@Configuration(proxyBeanMethods = false)
public class MyErrorPagesConfiguration {
    @Bean
    public ErrorPageRegistrar errorPageRegistrar() {
        return this::registerErrorPages;
    }

    private void registerErrorPages(ErrorPageRegistry registry) {
        registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400"));
    } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.web.server.ErrorPage
import org.springframework.boot.web.server.ErrorPageRegistrar
import org.springframework.boot.web.server.ErrorPageRegistry
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.HttpStatus

@Configuration(proxyBeanMethods = false)
class MyErrorPagesConfiguration {
    @Bean
    fun errorPageRegistrar(): ErrorPageRegistrar {
        return ErrorPageRegistrar { registry: ErrorPageRegistry -> registerErrorPages(registry) }
    }

    private fun registerErrorPages(registry: ErrorPageRegistry) {
        registry.addErrorPages(ErrorPage(HttpStatus.BAD_REQUEST, "/400"))
    } 
}
```

{: .note }
필터에 의해 처리되는 패스로 에러페이지(ErrorPage)를 등록하는 경우(저지(Jersey) 및 위켓(Wicket)과 같은 일부 스프링이 아닌 웹 프레임워크에서 일반적으로 발생함) 필터는 다음 예제와 같이 ERROR 디스패처로 명시적으로 등록되어야 한다.

`자바`
```java
import java.util.EnumSet;
import jakarta.servlet.DispatcherType;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
public class MyFilterConfiguration {
    @Bean
    public FilterRegistrationBean<MyFilter> myFilter() {
        FilterRegistrationBean<MyFilter> registration = new FilterRegistrationBean<>(new MyFilter());
        // ...
        registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
        return registration;
    } 
}
```

`코틀린`
```kotlin
import jakarta.servlet.DispatcherType
import org.springframework.boot.web.servlet.FilterRegistrationBean
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import java.util.EnumSet

@Configuration(proxyBeanMethods = false)
class MyFilterConfiguration {
    @Bean
    fun myFilter(): FilterRegistrationBean<MyFilter> {
        val registration = FilterRegistrationBean(MyFilter())
        // ...
        registration.setDispatcherTypes(EnumSet.allOf(DispatcherType::class.java))
        return registration
    } 
}
```
기본 `필터레지스트레이션빈(FilterRegistrationBean)`에는 ERROR 디스패처 타입이 포함되어 있지 않다.


#### War 배포 시 오류 처리(Error Handling in a WAR Deployment)
서블릿 컨테이너에 배포되면 스프링 부트는 오류 페이지 필터를 사용하여 오류 상태가 있는 요청을 적절한 오류 페이지로 전달한다. 이는 서블릿 사양이 오류 페이지 등록을 위한 API를 제공하지 않기 때문에 필요하다. war 파일을 배포하는 컨테이너와 애플리케이션에서 사용하는 기술에 따라 몇 가지 추가 구성이 필요할 수 있다.

오류 페이지 필터는 응답이 아직 커밋되지 않은 경우에만 요청을 올바른 오류 페이지로 전달할 수 있다. 기본적으로 웹스피어 애플리케이션 서버(WebSphere Application Server) 8.0 이상에서는 서블릿의 서비스 메소드가 성공적으로 완료되면 응답을 커밋한다. `com.ibm.ws.webcontainer.invokeFlushAfterService`를 `false`로 설정하여 이 동작을 비활성화해야 한다.


#### CORS 지원(CORS Support)
CORS(Cross-origin resource sharing)는 IFRAME 또는 JSONP와 같이 덜 안전하고 덜 강력한 접근 방식을 사용하는 대신 어떤 종류의 도메인 간 요청이 승인되는지 유연한 방식으로 지정할 수 있도록 대부분의 브라우저에서 구현되는 W3C 사양이다.

버전 4.2부터 스프링 MVC는 CORS를 지원합니다. 스프링 부트 애플리케이션에서 `@CrossOrigin` 어노테이션과 함께 컨트롤러 메서드 CORS 구성을 사용하면 특정 구성이 필요하지 않다. 다음 예제와 같이 커스텀 `addCorsMappings(CorsRegistry)` 메소드를 사용하여 `웹Mvc컨피규어러(WebMvcConfigurer)` 빈을 등록하여 스태틱 CORS 구성을 정의할 수 있다.

`자바`
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration(proxyBeanMethods = false)
public class MyCorsConfiguration {
    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**");
            }
        }; 
    }
}
```

`코틀린`
```kotlin
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.servlet.config.annotation.CorsRegistry
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer

@Configuration(proxyBeanMethods = false)
class MyCorsConfiguration {
    @Bean
    fun corsConfigurer(): WebMvcConfigurer {
        return object : WebMvcConfigurer {
            override fun addCorsMappings(registry: CorsRegistry) {
                registry.addMapping("/api/**")
            }
        } 
    }
}
```


### 8.1.2. JAX-RS 및 저지(JAX-RS and Jersey)
REST 엔드포인트에 JAX-RS 프로그래밍 모델을 선호하는 경우 스프링 MVC 대신 사용 가능한 구현 중 하나를 사용할 수 있다. [저지(Jersey)](https://jersey.github.io/) 및 [아파치 CXF](https://cxf.apache.org/)는 기본적으로 매우 잘 작동한다. CXF를 사용하려면 애플리케이션 컨텍스트에서 서블릿이나 필터를 `@Bean`으로 등록해야 한다. 저지(Jersey)에는 일부 스프링 지원이 있으므로 스타터와 함께 스프링 부트에서 자동 구성 지원도 제공한다.

저지(Jersey)를 시작하려면 `spring-boot-starter-jersey`를 의존성으로 포함시킨 다음 다음 예제와 같이 모든 엔드포인트를 등록하는 리소스컨피그(ResourceConfig) 타입의 @Bean 하나가 필요하다.

```java
import org.glassfish.jersey.server.ResourceConfig;
import org.springframework.stereotype.Component;

@Component
public class MyJerseyConfig extends ResourceConfig {
    public MyJerseyConfig() {
        register(MyEndpoint.class);
    } 
}
```

{: .warning}
>실행 가능한 압축파일 검색에 대한 저지(Jersey)의 지원은 다소 제한적이다. 예를 들어, 실행 가능한 war 파일을 실행할 때 완전히 실행 가능한 jar 파일이나 `WEB-INF/classes`에 있는 패키지의 엔드포인트를 검색할 수 없다. 이러한 제한을 피하려면 `packages` 메소드를 사용하면 안 되며 앞의 예제와 같이 레지스터(Register) 메소드를 사용하여 엔드포인트를 개별적으로 등록해야 한다.

고급 커스텀를 위해, `리소스컨피그커스터마이저(ResourceConfigCustomizer)`를 구현하는 임의 개수의 빈을 등록할 수도 있다.

등록된 모든 엔드포인트는 다음 예제와 같이 HTTP 리소스 어노테이션(@GET 및 기타)이 있는 `@Components`여야 한다.

```java
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import org.springframework.stereotype.Component;

@Component
@Path("/hello")
public class MyEndpoint {
    @GET
    public String message() {
        return "Hello";
    }
}
```

엔드포인트는 스프링 `@Component`이므로 라이프사이클은 스프링에 의해 관리되며 `@Autowired` 어노테이션을 사용하여 의존성을 주입하고 `@Value` 어노테이션을 사용하여 외부 구성을 주입할 수 있다. 기본적으로 저지(Jersey) 서블릿은 `/*`에 등록되고 매핑된다. 리소스컨피그(ResourceConfig)에 `@ApplicationPath`를 추가하여 매핑을 변경할 수 있다.

기본적으로, 저지(Jersey)는 `저지서블릿레지스트레이션(JerseyServletRegistration)`이라는 `서블릿레지스트레이션빈(ServletRegistrationBean)` 타입의 `@Bean`에서 서블릿으로 설정된다. 기본적으로 서블릿은 느리게 초기화되지만 `spring.jersey.servlet.load-on-startup`을 설정하여 해당 동작을 커스텀할 수 있다. 동일한 이름을 가진 자신만의 빈을 생성하여 해당 빈을 비활성화하거나 오버라이드할 수 있다. `spring.jersey.type=filter`를 설정하여 서블릿 대신 필터를 사용할 수도 있다(이 경우 대체하거나 오버라이드할 `@Bean`은 저지필터레지스트레이션(JerseyFilterRegistration)이다). 필터에는 `spring.jersey.filter.order`로 설정할 수 있는 `@Order`가 있다. 저지(Jersey)를 필터로 사용하는 경우 저지(Jersey)가 가로채지 않는 모든 요청을 처리하는 서블릿이 있어야 한다. 애플리케이션에 이러한 서블릿이 포함되어 있지 않은 경우 `server.servlet.register-default-servlet`을 true로 설정하여 기본 서블릿을 활성화할 수 있다. 서블릿과 필터 등록 모두 프로퍼티스 맵을 지정하기 위해 `spring.jersey.init.*`를 사용하여 초기화 파라미터를 제공할 수 있다.


### 8.1.3. 임베디드 서블릿 컨테이너 지원(Embedded Servlet Container Support)
서블릿 애플리케이션의 경우 스프링 부트에는 임베디드 톰캣, 제티(Jetty) 및 언더토우(Undertow) 서버에 대한 지원이 포함되어 있다. 대부분의 개발자는 구성된 인스턴스를 얻기 위해 적절한 "스타터"를 사용한다. 기본적으로 임포트 서버는 포트 8080에서 HTTP 요청을 수신한다.


#### 서블릿, 필터, 리스너(Servlets, Filters, and Listeners)
임베디드 서블릿 컨테이너를 사용할 때 스프링 빈을 사용하거나 서블릿 컴포넌트를 검색하여 서블릿 사양에서 서블릿, 필터 및 모든 리스너(예: HttpSessionListener)를 등록할 수 있다.


##### 서블릿, 필터, 리스너를 스프링 빈으로 등록(Registering Servlets, Filters, and Listeners as Spring Beans)
스프링 빈인 모든 서블릿, 필터 또는 서블릿 *Listener 인스턴스는 임베디드 컨테이너에 등록된다. 이는 구성 중 `application.properties`의 값을 참조하려는 경우 특히 편리할 수 있다.

기본적으로, 컨텍스트에 싱글 서블릿만 포함된 경우 `/`에 매핑된다. 멀티 서블릿 빈의 경우 빈명이 패스 접두어로 사용된다. 필터는 `/*`에 매핑된다.

컨벤션 기반 매핑이 충분히 유연하지 않은 경우 완전한 제어를 위해 `서블릿레지스트레이션빈(ServletRegistrationBean)`, `필터레지스트레이션빈(FilterRegistrationBean)` 및 `서블릿리스너레지스트레이션빈(ServletListenerRegistrationBean)` 클래스를 사용할 수 있다.


일반적으로 필터 빈은 순서가 없는 상태로 두는 것이 안전하다. 특정 순서가 필요한 경우 필터에 `@Order` 어노테이션을 추가하거나 `Ordered`를 구현해야 한다. `@Order`로 빈(bean) 메소드에 어노테이션을 달아 필터의 순서를 구성할 수 없다. `@Order`를 추가하거나 `Ordered`를 구현하기 위해 `Filter` 클래스를 변경할 수 없는 경우 필터에 대한 `필터레지스트레이션빈(FilterRegistrationBean)`을 정의하고 `setOrder(int)` 메서드를 사용하여 등록된 빈의 순서를 설정해야 한다. `Ordered.HIGHEST_PRECEDENCE`에서 요청의 바디(request body)를 읽는 필터를 구성하지 말자. 애플리케이션의 문자 인코딩 구성에 어긋날 수 있기 때문이다. 서블릿 필터가 요청을 래핑하는 경우 `OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER`보다 작거나 같은 순서로 구성되어야 한다.

{: .note}
애플리케이션에서 모든 필터의 순서를 보려면 웹 로깅 그룹(logging.level.web=debug)에 대해 디버그 레벨 로깅을 활성화하자. 다음을 포함한 등록된 필터의 순서 및 URL 패턴이 시작 시 기록된다.

{: .warning}
>필터 빈은 애플리케이션 라이프사이클 초기에 초기화되므로 등록 시 주의하자. 상호작용하는 필터를 등록해야 하는 다른 빈인 경우 대신 `델리게이팅필터프록시레지스트레이션빈(DelegatingFilterProxyRegistrationBean)` 사용을 고려하자.


#### 서블릿 컨텍스트 초기화(Servlet Context Initialization)
임베디드 서블릿 컨테이너는 `jakarta.servlet.ServletContainerInitializer` 인터페이스나 스프링의 `org.springframework.web.WebApplicationInitializer` 인터페이스를 직접 실행하지 않는다. 이는 war 실행중 서드 파티 라이브러리가 스프링 부트 애플리케이션을 손상시킬 수 있는 위험을 줄이기 위한 의도적인 설계된 결정이다.

스프링 부트 애플리케이션에서 서블릿 컨텍스트 초기화를 수행해야 하는 경우 `org.springframework.boot.web.servlet.ServletContextInitializer` 인터페이스를 구현하는 빈을 등록해야 한다. `onStartup` 메소드는 `서블릿컨텍스트(ServletContext)`에 대한 접근을 제공하며 필요한 경우 기존 `웹애플리케이션이니셜라이저(WebApplicationInitializer)`에 대한 어댑터로 쉽게 사용할 수 있다.


##### 서블릿, 필터 및 리스너 스캐닝(Scanning for Servlets, Filters, and listeners)
임베디드 컨테이너를 사용할 때 `@ServletComponentScan`을 사용하면 `@WebServlet`, `@WebFilter` 및 `@WebListener` 어노테이션이 달린 클래스의 자동 등록을 활성화할 수 있다.

{: .note }
`@ServletComponentScan`은 컨테이너의 임베디드 검색 메커니즘(built-in discovery mechanisms)이 대신 사용되는 독립형 컨테이너에서는 효과가 없다.


#### 서블릿웹서버애플리케이션컨텍스트(The ServletWebServerApplicationContext)
내부적으로 스프링 부트는 임베디드 서블릿 컨테이너 지원을 위해 다른 타입의 `애플리케이션컨텍스트(ApplicationContext)`를 사용한다. `서블릿웹서버애플리케이션컨텍스트(ServletWebServerApplicationContext)`는 싱글 `서블릿웹서버팩토리(ServletWebServerFactory)` 빈을 검색하여 자체적으로 부트스트랩하는 특별한 타입의 `웹애플리케이션컨텍스트(WebApplicationContext)`이다. 일반적으로 `톰캣서블릿웹서버팩토리(TomcatServletWebServerFactory)`, `제티서블릿웹서버팩토리(JettyServletWebServerFactory)` 또는 `언더토우서블릿웹서버팩토리(UndertowServletWebServerFactory)`가 자동 구성된다.

{: .note}
일반적으로 이러한 구현 클래스를 알 필요는 없다. 대부분의 애플리케이션은 자동으로 구성되며 적절한 `애플리케이션컨텍스트(ApplicationContext)` 및 `서블릿웹서버팩토리(ServletWebServerFactory)`가 생성된다.

임베디드 컨테이너에서 `서블릿컨텍스트(ServletContext)`는 애플리케이션 컨텍스트 초기화 중에 발생하는 서버 시작의 일부로 설정된다. 이 때문에 `애플리케이션컨텍스트(ApplicationContext)`의 빈은 `서블릿컨텍스트(ServletContext)`로 안정적으로 초기화될 수 없다. 이 문제를 해결하는 한 가지 방법은 `애플리케이션컨텍스트(ApplicationContext)`를 빈의 의존성으로 주입하고 필요할 때만 `서블릿컨텍스트(ServletContext)`에 접근하는 것이다. 또 다른 방법은 서버가 시작된 후 콜백을 사용하는 것이다. 이는 다음과 같이 `애플리케이션스타디드이벤트(ApplicationStartedEvent)`를 수신하는 `애플리케이션리스너(ApplicationListener)`를 사용하여 수행할 수 있다.

```java
import jakarta.servlet.ServletContext;
import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationListener;
import org.springframework.web.context.WebApplicationContext;

public class MyDemoBean implements ApplicationListener<ApplicationStartedEvent> {
    
    private ServletContext servletContext;

    @Override
    public void onApplicationEvent(ApplicationStartedEvent event) {
        ApplicationContext applicationContext = event.getApplicationContext();
        this.servletContext = ((WebApplicationContext) applicationContext).getServletContext();
    } 
}
```

#### 임베디드 서블릿 컨테이너 커스텀(Customizing Embedded Servlet Containers)
공통 서블릿 컨테이너 설정은 스프링 환경 프로퍼티를 사용하여 구성할 수 있다. 일반적으로 `application.properties` 또는 `application.yaml` 파일에서 프로퍼티스를 정의한다.

일반적인 서버 설정에는 다음 내용이 포함된다.
- 네트워크 설정: 들어오는 HTTP 요청(`server.port`)에 대한 수신 포트, `server.address`에 바인드할 인터페이스 주소 등.
- 세션 설정: 세션 지속 여부(`server.servlet.session.pertant`), 세션 시간 초과(`server.servlet.session.timeout`), 세션 데이터 위치(`server.servlet.session.store-dir`) 및 세션 쿠키 구성(`server.servlet.session.cookie.*`).
- 에러 관리: 오류 페이지(server.error.path)의 위치 등.
- SSL
- HTTP compression

스프링 부트는 가능한 한 공통 설정 노출하기를 시도하지만 이것이 항상 가능한 것은 아니다. 이러한 경우 전용 네임스페이스(dedicated namespaces)는 서버별 커스텀을 제공한다(`server.tomcat` 및 `server.undertow` 참고). 예를 들어, 임베디드 서블릿 컨테이너의 특정 기능을 사용하여 접근 로그를 구성할 수 있다.

{: .note}
전체 목록은 서버프로퍼티스(ServerProperties) 클래스를 참고하자.


##### SameSite 쿠키(SameSite Cookies)
SameSite 쿠키 애트리뷰트는 웹 브라우저에서 교차 사이트 요청(cross-site requests)에 쿠키 제출 여부 제어하는 ​​데 사용될 수 있다. 이 애트리뷰트는 애트리뷰트가 누락되었을 때 사용되는 기본값을 변경하기 시작한 최신 웹 브라우저와 특히 관련이 있다.

세션 쿠키의 SameSite 애트리뷰트를 변경하려면, `server.servlet.session.cookie.same-site` 프로퍼티을 사용할 수 있다. 이 프로퍼티는 자동 구성된 톰캣, 제티 및 언더토우 서버에서 지원된다. 또한 스프링 세션 서블릿 기반 `세션리포지터리(SessionRepository)` 빈을 구성하는 데에도 사용된다.

예를 들어 세션 쿠키에 SameSite 애트리뷰트가 `None`이 되도록 하려면 `application.properties` 또는 `application.yaml` 파일에 다음을 추가할 수 있다.

`프로퍼티스(Properties)`
```
server.servlet.session.cookie.same-site=none
```

`Yaml`
```yaml
server:
  servlet:
    session:
      cookie:
        same-site: "none"
```

`Http서블릿리스폰스(HttpServletResponse)`에 추가된 다른 쿠키의 SameSite 애트리뷰트를 변경하려면 `쿠키세임사이트서플라이어(CookieSameSiteSupplier)`를 사용할 수 있다. `쿠키세임사이트서플라이어(CookieSameSiteSupplier)`에는 쿠키가 전달되며 SameSite 값 또는 null을 반환할 수 있다.

특정 쿠키를 신속하게 일치시키는 데 사용할 수 있는 다양한 편의 팩토리 및 필터 메소드가 있다. 예를 들어, 다음 빈을 추가하면 정규식 `myapp.*`와 일치하는 이름을 가진 모든 쿠키에 대해 Lax의 SameSite가 자동으로 적용된다.

`자바`
```java
import org.springframework.boot.web.servlet.server.CookieSameSiteSupplier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
public class MySameSiteConfiguration {
    @Bean
    public CookieSameSiteSupplier applicationCookieSameSiteSupplier() {
        return CookieSameSiteSupplier.ofLax().whenHasNameMatching("myapp.*");
    }
}
```

`코틀린`
```kotlin
import org.springframework.boot.web.servlet.server.CookieSameSiteSupplier
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration(proxyBeanMethods = false)
class MySameSiteConfiguration {
    @Bean
    fun applicationCookieSameSiteSupplier(): CookieSameSiteSupplier {
        return CookieSameSiteSupplier.ofLax().whenHasNameMatching("myapp.*")
    }
}
```


##### 프로그래밍 방식의 커스텀(Programmatic Customization)
임베디드 서블릿 컨테이너를 프로그래밍 방식으로 구성해야 하는 경우 `웹서버팩토리커스터마이저(WebServerFactoryCustomizer)` 인터페이스를 구현하는 스프링 빈을 등록할 수 있다. `웹서버팩토리커스터마이저(WebServerFactoryCustomizer)`는 다양한 커스텀 설정 방법을 포함하는 컨`피규러블서블릿웹서버팩토리(ConfigurableServletWebServerFactory)`에 대한 접근를 제공한다. 다음 예에서는 프로그래밍 방식으로 포트를 설정하는 방법을 보여준다.

`자바`
```java
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.stereotype.Component;

@Component
public class MyWebServerFactoryCustomizer implements
WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {
    @Override
    public void customize(ConfigurableServletWebServerFactory server) {
        server.setPort(9000);
    }
}
```

`코틀린`
```kotlin
import org.springframework.boot.web.server.WebServerFactoryCustomizer
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory
import org.springframework.stereotype.Component

@Component
class MyWebServerFactoryCustomizer :
WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {
    override fun customize(server: ConfigurableServletWebServerFactory) {
        server.setPort(9000)
    } 
}
```
`톰캣서블릿웹서버팩토리(TomcatServletWebServerFactory)`, `제티서블릿웹서버팩토리(JettyServletWebServerFactory)` 및 `언더토우서블릿웹서버팩토리(UndertowServletWebServerFactory)`는 각각 톰캣, 제티 및 언더토우에 대한 추가 커스텀 설정 방법이 있는 `컨피규러블서블릿웹서버팩토리(ConfigurableServletWebServerFactory)` 전용 변형이다. 다음 예에서는 톰캣 관련 구성 옵션에 대한 접근을 제공하는 `톰캣서블릿웹서서팩토리(TomcatServletWebServerFactory)`를 커스텀하는 방법을 보여준다.

`자바`
```java
import java.time.Duration;
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.stereotype.Component;

@Component
public class MyTomcatWebServerFactoryCustomizer implements
WebServerFactoryCustomizer<TomcatServletWebServerFactory> {
    @Override
    public void customize(TomcatServletWebServerFactory server) {
        server.addConnectorCustomizers((connector) -> connector.setAsyncTimeout(Duration.ofSeconds(20).toMillis()));
    } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory
import org.springframework.boot.web.server.WebServerFactoryCustomizer
import org.springframework.stereotype.Component
import java.time.Duration

@Component
class MyTomcatWebServerFactoryCustomizer : WebServerFactoryCustomizer<TomcatServletWebServerFactory> {
    override fun customize(server: TomcatServletWebServerFactory) {
        server.addConnectorCustomizers({ connector -> connector.asyncTimeout = Duration.ofSeconds(20).toMillis() })
    }
}
```


##### ConfigurableServletWebServerFactory를 직접 커스텀하기(Customizing ConfigurableServletWebServerFactory Directly)
`서블릿웹서버팩토리(ServletWebServerFactory)`에서 확장해야 하는 고급 사례의 경우 이러한 타입의 빈을 직접 노출할 수 있다.

다양한 구성 옵션에 대한 Setter가 제공된다. 좀 더 색다른 작업을 수행해야 하는 경우를 대비해 여러 보호(protected) 메서드 "후크(hook)"도 제공된다. 자세한 내용은 [소스 코드 문서](https://docs.spring.io/spring-boot/docs/3.1.1/api/org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html)를 참고하자.

{: .note}
자동 구성된 커스텀 프로그램은 커스텀 팩토리에 계속 적용되므로, 해당 옵션은 신중하게 사용하자.


#### JSP 제한 사항(JSP Limitations)
임베디드 서블릿 컨테이너를 사용하고 실행 가능한 압축파일로 패키지된 스프링 부트 애플리케이션을 실행할 때 JSP 지원에 몇 가지 제한 사항이 있다.
- 제티와 톰캣을 사용할 경우 war 패키징을 사용하면 작동한다. 실행 가능한 war는 java -jar로 실행될 때 작동하며 모든 표준 컨테이너에 배포할 수도 있다. 실행 가능한 jar를 사용할 때는 JSP가 지원되지 않다.
- 언더토우(Undertow)는 JSP를 지원하지 않는다.
- 커스텀 error.jsp 페이지를 생성해도 오류 처리를 위한 기본 뷰가 오버라이드되지 않는다. 대신 커스텀 오류 페이지를 사용해야 한다.


## 8.2. 리액티브 웹 애플리케이션(Reactive Web Applications)
스프링 부트는 스프링 웹플럭스에 대한 자동 구성(auto-configuration)을 제공하여 리액티브 웹 애플리케이션 개발을 단순화한다.


### 8.2.1. 스프링 웹플럭스 프레임워크(The “Spring WebFlux Framework”)
스프링 웹플럭스(Spring WebFlux)는 스프링 프임워 5.0에 도입된 새로운 리액티브 웹 프레임워크이다. 스프링 MVC와 달리, 서블릿 API가 필요하지 않고, 완전히 비동기적이고, 논블락킹이며 리액터(Reactor) 프로젝트를 통해 리액티브 스림(Reactive Streams) 사양을 구현한다.

스프링 웹플럭스(Spring WebFlux)는 함수형(functional) 기반과 어노테이션 기반이라는 두 가지 형태로 제공된다. 다음 예제와 같이 어노테이션 기반 모델은 스프링 MVC 모델과 매우 유사하다.

```java
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/users")
public class MyRestController {
    private final UserRepository userRepository;
    private final CustomerRepository customerRepository;
    public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) {
        this.userRepository = userRepository;
        this.customerRepository = customerRepository;
    }

    @GetMapping("/{userId}")
    public Mono<User> getUser(@PathVariable Long userId) {
        return this.userRepository.findById(userId);
    }

    @GetMapping("/{userId}/customers")
    public Flux<Customer> getUserCustomers(@PathVariable Long userId) {
        return this.userRepository.findById(userId).flatMapMany(this.customerRepository::findByUser);
    }

    @DeleteMapping("/{userId}")
    public Mono<Void> deleteUser(@PathVariable Long userId) {
        return this.userRepository.deleteById(userId);
    }
}
```

```kotlin
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@RestController
@RequestMapping("/users")
class MyRestController(private val userRepository: UserRepository, private val customerRepository: CustomerRepository) {
    @GetMapping("/{userId}")
    fun getUser(@PathVariable userId: Long): Mono<User?> {
        return userRepository.findById(userId)
    }

    @GetMapping("/{userId}/customers")
    fun getUserCustomers(@PathVariable userId: Long): Flux<Customer> {
        return userRepository.findById(userId).flatMapMany { user: User? ->
            customerRepository.findByUser(user)
        } 
    }

    @DeleteMapping("/{userId}")
    fun deleteUser(@PathVariable userId: Long): Mono<Void> {
        return userRepository.deleteById(userId)
    }
}
```

함수형(functional)의 변형인 "WebFlux.fn"은 다음 예와 같이 라우팅 구성을 요청의 실제 처리와 분리한다.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.server.RequestPredicate;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.ServerResponse;
import static org.springframework.web.reactive.function.server.RequestPredicates.accept;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;

@Configuration(proxyBeanMethods = false)
public class MyRoutingConfiguration {
    private static final RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);

    @Bean
    public RouterFunction<ServerResponse> monoRouterFunction(MyUserHandler userHandler) {
        return route()
                .GET("/{user}", ACCEPT_JSON, userHandler::getUser)
                .GET("/{user}/customers", ACCEPT_JSON, userHandler::getUserCustomers)
                .DELETE("/{user}", ACCEPT_JSON, userHandler::deleteUser)
                .build();
    } 
}
```

```kotlin
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.MediaType
import org.springframework.web.reactive.function.server.RequestPredicates.DELETE
import org.springframework.web.reactive.function.server.RequestPredicates.GET
import org.springframework.web.reactive.function.server.RequestPredicates.accept
import org.springframework.web.reactive.function.server.RouterFunction
import org.springframework.web.reactive.function.server.RouterFunctions
import org.springframework.web.reactive.function.server.ServerResponse

@Configuration(proxyBeanMethods = false)
class MyRoutingConfiguration {
    @Bean
    fun monoRouterFunction(userHandler: MyUserHandler): RouterFunction<ServerResponse> {
        return RouterFunctions.route(
            GET("/{user}").and(ACCEPT_JSON), userHandler::getUser).andRoute(
            GET("/{user}/customers").and(ACCEPT_JSON), userHandler::getUserCustomers).andRoute(
            DELETE("/{user}").and(ACCEPT_JSON), userHandler::deleteUser)
    }
    
    companion object {
        private val ACCEPT_JSON = accept(MediaType.APPLICATION_JSON)
    } 
}
```

```java
import reactor.core.publisher.Mono;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;

@Component
public class MyUserHandler {
    public Mono<ServerResponse> getUser(ServerRequest request) {
        ...
    }

    public Mono<ServerResponse> getUserCustomers(ServerRequest request) {
        ...
    }

    public Mono<ServerResponse> deleteUser(ServerRequest request) {
        ...
    } 
}
```

```kotlin
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse
import reactor.core.publisher.Mono

@Component
class MyUserHandler {
    fun getUser(request: ServerRequest?): Mono<ServerResponse> {
        return ServerResponse.ok().build()
    }

    fun getUserCustomers(request: ServerRequest?): Mono<ServerResponse> {
        return ServerResponse.ok().build()
    }

    fun deleteUser(request: ServerRequest?): Mono<ServerResponse> {
        return ServerResponse.ok().build()
    } 
}
```
웹플럭스는 스프링 프레임워크의 일부이며 자세한 내용은 해당 레퍼런스 문서에서 확인할 수 있다.

{: .note}
라우터 정의를 모듈화하기 위해 원하는 만큼 라우터펑션(RouterFunction) 빈을 정의할 수 있다. 우선순위를 적용해야 하는 경우 빈의 순위를 정할 수 있다.

시작하려면, 애플리케이션에 `spring-boot-starter-webflux` 모듈을 추가하자.

{: .note}
애플리케이션에 `spring-boot-starter-web` 및 `spring-boot-starter-webflux` 모듈을 모두 추가하면 웹플럭스가 아닌 스프링 부트가 스프링 MVC를 자동 구성하게 된다. 많은 스프링 개발자가 리액티브 웹클라이언트(WebClient)를 사용하기 위해 스프링 MVC 애플리케이션에 `spring-boot-starter-webflux`를 추가하기 때문에 이렇게 동작을 선택했다. 선택한 애플리케이션 타입을 `SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)`으로 설정하여 선택을 강제할 수 있다.


#### 스프링 웹플럭스 자동 구성(Spring WebFlux Auto-configuration)
스프링 부트는 대부분의 애플리케이션에서 잘 작동하는 스프링 웹플럭스에 대한 자동 구성을 제공한다.

자동 구성은 스프링의 기본값 위에 다음 기능을 추가한다.
- `Http메세지리더(HttpMessageReader)` 및 `Http메세지라이터(HttpMessageWriter)` 인스턴스에 대한 코덱(codec) 구성(이 문서의 뒷부분에서 설명)
- WebJars 지원을 포함하여 스태틱 리소스 제공 지원(이 문서 뒷부분에서 설명)

스프링 부트 웹플럭스 기능을 유지하고 추가 웹플럭스 구성을 추가하려는 경우 `@EnableWebFlux` 없이 웹플럭스컨피규어러(WebFluxConfigurer) 타입의 `@Configuration` 클래스를 추가할 수 있다.

스프링 웹플럭스를 완전히 제어하려면 `@EnableWebFlux` 어노테이션이 달린 고유한 `@Configuration`을 추가할 수 있다.


#### HttpMessageReaders 및 HttpMessageWriters가 포함된 HTTP 코덱(HTTP Codecs with HttpMessageReaders and HttpMessageWriters)
스프링 웹플럭스는 `Http메세지리더(HttpMessageReader)` 및 `Http메세지라이터(HttpMessageWriter)` 인터페이스를 사용하여 HTTP 요청과 응답을 변환한다. 클래스패스에서 사용 가능한 라이브러리를 확인하여 적절한 기본값을 갖도록 코덱컨피규어러(CodecConfigurer)로 구성된다.

스프링 부트는 코덱인 `spring.codec.*`에 대한 전용 구성 프로퍼티스를 제공한다. 또한 `코덱커스터마이저(CodecCustomizer)` 인스턴스를 사용하여 커스텀을 적용한다. 예를 들어 `spring.jackson.*` 구성 키는 잭슨(Jackson) 코덱에 적용된다.

코덱을 추가하거나 커스텀해야 하는 경우, 다음 예와 같이 커스텀 코덱커스터마이저(CodecCustomizer) 컴포넌트를 생성할 수 있다.

```java
import org.springframework.boot.web.codec.CodecCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.codec.ServerSentEventHttpMessageReader;

@Configuration(proxyBeanMethods = false)
public class MyCodecsConfiguration {
    @Bean
    public CodecCustomizer myCodecCustomizer() {
        return (configurer) -> {
            configurer.registerDefaults(false);
            configurer.customCodecs().register(new ServerSentEventHttpMessageReader());
            // ...
        }; 
    }
}
```

```kotlin
import org.springframework.boot.web.codec.CodecCustomizer
import org.springframework.context.annotation.Bean
import org.springframework.http.codec.CodecConfigurer
import org.springframework.http.codec.ServerSentEventHttpMessageReader
class MyCodecsConfiguration {
    @Bean
    fun myCodecCustomizer(): CodecCustomizer {
        return CodecCustomizer { configurer: CodecConfigurer ->
            configurer.registerDefaults(false)
            configurer.customCodecs().register(ServerSentEventHttpMessageReader())
        } 
    }
}
```

부트의 커스텀 JSON 시리얼라이저(serializer) 및 디시리얼라이저(deserializer)를 활용할 수도 있다


#### 정적 콘텐츠(Static Content)
기본적으로 스프링 부트는 클래스패스에 있는 `/static`(또는 `/public`, `/resources` 또는 `/META-INF/resources`)이라는 디렉터리의 정적 콘텐츠를 제공한다. 이는 스프링 웹플럭스의 `리소스웹핸들러(ResourceWebHandler)`를 사용하므로 사용자는 자체 `웹플럭스컨피규어러(WebFluxConfigurer)`를 추가하고 `addResourceHandlers` 메서드를 오버라이드하여 해당 동작을 수정할 수 있다.

기본적으로 리소스는 `/**`에 매핑되지만 `spring.webflux.static-path-pattern` 프로퍼티을 설정하여 조정할 수 있다. 예를 들어 모든 리소스를 `/resources/**`에 재배치하는 방법은 다음과 같다.

`프로퍼티스(Properties)`
```
spring.webflux.static-path-pattern=/resources/**
```

`Yaml`
```yaml
spring:
  webflux:
    static-path-pattern: "/resources/**"
```

`spring.web.resources.static-location`을 사용하여 정적 리소스 위치를 커스텀할 수도 있다. 이렇게 하면 기본값이 디렉터리 위치로 대체된다. 그렇게 하면 기본 시작 페이지 감지가 커스텀 위치로 전환된다. 따라서 시작할 때 위치에 `index.html`이 있으면 해당 위치가 애플리케이션의 홈 페이지다.

앞서 나열된 "표준(“standard”)" 정적 리소스 위치 외에도 Webjars 콘텐츠에 대한 특별한 경우가 만들어졌다. 기본적으로 `/webjars/**`에 패스가 있는 모든 리소스는 Webjars 형식으로 패키지된 경우 jar 파일에서 제공된다. 패스는 `spring.webflux.webjars-path-pattern` 프로퍼티로 커스텀할 수 있다.

{: .note}
스트링 웹플럭스 애플리케이션은 서블릿 API에 엄격하게 의존하지 않으므로 war 파일로 배포할 수 없으며 `src/main/webapp` 디렉터리를 사용하지 않는다.


#### 웰컴 페이지(Welcome Page)
스프링 부트는 정적 및 템플릿 시작 페이지를 모두 지원한다. 먼저 구성된 정적 콘텐츠 위치에서 `index.html` 파일을 찾는다. 찾을 수 없으면 인덱스 템플릿을 찾는다. 둘 중 하나가 발견되면 자동으로 애플리케이션의 시작 페이지로 사용된다.


#### 템플릿 엔진(Template Engines)
REST 웹 서비스뿐만 아니라 스프링 웹플럭스를 사용하여 동적 HTML 콘텐츠를 제공할 수도 있다. 스프링 웹플럭스는 Thymeleaf, FreeMarker 및 Mustache를 포함한 다양한 템플릿 기술을 지원한다.

스프링 부트에는 다음 템플릿 엔진에 대한 자동 구성 지원이 포함되어 있다.
- FreeMarker 
- Thymeleaf
- Mustache

기본 구성으로 이러한 템플릿 엔진 중 하나를 사용하면 템플릿이 `src/main/resources/templates`에서 자동으로 선택된다.


#### 에러 핸들링(Error Handling)
스프링 부트는 모든 오류를 합리적인 방식으로 처리하는 웹익셉션핸들러(WebExceptionHandler)를 제공한다. 처리 순서에서 위치는 마지막으로 웹플럭스에서 제공하는 핸들러 바로 앞이다. 머신 클라이언트의 경우 오류 세부정보, HTTP 상태 및 예외 메시지가 포함된 JSON 응답을 생성한다. 브라우저 클라이언트의 경우 동일한 데이터를 HTML 타입으로 렌더링하는 "whitelabel" 오류 처리기가 있다. 오류를 표시하기 위해 자체 HTML 템플릿을 제공할 수도 있다(다음 섹션 참조).

스프링 부트에서 오류 처리를 직접 커스텀하기 전에 스프링 웹플럭스에서 RFC 7807 문제 세부 정보 지원을 활용할 수 있다. 스프링 웹플럭스는 다음과 같이 `application/problem+json `미디어 타입을 사용하여 커스텀 오류 메시지를 생성할 수 있다.

```
{
    "type": "https://example.org/problems/unknown-project",
    "title": "Unknown project",
    "status": 404,
    "detail": "No project found for id 'spring-unknown'",
    "instance": "/projects/spring-unknown"
}
```

이 지원은 `spring.webflux.problemdetails.enabled`를 true로 설정하여 활성화할 수 있다.

이 기능을 커스텀하는 첫 번째 단계에는 기존 메커니즘을 사용하되 오류 내용을 대체하거나 늘리는 작업이 포함되는 경우가 많다. 이를 위해 에러애트리뷰트(ErrorAttributes) 타입의 빈을 추가할 수 있다.

오류 처리 동작을 변경하려면 에러웹익셉션핸들러(ErrorWebExceptionHandler)를 구현하고 해당 타입의 빈 정의를 등록할 수 있다. 에러웹익셉션핸들라(ErrorWebExceptionHandler)는 매우 낮은 레벨이기 때문에 스프링 부트는 다음 예제와 같이 웹플럭스 기능적 방식으로 오류를 처리할 수 있도록 편리한 앱스트랙트에러웹익셥션핸들러(AbstractErrorWebExceptionHandler)도 제공한니다.

```java
import reactor.core.publisher.Mono;
import org.springframework.boot.autoconfigure.web.WebProperties.Resources;
import org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler;
import org.springframework.boot.web.reactive.error.ErrorAttributes;
import org.springframework.context.ApplicationContext;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.RouterFunctions;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import org.springframework.web.reactive.function.server.ServerResponse.BodyBuilder;

@Component
public class MyErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {
    public MyErrorWebExceptionHandler(ErrorAttributes errorAttributes, Resources resources, ApplicationContext applicationContext) {
        super(errorAttributes, resources, applicationContext);
    }
    
    @Override
    protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {
        return RouterFunctions.route(this::acceptsXml, this::handleErrorAsXml);
    }

    private boolean acceptsXml(ServerRequest request) {
        return request.headers().accept().contains(MediaType.APPLICATION_XML);
    }

    public Mono<ServerResponse> handleErrorAsXml(ServerRequest request) {
        BodyBuilder builder = ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR);
        // ... additional builder calls
        return builder.build();
    } 
}
```

```kotlin
import org.springframework.boot.autoconfigure.web.WebProperties
import org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler
import org.springframework.boot.web.reactive.error.ErrorAttributes
import org.springframework.context.ApplicationContext
import org.springframework.http.HttpStatus
import org.springframework.http.MediaType
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.RouterFunction
import org.springframework.web.reactive.function.server.RouterFunctions
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse
import reactor.core.publisher.Mono

@Component
class MyErrorWebExceptionHandler(
    errorAttributes: ErrorAttributes?,
    resources: WebProperties.Resources?, 
    applicationContext: ApplicationContext?
) : AbstractErrorWebExceptionHandler(errorAttributes, resources, applicationContext) {
    
    override fun getRoutingFunction(errorAttributes: ErrorAttributes): RouterFunction<ServerResponse> {
        return RouterFunctions.route(this::acceptsXml, this::handleErrorAsXml)
    }

    private fun acceptsXml(request: ServerRequest): Boolean {
        return request.headers().accept().contains(MediaType.APPLICATION_XML)
    }
    
    fun handleErrorAsXml(request: ServerRequest?): Mono<ServerResponse> {
        val builder = ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR)
        // ... additional builder calls
        return builder.build()
    } 
}
```
보다 완전한 그림을 위해 `디폴트에러웹익셥션핸들러(DefaultErrorWebExceptionHandler)`를 직접 하위 클래스로 분류하고 특정 메서드를 오버라이드할 수도 있다.

컨트롤러 또는 핸들러 기능 레벨에서 처리된 오류가 메트릭 인프라에 기록되지 않는 경우도 있다. 애플리케이션은 처리된 예외를 요청 애트리뷰트로 설정하여 이러한 예외가 요청 메트릭과 함께 기록되도록 할 수 있다.

`자바`
```java
import org.springframework.boot.web.reactive.error.ErrorAttributes;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.reactive.result.view.Rendering;
import org.springframework.web.server.ServerWebExchange;

@Controller
public class MyExceptionHandlingController {
    @GetMapping("/profile")
    public Rendering userProfile() {
        // ...
        throw new IllegalStateException();
    }

    @ExceptionHandler(IllegalStateException.class)
    public Rendering handleIllegalState(ServerWebExchange exchange, IllegalStateException exc) {
        exchange.getAttributes().putIfAbsent(ErrorAttributes.ERROR_ATTRIBUTE, exc);
        return Rendering.view("errorView").modelAttribute("message", exc.getMessage()).build();
    } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.web.reactive.error.ErrorAttributes
import org.springframework.stereotype.Controller
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.reactive.result.view.Rendering
import org.springframework.web.server.ServerWebExchange

@Controller
class MyExceptionHandlingController {
    @GetMapping("/profile")
    fun userProfile(): Rendering {
        // ...
        throw IllegalStateException()
    }

    @ExceptionHandler(IllegalStateException::class)
    fun handleIllegalState(exchange: ServerWebExchange, exc: IllegalStateException): Rendering {
        exchange.attributes.putIfAbsent(ErrorAttributes.ERROR_ATTRIBUTE, exc)
        return Rendering.view("errorView").modelAttribute("message", exc.message ?: "").build()
    } 
}
```


#### 커스텀 에러 페이지(Custom Error Pages)
주어진 상태 코드에 대한 커스텀 HTML 오류 페이지를 표시하려는 경우 예를 들어 `/error` 디렉토리에 파일을 추가하여 `error/*`에서 해결되는 보기를 추가할 수 있다. 오류 페이지는 정적 HTML(즉, 정적 리소스 디렉터리에 추가됨)이거나 템플릿을 사용하여 구축될 수 있다. 파일명은 정확한 상태 코드, 상태 코드 시리즈 마스크 또는 일치하는 항목이 없는 경우 기본값에 대한 오류여야 한다. 기본 오류 보기에 대한 경로는 `error/error`인 반면 스프링 MVC에서는 기본 오류 보기는 error이다.

예를 들어 404를 정적 HTML 파일에 매핑하려면 디렉터리 구조는 다음과 같다.
```
src/
  +- main/
       +- java/
       |   + <source code>
       +- resources/
           +- public/
               +- error/
               |   +- 404.html
               +- <other public assets>
```

머스태치(Mustache) 템플릿을 사용하여 모든 5xx 오류를 매핑하려면 디렉터리 구조는 다음과 같다.

```
src/
   +- main/
       +- java/
       |   + <source code>
       +- resources/
           +- templates/
               +- error/
               |   +- 5xx.mustache
               +- <other templates>

```


#### 웹 필터(Web Filters)
웹 플러스는 HTTP 요청-응답 교환을 필터링하기 위해 구현할 수 있는 웹필터(WebFilter) 인터페이스를 제공한다. 애플리케이션 컨텍스트에서 발견된 웹필터(WebFilter) 빈은 자동으로 각 교환을 필터링하는 데 사용된다.

필터의 순서가 중요한 경우 `Ordered`를 구현하거나 `@Order`로 어노테이션을 달 수 있습니다. 스프링 부트 자동 구성을 통해 웹 필터를 구성할 수 있다. 그렇게 하는 경우 다음 표에 표시된 순서가 사용된다.

|웹필터|순서|
|---|---|
|`ServerHttpObservationFilter` (마이크로미터 옵저버블리티(Observability))|`Ordered.HIGHEST_PRECEDENCE + 1`|
|`WebFilterChainProxy` (스프링 시큐리티)|`-100`|
|`HttpExchangesWebFilter`|`Ordered.LOWEST_PRECEDENCE - 10`|


#### 8.2.2 임베디드 리액티브 서버 지원(Embedded Reactive Server Support)
스프링 부트에는 리액터 네티(Reactor Netty), 톰캣(Tomcat), 제티(Jetty) 및 언더토우(Undertow와) 같은 임베디드 리액티브 웹 서버에 대한 지원이 포함되어 있다. 대부분의 개발자는 완전히 구성된 인스턴스를 얻기 위해 적절한 "스타터"를 사용한다. 기본적으로 포함된 서버는 포트 8080에서 HTTP 요청을 수신한다.


#### 8.2.3. 리액티브 서버 리소스 컨피규레이션(Reactive Server Resources Configuration)
리액터 네티 또는 제티 서버를 자동 구성할 때 스프링 부트는 서버 인스턴스에 HTTP 리소스를 제공하는 특정 빈(리액터리소스팩토리(ReactorResourceFactory) 또는 제티리소스팩토리(JettyResourceFactory))을 생성한다.

기본적으로, 이러한 리소스는 다음과 같은 경우 최적의 성능을 위해 리액터 네티(Reactor Netty) 및 제티(Jetty) 클라이언트와도 공유된다.
- 서버와 클라이언트에 동일한 기술이 사용된다.
- 클라이언트 인스턴스는 스프링 부트에 의해 자동 구성된 `WebClient.Builder` 빈을 사용하여 구축한다.

개발자는 커스텀 리액터리소스팩토리(ReactorResourceFactory) 또는 제티리소스팩토리(JettyResourceFactory) 빈을 제공하여 제티 및 리액터 네티에 대한 리소스 구성을 오버라이드할 수 있다. 이는 클라이언트와 서버 모두에 적용된다.

웹클라이언트(WebClient) 런타임 절에서 클라이언트측 리소스 구성에 대해 자세히 알아볼 수 있다.


## 8.3. 정상 종료(Graceful Shutdown)
4개의 내장 웹 서버(제티, 리액터 네티, 톰캣 및 언더토우)와 리액티브 및 서블릿 기반 웹 애플리케이션 모두에서 정상 종료(Graceful Shutdown)가 지원된다. 이는 애플리케이션 컨텍스트를 닫는 과정의 일부로 발생하며 스마트라이프사이클(SmartLifecycle) 빈을 중지하는 초기 단계에서 수행된다. 이 처리 중지는 기존 요청의 완료는 허용되지만 새 요청을 허용하지 않으며 유예 기간에 타임아웃을 둔다. 새 요청이 허용되지 않는 정확한 방법은 사용 중인 웹 서버에 따라 다르다. 제티, 리액터 네티 및 톰캣은 네트워크 계층에서 요청 수락을 중지한다. 언더토우는 요청을 수락하지만 서비스 이용 불가(503) 응답으로 즉시 응답한다.

{: .note}
톰캣을 사용한 정상 종료에는 톰캣 9.0.33 이상이 필요하다.

단계적 종료 활성화는 다음 예와 같이 `server.shutdown` 프로퍼티를 구성한다.

`프로퍼티스(Properties)`
```
server.shutdown=graceful
```

`Yaml`
```yaml
server:
  shutdown: "graceful"
```

타임아웃을 구성하려면 다음 예와 같이 `spring.lifecycle.timeout-per-shutdown-phase` 프로퍼티를 구성한다.

`프로퍼티스(Properties)`
```
spring.lifecycle.timeout-per-shutdown-phase=20s
```

`Yaml`
```yaml
spring:
  lifecycle:
    timeout-per-shutdown-phase: "20s"
```

{: .important}
>적절한 SIGTERM 신호를 보내지 않으면 IDE에서 정상 종료를 사용하는 것이 제대로 작동하지 않을 수 있다. 자세한 내용은 IDE 문서를 참고하자.