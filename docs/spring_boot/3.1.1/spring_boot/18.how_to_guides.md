---
layout: default
title: 18. "사용" 가이드("How-to" Guides)
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 18
---

[원문 - How-to Guides](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto)

***

- 18 "사용" 가이드("How-to" Guides)
  - 18.1. 스프링 부트 애플리케이션(Spring Boot Application)
    - 18.1.1. 나만의 FailureAnalyzer 만들기(Create Your Own FailureAnalyzer)
    - 18.1.2. 자동 구성 문제 해결(Troubleshoot Auto-configuration)
    - 18.1.3. 시작하기 전 환경 또는 ApplicationContext 커스텀(Customize the Environment or ApplicationContext Before It Starts)
    - 18.1.4. ApplicationContext 계층 구조 구축(상위 또는 루트 컨텍스트 추가)(Build an ApplicationContext Hierarchy (Adding a Parent or Root Context))
    - 18.1.5. 웹이 아닌 애플리케이션 만들기(Create a Non-web Application)
  - 18.2. 프로퍼티스와 구성(Properties and Configuration)
    - 18.2.1. 빌드 시 자동으로 프로퍼티스 확장(Automatically Expand Properties at Build Time)
      - 메이븐을 사용한 자동 프로퍼티 확장(Automatic Property Expansion Using Maven)
      - 그레이들을 사용한 자동 프로퍼티 확장(Automatic Property Expansion Using Gradle)
    - 18.2.2. SpringApplication 구성 외부화(Externalize the Configuration of SpringApplication)
    - 18.2.3. 애플리케이션의 외부 프로퍼티스 위치 변경(Change the Location of External Properties of an Application)
    - 18.2.4. '짧은' 커맨드라인 아규먼트 사용(Use ‘Short’ Command Line Arguments)
    - 18.2.5. 외부 프로퍼티스에 YAML 사용(Use YAML for External Properties)
    - 18.2.6. 활성 스프링 프로필 설정(Set the Active Spring Profiles)
    - 18.2.7. 기본 프로필명 설정(Set the Default Profile Name)
    - 18.2.8. 환경에 따라 구성 변경(Change Configuration Depending on the Environment)
    - 18.2.9. 외부 프로퍼티스에 대한 빌트인 옵션 살펴보기(Discover Built-in Options for External Properties)
  - 18.3. 임베디드 웹 서버(Embedded Web Servers)
    - 18.3.1. 다른 웹서버 사용(Use Another Web Server)
    - 18.3.2. 웹 서버 비활성화(Disabling the Web Server)
    - 18.3.3. HTTP 포트 변경(Change the HTTP Port)
    - 18.3.4. 할당되지 않은 무작위 HTTP 포트 사용(Use a Random Unassigned HTTP Port)
    - 18.3.5. 런타임 시 HTTP 포트 검색(Discover the HTTP Port at Runtime)
    - 18.3.6. HTTP 응답 압축 활성화(Enable HTTP Response Compression)
    - 18.3.7. SSL 구성(Configure SSL)
    - 18.3.8. HTTP/2 구성(Configure HTTP/2)
      - HTTP/2와 톰캣(HTTP/2 With Tomcat)
      - HTTP/2와 제티(HTTP/2 With Jetty)
      - 리액터 네티와 HTTP/2(HTTP/2 With Reactor Netty)
      - 언더토우와 HTTP/2(HTTP/2 With Undertow)
    - 18.3.9. 웹서버 구성(Configure the Web Server)
    - 18.3.10. 애플리케이션에 서블릿, 필터 또는 리스너 추가(Add a Servlet, Filter, or Listener to an Application)
      - 스프링 빈을 사용하여 서블릿, 필터 또는 리스너 추가(Add a Servlet, Filter, or Listener by Using a Spring Bean)
      - 클래스패스 스캐닝으로 서블릿, 필터 및 리스너 추가(Add Servlets, Filters, and Listeners by Using Classpath Scanning)
    - 18.3.11. 접근 로깅 구성(Configure Access Logging)
    - 18.3.12. 프런트 엔드 프록시 서버 뒤에서 실행(Running Behind a Front-end Proxy Server)
      - 톰캣의 프록시 구성 커스텀(Customize Tomcat’s Proxy Configuration)
    - 18.3.13. 톰캣으로 다중 커넥터 활성화(Enable Multiple Connectors with Tomcat)
    - 18.3.14. 톰캣의 MBean 레지스트리 활성화(Enable Tomcat’s MBean Registry)
    - 18.3.15. 언더토우로 다중 리스너 활성화(Enable Multiple Listeners with Undertow)
    - 18.3.16. @ServerEndpoint를 사용하여 웹소켓 엔드포인트 생성(Create WebSocket Endpoints Using @ServerEndpoint)
  - 18.4. 스프링 MVC(Spring MVC)
    - 18.4.1. JSON REST 서비스 작성(Write a JSON REST Service)
    - 18.4.2. XML REST 서비스 작성(Write an XML REST Service)
    - 18.4.3. Customize the Jackson ObjectMapper
    - 18.4.4. Customize the @ResponseBody Rendering
    - 18.4.5. Handling Multipart File Uploads
    - 18.4.6. Switch Off the Spring MVC DispatcherServlet
    - 18.4.7. Switch off the Default MVC Configuration
    - 18.4.8. Customize ViewResolvers
  - 18.5. Jersey
    - 18.5.1. Secure Jersey endpoints with Spring Security
    - 18.5.2. Use Jersey Alongside Another Web Framework 
  - 18.6. HTTP Clients
    - 18.6.1. Configure RestTemplate to Use a Proxy
    - 18.6.2. Configure the TcpClient used by a Reactor Netty-based WebClient
  - 18.7. Logging
    - 18.7.1. Configure Logback for Logging
      - Configure Logback for File-only Output
    - 18.7.2. Configure Log4j for Logging
      - Use YAML or JSON to Configure Log4j2
      - Use Composite Configuration to Configure Log4j2
  - 18.8. Data Access
    - 18.8.1. Configure a Custom DataSource
    - 18.8.2. Configure Two DataSources
    - 18.8.3. Use Spring Data Repositories
    - 18.8.4. Separate @Entity Definitions from Spring Configuration
    - 18.8.5. Configure JPA Properties
    - 18.8.6. Configure Hibernate Naming Strategy
    - 18.8.7. Configure Hibernate Second-Level Caching
    - 18.8.8. Use Dependency Injection in Hibernate Components
    - 18.8.9. Use a Custom EntityManagerFactory
    - 18.8.10. Using Multiple EntityManagerFactories
    - 18.8.11. Use a Traditional persistence.xml File
    - 18.8.12. Use Spring Data JPA and Mongo Repositories
    - 18.8.13. Customize Spring Data’s Web Support
    - 18.8.14. Expose Spring Data Repositories as REST Endpoint
    - 18.8.15. Configure a Component that is Used by JPA
    - 18.8.16. Configure jOOQ with Two DataSources
  - 18.9. Database Initialization
    - 18.9.1. Initialize a Database Using JPA
    - 18.9.2. Initialize a Database Using Hibernate
    - 18.9.3. Initialize a Database Using Basic SQL Scripts
    - 18.9.4. Initialize a Spring Batch Database
    - 18.9.5. Use a Higher-level Database Migration Tool
      - Execute Flyway Database Migrations on Startup
      - Execute Liquibase Database Migrations on Startup
    - 18.9.6. Depend Upon an Initialized Database
      - Detect a Database Initializer
      - Detect a Bean That Depends On Database Initialization
  - 18.10. NoSQL
    - 18.10.1. Use Jedis Instead of Lettuce
  - 18.11. Messaging
    - 18.11.1. Disable Transacted JMS Session
  - 18.12. Batch Applications
    - 18.12.1. Specifying a Batch Data Source
    - 18.12.2. Running Spring Batch Jobs on Startup
    - 18.12.3. Running From the Command Line
    - 18.12.4. Storing the Job Repository
  - 18.13. Actuator
    - 18.13.1. Change the HTTP Port or Address of the Actuator Endpoints
    - 18.13.2. Customize the ‘whitelabel’ Error Page
    - 18.13.3. Sanitize Sensitive Values
      - Customizing Sanitization
    - 18.13.4. Map Health Indicators to Micrometer Metrics
  - 18.14. Security
    - 18.14.1. Switch off the Spring Boot Security Configuration
    - 18.14.2. Change the UserDetailsService and Add User Accounts
    - 18.14.3. Enable HTTPS When Running behind a Proxy Server
  - 18.15. Hot Swapping
    - 18.15.1. Reload Static Content
    - 18.15.2. Reload Templates without Restarting the Container
      - Thymeleaf Templates
      - FreeMarker Templates
      - Groovy Templates
    - 18.15.3. Fast Application Restarts
    - 18.15.4. Reload Java Classes without Restarting the Container
  - 18.16. Testing
    - 18.16.1. Testing With Spring Security
    - 18.16.2. Structure @Configuration classes for inclusion in slice tests
  - 18.17. Build
    - 18.17.1. Generate Build Information
    - 18.17.2. Generate Git Information
    - 18.17.3. Customize Dependency Versions
    - 18.17.4. Create an Executable JAR with Maven
    - 18.17.5. Use a Spring Boot Application as a Dependency
    - 18.17.6. Extract Specific Libraries When an Executable Jar Runs
    - 18.17.7. Create a Non-executable JAR with Exclusions
    - 18.17.8. Remote Debug a Spring Boot Application Started with Maven
    - 18.17.9. Build an Executable Archive From Ant without Using spring-boot-antlib
  - 18.18. Ahead-of-time processing
    - 18.18.1. Conditions
  - 18.19. Traditional Deployment
    - 18.19.1. Create a Deployable War File
    - 18.19.2. Convert an Existing Application to Spring Boot
    - 18.19.3. Deploying a WAR to WebLogic
  - 18.20. Docker Compose
    - 18.20.1. Customizing the JDBC URL 

***


# 18. "사용" 가이드("How-to" Guides)
이 장에서는 스프링 부트를 사용할 때 자주 발생하는 몇 가지 일반적인 '어떻게 해야 하지...' 질문에 대한 답변을 제공한다. 완전하진 않지만 꽤 많은 부분을 커버하고 있다.

여기서 다루지 않은 특정 문제가 있는 경우 [stackoverflow.com](https://stackoverflow.com/tags/spring-boot)을 확인하여 누군가 이미 답변을 제공했는지 확인할 수 있다. 이곳은 새로운 질문을 하기에도 좋은 곳이다(`spring-boot` 태그를 사용하자).

우리는 또한 이 장을 확장할 수 있게 되어 매우 기쁘다. '사용 방법'을 추가하려면 [풀 리퀘스트](https://github.com/spring-projects/spring-boot/tree/v3.1.1)를 보내보자.


## 18.1. 스프링 부트 애플리케이션(Spring Boot Application)
이 장에는 스프링 부트 애플리케이션과 직접 관련된 토픽이 포함되어 있다.


### 18.1.1. 나만의 FailureAnalyzer 만들기(Create Your Own FailureAnalyzer)
`FailureAnalyzer`는 시작 시 예외를 가로채서 이를 사람이 읽을 수 있는 메시지로 변환하고 `FailureAnalytics`에 래핑하는 훌륭한 방법이다. 스프링 부트는 애플리케이션 컨텍스트 관련 예외, JSR-303 검증 등에 대한 분석기(analyzer)를 제공한다. 자신만의 것을 만들 수도 있다.

`AbstractFailureAnalyzer`는 처리할 예외에 지정된 예외 유형이 있는지 확인하는 `FailureAnalyzer`의 편리한 확장이다. 구현체가 실제로 존재할 때만 예외를 처리할 수 있도록 이를 확장할 수 있다. 어떤 이유로든 예외를 처리할 수 없는 경우 `null`을 반환하여 다른 구현체에서 예외를 처리할 수 있도록 한다.

`FailureAnalyzer` 구현체는 `META-INF/spring.factories`에 등록되어야 한다. 다음 예제에서는 `ProjectConstraintViolationFailureAnalyzer`를 등록한다.

```
org.springframework.boot.diagnostics.FailureAnalyzer=\
com.example.ProjectConstraintViolationFailureAnalyzer
```

{: .note }
`BeanFactory` 또는 `Environment`에 접근해야 하는 경우 FailureAnalyzer는 각각 `BeanFactoryAware` 또는 `EnvironmentAware`를 구현할 수 있다.


### 18.1.2. 자동 구성 문제 해결(Troubleshoot Auto-configuration)
스프링 부트 자동 구성은 "올바른 작업"을 수행하기 위해 최선을 다하지만 때로 작업이 실패하고 이유를 분명하게 확인하기 어려울 수 있다.

모든 스프링 부트 `ApplicationContext`에는 정말 유용한 `ConditionEvaluationReport`가 있다. `DEBUG` 로깅 출력을 활성화하면 이를 볼 수 있다. `spring-boot-actuator`([액추에이터 장 참고](/docs/spring_boot/3.1.1/spring_boot/13.production_ready_features/#13-%ED%94%84%EB%A1%9C%EB%8D%95%EC%85%98-%EC%A4%80%EB%B9%84-%EA%B8%B0%EB%8A%A5production-ready-features))를 사용하는 경우 보고서를 `JSON`으로 렌더링하는 조건 엔드포인트도 있다. 해당 엔드포인트를 사용하여 애플리케이션을 디버깅하고 런타임 시 스프링 부트에 의해 추가된 기능(및 추가되지 않은 기능)을 확인하자.

소스 코드와 자바독을 살펴보면 더 많은 질문에 대한 답을 얻을 수 있다. 코드를 읽을 때 다음 법칙을 기억하자.
- `*AutoConfiguration`이라는 클래스를 찾아 해당 소스를 읽어보자. 어떤 기능을 언제 활성화하는지 알아보려면 `@Conditional*` 어노테이션에 특별한 주의를 기울이자. 커맨드라인에서 `--debug`를 추가하거나 시스템 프로퍼티 `-Ddebug`를 추가하여 앱에서 이루어진 모든 자동 구성 결정에 대한 로그를 콘솔에 가져온다. 액추에이터가 활성화된 실행 중인 애플리케이션에서 동일한 정보를 보려면 `conditions` 엔드포인트(`/actuator/conditions` 또는 이에 상응하는 JMX)를 살펴보자.
- `@ConfigurationProperties`(예: `ServerProperties`)인 클래스를 찾아 거기에서 사용 가능한 외부 구성 옵션을 읽어보자. `@ConfigurationProperties` 어노테이션에는 외부 프로퍼티에 대한 접두사 역할을 하는 이름 애트리뷰트가 있다. 따라서, `ServerProperties`에는 `prefix="server"`가 있고 해당 프로퍼티는 `server.port`, `server.address` 등이다. 액추에이터가 활성화된 실행 중인 애플리케이션에서 `configprops` 엔드포인트를 살펴보자.
- 편리한 방식으로 `Environment`에서 구성 값을 명시적으로 가져오기 위해 `Binder`에서 `bind` 메서드를 사용하는 방법을 찾아보자. 접두사와 함께 사용되는 경우가 많다.
- `Environment`에 직접 바인딩되는 `@Value` 어노테이션을 찾아보자.
- SpEL 표현식에 대한 응답으로 기능을 켜고 끄는 `@ConditionalOnExpression` 어노테이션을 찾아보자. 일반적으로 환경에서 분석된 자리 표시자(placeholder)로 평가한다.


### 18.1.3. 시작하기 전 Environment 또는 ApplicationContext 커스텀(Customize the Environment or ApplicationContext Before It Starts)
`SpringApplication`에는 컨텍스트나 environment에 커스텀을 적용하는 데 사용되는 `ApplicationListener` 및 `ApplicationContextInitializer`가 있다. 스프링 부트는 `META-INF/spring.factories`에서 내부적으로 사용할 수 있도록 이러한 커스텀을 로드한다. 추가 커스텀을 등록하는 방법은 여러 가지가 있다.
- 프로그래밍 방식으로 애플리케이션별 `SpringApplication`을 실행하기 전에 `addListeners` 및 `addInitializers` 메서드를 호출한다.
- 선언적으로, 애플리케이션별 `context.initializer.classes` 또는 `context.listener.classes` 프로퍼티스를 설정한다.
- 선언적으로, 모든 애플리케이션에 대해 `META-INF/spring.factories`를 추가하고 모든 애플리케이션이 라이브러리로 사용하는 jar 파일에 패키징한다.

`SpringApplication`은 몇 가지 특별한 `ApplicationEvent`를 리스너(컨텍스트가 생성되기 전이라도)에 보낸 다음 `ApplicationContext`에 의해 게시된 이벤트에 대한 리스너를 등록한다. 전체 목록은 '스프링 부트 기능' 장의 '[애플리케이션 이벤트 및 리스너](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#717-application-events-and-listeners)'를 참고하자.

`EnvironmentPostProcessor`를 사용하여 애플리케이션 컨텍스트를 새로 고치기 전에 `Environment`을 커스텀하는 것도 가능하다. 다음 예제와 같이 각 구현체는 `META-INF/spring.factories`에 등록되어야 한다.

```
org.springframework.boot.env.EnvironmentPostProcessor=com.example.YourEnvironmentPostProcessor
```

구현 시 임의의 파일을 로드하고 `Environment`에 추가할 수 있다. 다음 예제에서는 클래스패스에서 YAML 구성 파일을 로드한다.

`자바`
```java
import java.io.IOException;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.env.EnvironmentPostProcessor;
import org.springframework.boot.env.YamlPropertySourceLoader;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.util.Assert;

public class MyEnvironmentPostProcessor implements EnvironmentPostProcessor {
  private final YamlPropertySourceLoader loader = new YamlPropertySourceLoader();
  @Override
  public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
    Resource path = new ClassPathResource("com/example/myapp/config.yml");
    PropertySource<?> propertySource = loadYaml(path);
    environment.getPropertySources().addLast(propertySource);
  }

  private PropertySource<?> loadYaml(Resource path) {
    Assert.isTrue(path.exists(), () -> "Resource " + path + " does not exist");
    try {
      return this.loader.load("custom-resource", path).get(0);
    } catch (IOException ex) {
      throw new IllegalStateException("Failed to load yaml configuration from " + path, ex); 
    }
  } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.SpringApplication
import org.springframework.boot.env.EnvironmentPostProcessor
import org.springframework.boot.env.YamlPropertySourceLoader
import org.springframework.core.env.ConfigurableEnvironment
import org.springframework.core.env.PropertySource
import org.springframework.core.io.ClassPathResource
import org.springframework.core.io.Resource
import org.springframework.util.Assert
import java.io.IOException

class MyEnvironmentPostProcessor : EnvironmentPostProcessor {
  private val loader = YamlPropertySourceLoader()

  override fun postProcessEnvironment(environment: ConfigurableEnvironment, application: SpringApplication) {
    val path: Resource = ClassPathResource("com/example/myapp/config.yml")
    val propertySource = loadYaml(path)
    environment.propertySources.addLast(propertySource)
  }

  private fun loadYaml(path: Resource): PropertySource<*> {
    Assert.isTrue(path.exists()) { "Resource $path does not exist" }
    return try {
      loader.load("custom-resource", path)[0]
    } catch (ex: IOException) { 
      throw IllegalStateException("Failed to load yaml configuration from $path", ex) 
    }
  } 
}
```

{: .note }
`Environment`은 스프링 부트가 기본적으로 로드하는 모든 일반적인 프로퍼티 소스로 이미 준비되어 있다. 따라서 `Environment`에서 파일 위치를 얻는 것이 가능하다. 앞의 예제에서는 일반적으로 다른 위치에 정의된 키가 우선순위를 갖도록 리스트의 끝에 커스텀 리소스 프로퍼티 소스를 추가한다. 커스텀 구현체는 다른 순서를 정의할 수 있다.

{: .caution }
`@SpringBootApplication`에서 `@PropertySource`를 사용하는 것이 `Environment`에서 커스텀 리소스를 로드하는 편리한 방법으로 보일 수 있지만 권장하지는 않는다. 이러한 프로퍼티 소스는 애플리케이션 컨텍스트가 새로 고쳐질 때까지 `Environment`에 추가되지 않는다. 새로 고침이 시작되기 전에 읽혀지는 `logging.*` 및 `spring.main.*`과 같은 특정 프로퍼티를 구성하기에는 너무 늦다.


### 18.1.4. ApplicationContext 계층 구조 구축(상위 또는 루트 컨텍스트 추가)(Build an ApplicationContext Hierarchy (Adding a Parent or Root Context))
`ApplicationBuilder` 클래스를 사용하여 상위/하위 `ApplicationContext` 계층을 생성할 수 있다. 자세한 내용은 '스프링 부트 기능' 장의 '[Fluent Builder API](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#715-fluent-builder-api)'를 참고하자.


### 18.1.5. 웹이 아닌 애플리케이션 만들기(Create a Non-web Application)

모든 스프링 애플리케이션이 웹 애플리케이션(또는 웹 서비스)일 필요는 없다. 메인 메서드에서 일부 코드를 실행하고 스프링 애플리케이션을 부트스트랩하여 사용할 인프라를 설정하려는 경우 스프링 부트의 `SpringApplication` 기능을 사용할 수 있다. `SpringApplication`은 웹 애플리케이션 필요 여부에 따라 `ApplicationContext` 클래스를 변경한다. 이를 돕기 위해 가장 먼저 할 수 있는 일은 서버 관련 의존성(예: 서블릿 API)을 클래스패스에서 벗어나게 하는 것이다. 그렇게 할 수 없는 경우(예를 들어 동일한 코드 베이스에서 두 개의 애플리케이션을 실행하는 경우) `SpringApplication` 인스턴스에서 명시적으로 `setWebApplicationType(WebApplicationType.NONE)`을 호출하거나 (자바 API 또는 외부 속성을 통해) `applicationContextClass` 프로퍼티를 설정할 수 있다. 비즈니스 로직으로 실행하려는 애플리케이션 코드는 `CommandLineRunner`로 구현되고 `@Bean` 정의로 컨텍스트에 놓을 수 있다.


## 18.2. 프로퍼티스와 구성(Properties and Configuration)
이 절에는 프로퍼티스와 구성(Configuration)을 설정하고 읽는 방법과 스프링 부트 애플리케이션과의 상호 작용을 다룬다.


### 18.2.1. 빌드 시 자동으로 프로퍼티스 확장(Automatically Expand Properties at Build Time)
프로젝트의 빌드 구성에도 지정된 일부 프로퍼티스를 하드코딩하는 대신 기존 빌드 구성을 사용하여 자동으로 확장할 수 있다. 이는 메이븐과 그레이들 모두 가능하다.


#### 메이븐을 사용한 자동 프로퍼티 확장(Automatic Property Expansion Using Maven)
리소스 필터링을 사용하여 메이븐 프로젝트에서 프로퍼티스를 자동으로 확장할 수 있다. `spring-boot-starter-parent`를 사용하는 경우 다음 예와 같이 `@..@` 자리 표시자(placeholder)를 사용하여 메이븐 '프로젝트 프로퍼티스'를 참고할 수 있다.

`프로퍼티스(Properties)`
```
app.encoding=@project.build.sourceEncoding@
app.java.version=@java.version@
```

`Yaml`
```yaml
app:
  encoding: "@project.build.sourceEncoding@"
  java:
    version: "@java.version@"
```

{: .note}
프로덕션 구성만 해당 방식으로 필터링된다. 즉, `src/test/resources`에는 필터링이 적용되지 않는다.

{: .note}
`addResources` 플래그를 활성화하면 `spring-boot:run` 골(goal)은 핫 리로딩 목적으로 `src/main/resources`를 클래스패스에 직접 추가할 수 있다. 그렇게 하면 리소스 필터링과 이 기능을 우회할 수 있다. 대신 `exec:java` 골(goal)을 사용하거나 플러그인 구성을 커스텀할 수 있다. 자세한 내용은 [플러그인 사용 페이지](https://docs.spring.io/spring-boot/docs/3.1.1/maven-plugin/reference/htmlsingle/#getting-started)를 참고하자.

`starter parent`를 사용하지 않는 경우, `pom.xml`의 `<build/>` 엘리먼트 내에 다음 엘리먼트를 포함해야 한다.

```xml
<resources>
  <resource>
    <directory>src/main/resources</directory>
    <filtering>true</filtering>
  </resource>
</resources>
```

또한 `<plugins/>` 내에 다음 엘리먼트를 포함해야 한다.

```xml
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-resources-plugin</artifactId>
  <version>2.7</version>
  <configuration>
    <delimiters>
      <delimiter>@</delimiter>
    </delimiters>
    <useDefaultDelimiters>false</useDefaultDelimiters>
  </configuration>
</plugin>
```

{: .note}
`useDefaultDelimiters` 프로퍼티는 구성에서 표준 스프링 자리 표시자(예: `${placeholder}`)를 사용하는 경우 중요하다. 해당 프로퍼티가 `false`로 설정되지 않은 경우 빌드에 의해 확장할 수 있다.


#### 그레이들을 사용한 자동 프로퍼티 확장(Automatic Property Expansion Using Gradle)
다음 예와 같이 자바 플러그인의 `processResources` 태스크를 구성하여 그레이들 프로젝트에서 프로퍼티스를 자동으로 확장할 수 있다.

```groovy
tasks.named('processResources') {
  expand(project.properties)
}
```

그런 다음 다음 예제와 같이 자리 표시자를 사용하여 그레이들 프로젝트의 프로퍼티스를 참조할 수 있다.

`프로퍼티스(Properties)`
```
app.name=${name}
app.description=${description}
```

`Yaml`
```yaml
app:
  name: "${name}"
  description: "${description}"
```

{: .note}
그레이들의 `expand` 메소드는 `${..}` 토큰을 변환하는 그루비의 `SimpleTemplateEngine`을 사용한다. `${..}` 스타일은 스프링의 자체 프로퍼티 자리 표시자 메커니즘과 충돌한다. 자동 확장과 함께 스프링 프로퍼티 자리 표시자를 사용하려면 `\${..}`와 같이 스프링 프로퍼티 자리 표시자를 이스케이프 처리하자.


### 18.2.2. SpringApplication 구성 외부화(Externalize the Configuration of SpringApplication)
SpringApplication에는 빈 프로퍼티 세터가 있으므로, 해당 동작을 수정하기 위해 애플리케이션을 생성할 때 자바 API를 사용할 수 있다. 또는 `spring.main.*`에서 프로퍼티스를 설정하여 구성을 외부화할 수 있다. 예를 들어 `application.properties`에는 다음과 같은 설정이 있을 수 있다.

`프로퍼티스(Properties)`
```
spring.main.web-application-type=none
spring.main.banner-mode=off
```

`Yaml`
```yaml
spring:
  main:
    web-application-type: "none"
    banner-mode: "off"
```

그러면 시작 시 스프링 부트 배너가 인쇄되지 않고 애플리케이션이 내장된 웹 서버를 시작하지 않는다.

외부 구성에 정의된 프로퍼티스는 주요 소스를 제외하고 자바 API로 지정된 값을 오버라이드하고 대체한다. 주요(Primary) 소스는 SpringApplication 생성자에 제공되는 소스다.

`자바`
```java
import org.springframework.boot.Banner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyApplication {
  public static void main(String[] args) {
    SpringApplication application = new SpringApplication(MyApplication.class);
    application.setBannerMode(Banner.Mode.OFF);
    application.run(args);
  } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.Banner
import org.springframework.boot.SpringApplication
import org.springframework.boot.autoconfigure.SpringBootApplication

@SpringBootApplication
object MyApplication {
  @JvmStatic
  fun main(args: Array<String>) {
    val application = SpringApplication(MyApplication::class.java)
    application.setBannerMode(Banner.Mode.OFF)
    application.run(*args)
  } 
}
```

또는 `SpringApplicationBuilder`의 `source(...)` 메소드에:

`자바`
```java
import org.springframework.boot.Banner;
import org.springframework.boot.builder.SpringApplicationBuilder;

public class MyApplication {
    public static void main(String[] args) {
        new SpringApplicationBuilder()
            .bannerMode(Banner.Mode.OFF)
            .sources(MyApplication.class)
            .run(args);
  } 
}

```

`코틀린`
```kotlin
import org.springframework.boot.Banner
import org.springframework.boot.builder.SpringApplicationBuilder

object MyApplication {
  @JvmStatic
  fun main(args: Array<String>) {
      SpringApplicationBuilder()
          .bannerMode(Banner.Mode.OFF)
          .sources(MyApplication::class.java)
          .run(*args)
  } 
}
```

위의 예제를 고려하면 다음과 같은 구성이 있다.

`프로퍼티스(Properties)`
```
spring.main.sources=com.example.MyDatabaseConfig,com.example.MyJmsConfig
spring.main.banner-mode=console
```

`Yaml`
```yaml
spring:
  main:
    sources: "com.example.MyDatabaseConfig,com.example.MyJmsConfig"
    banner-mode: "console"
```

실제 애플리케이션은 배너(구성에 의해 오버라이드됨)를 표시하고 `ApplicationContext`에 대해 세 가지 소스를 사용한다. 애플리케이션 소스는 다음과 같다.

1. `MyApplication` (코드로부터)
2. `MyDatabaseConfig` (외부 구성으로부터) 
3. `MyJmsConfig`(외부 구성으로부터)


### 18.2.3. 애플리케이션의 외부 프로퍼티스 위치 변경(Change the Location of External Properties of an Application)
기본적으로, 다양한 소스의 프로퍼티스는 정의된 순서대로 스프링 환경에 추가된다(정확한 순서는 '스프링 부트 기능' 장의 ['외부화된 구성'](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#72-externalized-configuration) 참고).

다음 시스템 프로퍼티스(또는 환경 변수)을 제공하여 동작을 변경할 수도 있다.
- `spring.config.name` (`SPRING_CONFIG_NAME`): 파일 이름의 루트는 'application'으로 기본 설정된다.
- `spring.config.location` (`SPRING_CONFIG_LOCATION`): 로드할 파일(예: 클래스패스 리소스 또는 URL)이다. 이 문서에는 별도의 `Environment` 프로퍼티 소스가 설정되어 있으며 시스템 프로퍼티, 환경 변수 또는 커맨드라인으로 오버라이드될 수 있다.

환경에 무엇을 설정했는지에 관계없이 스프링 부트는 위에서 설명한 대로 항상 `application.properties`를 로드한다. 기본적으로 YAML을 사용하는 경우 '.yaml' 및 '.yml' 확장자를 가진 파일도 목록에 추가된다.

{: .note}
로드되는 파일에 대한 자세한 정보를 원할 경우 `org.springframework.boot.context.config`의 로깅 레벨을 트레이스(trace)로 설정할 수 있다.


### 18.2.4. '짧은' 커맨드라인 아규먼트 사용(Use ‘Short’ Command Line Arguments)
어떤 사람들은 커맨드라인에서 구성 프로퍼티를 설정하기 위해 `--server.port=9000` 대신 `--port=9000`을 사용하는 것을 좋아한다. 다음 예제와 같이 `application.properties`에서 자리 표시자를 사용하여 이 동작을 활성화할 수 있다.

`프로퍼티스(Properties)`
```
server.port=${port:8080}
```

`Yaml`
```yaml
server:
  port: "${port:8080}"
```

`spring-boot-starter-parent` POM에서 상속받은 경우, `maven-resources-plugins`의 기본 필터 토큰이 `${*}`에서 `@`(즉, `${maven.token}`대신 `@maven.token@`)을 사용하여 스프링 스타일 자리 표시자와의 충돌을 방지한다. `application.properties`에 대해 메이븐 필터링을 직접 활성화한 경우 다른 구분 기호를 사용하도록 기본 필터 토큰을 변경할 수도 있다.

{: .note}
이 특정한 경우 포트 바인딩은 헤로쿠(Heroku) 또는 클라우드 파운드리(Cloud Foundry)와 같은 PaaS 환경에서 작동한다. 이 두 플랫폼에서 PORT 환경 변수는 자동으로 설정되며 스프링은 환경 프로퍼티에 대한 대문자 동의어에 바인딩할 수 있다.


### 18.2.5. 외부 프로퍼티스에 YAML 사용(Use YAML for External Properties)
YAML은 JSON의 상위 집합이므로 다음 예제와 같이 외부 프로퍼티를 계층 포맷으로 저장하기 위한 편리한 문법이다.

```yaml
spring:
  application:
    name: "cruncher"
  datasource:
    driver-class-name: "com.mysql.jdbc.Driver"
    url: "jdbc:mysql://localhost/test"
server:
  port: 9000
```

`application.yaml`이라는 파일을 생성하여 클래스패스 루트에 넣는다. 그런 다음 의존성에 `snakeyaml`을 추가한다(메이븐은 `spring-boot-starter`를 사용하는 경우 이미 포함된 `org.yaml:snakeyaml`을 사용한다). YAML 파일은 `Java Map<String,Object>`(예: JSON 객체)로 파싱하고 스프링 부트는 맵을 평면화하여 많은 사람들이 익숙한 프로퍼티 파일처럼 한 레벨 깊이에 마침표로 구분된 키를 갖도록 한다.

이전 예제 YAML은 다음 `application.properties` 파일에 해당한다.

```
spring.application.name=cruncher
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost/test
server.port=9000
```

YAML에 대한 자세한 내용은 '스프링 부트 기능' 장의 ['YAML 작업'](https://onestone9900.github.io/docs/spring_boot/3.1.1/spring_boot/7.core_features/#725-working-with-yaml)을 참고하자.


### 18.2.6. 활성 스프링 프로필 설정(Set the Active Spring Profiles)
스프링 `Environment`에는 이를 위한 API가 있지만 일반적으로 시스템 프로퍼티(`spring.profiles.active`) 또는 OS 환경 변수(`SPRING_PROFILES_ACTIVE`)를 설정한다. 또한 다음과 같이 `-D` 아규먼트를 사용하여 애플리케이션을 시작할 수 있다(메인 클래스 또는 jar 압축파일 앞에 놓는 것을 기억하자).

```
$ java -jar -Dspring.profiles.active=production demo-0.0.1-SNAPSHOT.jar
```

스프링 부트에서는 다음 예제와 같이 `application.properties`에서 활성 프로필을 설정할 수도 있다.

`프로퍼티스(Properties)`
```
spring.profiles.active=production
```

`Yaml`
```yaml
spring:
  profiles:
    active: "production"
```

이 방법으로 설정된 값은 시스템 프로퍼티나 환경 변수 설정으로 대체되지만 `SpringApplicationBuilder.profiles()` 메서드로는 대체되지 않는다. 따라서 후자의 자바 API를 사용하면 기본값을 변경하지 않고 프로필을 보강할 수 있다.

자세한 내용은 "스프링 부트 기능" 장의 ["프로필"](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#73-profiles)을 참고하자.


### 18.2.7. 기본 프로필명 설정(Set the Default Profile Name)
기본 프로필은 활성화된 프로필이 없는 경우 활성화되는 프로필이다. 기본적으로 기본 프로필 이름은 `default`이지만 시스템 프로퍼티(`spring.profiles.default`) 또는 OS 환경 변수(`SPRING_PROFILES_DEFAULT`)를 사용하여 변경할 수 있다.

스프링 부트에서는, 다음 예제와 같이 `application.properties`에서 기본 프로필명을 설정할 수도 있다.

`프로퍼티스(Properties)`
```
spring.profiles.default=dev
```

`Yaml`
```yaml
spring:
  profiles:
    default: "dev"
```

자세한 내용은 "스프링 부트 기능" 장의 ["프로필"](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#73-profiles)을 참고하자.


### 18.2.8. 환경에 따라 구성 변경(Change Configuration Depending on the Environment)
스프링 부트는 활성 프로필을 조건부로 활성화할 수 있는 다중 문서 YAML 및 프로퍼티 파일(자세한 내용은 [다중 문서 파일 작업](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#working-with-multi-document-files) 참고)을 지원한다.

문서에 `spring.config.activate.on-profile` 키가 포함되어 있으면 프로필 값(쉼표로 구분된 프로필 목록 또는 프로필 표현식)이 스프링 `Environment.acceptsProfiles()` 메서드에 제공된다. 다음 예제와 같이 프로필 식이 일치하면 해당 문서가 최종 병합에 포함된다(그렇지 않으면 포함되지 않음).

`프로퍼티스(Properties)`
```
server.port=9000
#---
spring.config.activate.on-profile=development
server.port=9001
#---
spring.config.activate.on-profile=production
server.port=0
```

`Yaml`
```yaml
server:
  port: 9000
--- 
spring:
  config:
    activate:
      on-profile: "development"
server:
  port: 9001
---
spring:
  config:
    activate:
      on-profile: "production"
server:
  port: 0
```

앞의 예제에서 기본 포트는 9000이다. 그러나 'development'라는 스프링 프로필이 활성화된 경우 포트는 9001이다. 'production'이 활성화된 경우 포트는 0이다.

{: .note }
문서는 발견된 순서대로 병합된다. 나중 값은 이전 값을 오버라이드 한다.


### 18.2.9. 외부 프로퍼티스에 대한 빌트인 옵션 살펴보기(Discover Built-in Options for External Properties)
스프링 부트는 런타임 시 `application.properties`(또는 YAML 파일 및 기타 위치)의 외부 프로퍼티를 애플리케이션에 바인딩한다. 클래스패스에 있는 추가 jar 파일에서 기여가 이루어질 수 있기 때문에 단일 위치에 지원되는 모든 프로퍼티의 전체 목록이 없으며 기술적으로 그럴 수도 없다.

액추에이터 기능을 사용하여 실행 중인 애플리케이션에는 `@ConfigurationProperties`를 통해 사용 가능한 모든 바인딩 및 바인딩 가능한 프로퍼티를 표시하는 `configprops` 엔드포인트가 있다.

부록에는 스프링 부트에서 지원하는 가장 일반적인 프로퍼티스 목록과 함께 `application.properties` 예제가 포함되어 있다. 최종 목록은 소스 코드에서 `@ConfigurationProperties` 및 `@Value` 어노테이션을 검색하고 가끔씩 `Binder`를 사용하여 얻은 것이다. 프로퍼티스 로드의 정확한 순서에 대한 자세한 내용은 ["외부화된 구성"](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#72-externalized-configuration)을 참고하자.


## 18.3. 임베디드 웹 서버(Embedded Web Servers)
각 스프링 부트 웹 애플리케이션에는 임베디드 웹 서버가 포함되어 있다. 이 기능은 임베디드 서버를 변경하는 방법과 임베디드 서버를 구성하는 방법을 포함하여 다양한 방법에 대한 질문으로 이어진다. 이 장에서는 이러한 질문에 답변한다.


### 18.3.1. 다른 웹서버 사용(Use Another Web Server)
많은 스프링 부트 스타터에는 기본 임베디드 컨테이너가 포함되어 있다.
- 서블릿 스택 애플리케이션의 경우 `spring-boot-starter-web`에는 `spring-boot-starter-tomcat`을 포함하여 톰캣이 포함되어 있지만, `spring-boot-starter-jetty` 또는 `spring-boot-starter-undertow`을 사용할 수도 있다.
- 리액티브 스택 애플리케이션의 경우 `spring-boot-starter-webflux`에는 `spring-boot-starter-reactor-netty`를 포함하여 리액터 네티가 포함되어 있지만 `spring-boot-starter-tomcat`, `spring-boot-starter-jetty` 또는 `spring-boot-starter-undertow`를 대신 사용할 수도 있다.

다른 HTTP 서버로 전환할 때 필요한 기본 의존성을 대신 교체해야 한다. 이 프로세스를 돕기 위해 스프링 부트는 지원되는 각 HTTP 서버에 대해 별도의 스타터를 제공한다.

다음 메이븐 예제에서는 톰캣을 제외하고 스프링 MVC용 제티(Jetty)를 포함하는 방법을 보여준다.

```xml
<properties>
  <servlet-api.version>3.1.0</servlet-api.version>
</properties>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
  <exclusions>
    <!-- 톰캣 의존성 제외 -->
    <exclusion>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-tomcat</artifactId>
    </exclusion>
  </exclusions>
</dependency>
<!-- 대신 Jetty 사용 -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
```

{: .note }
톰캣 9 및 언더토우 2와 달리 제티 9.4는 서블릿 4.0을 지원하지 않으므로 서블릿 API 버전이 오버라이드 됐다.

서블릿 4.0을 지원하는 제티 10을 사용하려면 다음 예제에 표시된 대로 수행할 수 있다.

```xml
<properties>
  <jetty.version>10.0.8</jetty.version>
</properties>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
  <exclusions>
    <!-- 톰캣 의존성 제외 -->
    <exclusion>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-tomcat</artifactId>
    </exclusion>
  </exclusions>
</dependency>
<!-- 대신 Jetty 사용 -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-jetty</artifactId>
  <exclusions>
      <!-- 제티-9 일부 의존성 제외 -->
      <exclusion>
        <groupId>org.eclipse.jetty.websocket</groupId>
        <artifactId>websocket-server</artifactId>
      </exclusion>
      <exclusion>
        <groupId>org.eclipse.jetty.websocket</groupId>
        <artifactId>javax-websocket-server-impl</artifactId>
      </exclusion>
  </exclusions>
</dependency>
```

톰캣 스타터를 제외하는 것과 함께 몇 가지 제티9 관련 의존성도 제외해야 한다.

다음 그레이들 예제에서는 스프링 웹플럭스용 리액터 네티 대신 언더토우를 사용하기 위해 필요한 의존성과 모듈 교체를 구성한다.

```groovy
dependencies {
  implementation "org.springframework.boot:spring-boot-starter-undertow"
  implementation "org.springframework.boot:spring-boot-starter-webflux"
  modules {
      module("org.springframework.boot:spring-boot-starter-reactor-netty") {
          replacedBy("org.springframework.boot:spring-boot-starter-undertow", "Use Undertow instead of Reactor Netty")
      }
  } 
}
```

{: .note }
`spring-boot-starter-reactor-netty`는 `웹클라이언트(WebClient)` 클래스를 사용하는 데 필요하므로 다른 서버를 포함해야 하는 경우에도 네티(Netty)에 대한 의존성을 유지해야 할 수도 있다.


### 18.3.2. 웹 서버 비활성화(Disabling the Web Server)
클래스패스에 웹 서버를 시작하는 데 필요한 비트가 포함되어 있으면 스트링 부트가 시작한다. 이 동작을 비활성화하려면 다음 예와 같이 `application.properties`에서 `WebApplicationType`을 구성하면 된다.

`프로퍼티스(Properties)`
```
spring.main.web-application-type=none
```

`Yaml`
```yaml
spring:
  main:
    web-application-type: "none"
```


### 18.3.3. HTTP 포트 변경(Change the HTTP Port)
독립 실행형 애플리케이션에서 기본 HTTP 포트는 기본적으로 8080이지만, `server.port`를 사용하여 설정할 수 있다(예: `application.properties` 또는 시스템 프로퍼티). 환경 값의 느린 바인딩(relaxed binding) 덕분에 `SERVER_PORT`(예: OS 환경 변수)를 사용할 수도 있다.

HTTP 엔드포인트를 완전히 끄되 여전히 `WebApplicationContext`를 생성하려면 `server.port=-1`을 사용하자(그렇게 하면 테스트에 유용할 때도 있음).

자세한 내용은 '스프링 부트 기능' 장의 "[임베디드 서블릿 컨테이너 커스텀](/docs/spring_boot/3.1.1/spring_boot/8.developing_with_spring_boot/#%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C-%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%BB%A4%EC%8A%A4%ED%85%80customizing-embedded-servlet-containers)" 또는 `ServerProperties` 소스 코드를 참고하자.


### 18.3.4. 할당되지 않은 무작위 HTTP 포트 사용(Use a Random Unassigned HTTP Port)
사용 가능한 포트를 검색하려면(충돌을 방지하기 위해 OS 기본 사용) `server.port=0`을 사용하자.


### 18.3.5. 런타임 시 HTTP 포트 검색(Discover the HTTP Port at Runtime)
로그 출력이나 `WebServer`를 통해 `WebServerApplicationContext`에서 서버가 실행 중인 포트에 접근할 수 있다. 이를 가져오고 초기화되었는지 확인하는 가장 좋은 방법은 `ApplicationListener<WebServerInitializedEvent>` 타입의 `@Bean`을 추가하고 게시될 때 이벤트에서 컨테이너를 꺼내는 것이다.

`@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)`를 사용하는 테스트는 다음 예제와 같이 `@LocalServerPort` 어노테이션을 사용하여 필드에 실제 포트를 주입할 수도 있다.

`자바`
```java
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.server.LocalServerPort;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class MyWebIntegrationTests {
  @LocalServerPort
  int port;
  // ... 
}

```

`코틀린`
```kotlin
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment
import org.springframework.boot.test.web.server.LocalServerPort

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class MyWebIntegrationTests {
  @LocalServerPort
  var port = 0
  // ... 
}
```

{: .note }
`@LocalServerPort`는 `@Value("${local.server.port}")`에 대한 메타 어노테이션이다. 일반 애플리케이션에 포트를 삽입하지 말자. 방금 본 것처럼 값은 컨테이너가 초기화된 후에만 설정된다. 테스트와 달리 애플리케이션 코드 콜백은 초기(값이 실제로 사용 가능해지기 전)에 처리된다.


### 18.3.6. HTTP 응답 압축 활성화(Enable HTTP Response Compression)
HTTP 응답 압축은(response compression) 제티, 톰캣, 리액터 네티 및 언더토우에서 지원된다. 다음과 같이 `application.properties`에서 활성화할 수 있다.

`프로퍼티스(Properties)`
```
server.compression.enabled=true
```

`Yaml`
```yaml
server:
  compression:
    enabled: true
```

기본적으로, 압축을 수행하려면 응답 길이가 2048바이트 이상이어야 한다. `server.compression.min-response-size` 프로퍼티를 설정하여 이 동작을 구성할 수 있다.

기본적으로 응답은 콘텐츠 타입(content type)이 다음 중 하나인 경우에만 압축된다.

- `text/html`
- `text/xml`
- `text/plain`
- `text/css`
- `text/javascript`
- `application/javascript`
- `application/json`
- `application/xml`

`server.compression.mime-types` 프로퍼티를 설정하여 이 동작을 구성할 수 있다.


### 18.3.7. SSL 구성(Configure SSL)
SSL은 일반적으로 `application.properties` 또는 `application.yaml`에서 다양한 `server.ssl.*` 프로퍼티스를 설정하여 선언적으로 구성할 수 있다. 다음 예제에서는 자바 `KeyStore` 파일을 사용하여 SSL 프로퍼티스를 설정하는 방법을 보여준다.

`프로퍼티스(Properties)`
```
server.port=8443
server.ssl.key-store=classpath:keystore.jks
server.ssl.key-store-password=secret
server.ssl.key-password=another-secret
```

`Yaml`
```yaml
server:
  port: 8443
  ssl:
    key-store: "classpath:keystore.jks"
    key-store-password: "secret"
    key-password: "another-secret"
```

다음 예제에서는 `PEM`으로 인코딩된 인증서와 개인 키 파일을 사용하여 SSL 프로퍼티스를 설정하는 방법을 보여준다.

`프로퍼티스(Properties)`
```
server.port=8443
server.ssl.certificate=classpath:my-cert.crt
server.ssl.certificate-private-key=classpath:my-cert.key
server.ssl.trust-certificate=classpath:ca-cert.crt
```

`Yaml`
```yaml
server:
  port: 8443
  ssl:
    certificate: "classpath:my-cert.crt"
    certificate-private-key: "classpath:my-cert.key"
    trust-certificate: "classpath:ca-cert.crt"
```

또는, 다음 예제와 같이 SSL 신뢰 자료(trust material)를 SSL 번들로 구성하고 웹 서버에 적용할 수 있다.

`프로퍼티스(Properties)`
```
server.port=8443
server.ssl.bundle=example
```

`Yaml`
```yaml
server:
  port: 8443
  ssl:
    bundle: "example"
```

지원되는 모든 프로퍼티스에 대한 자세한 내용은 [Ssl](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#712-ssl)을 참고하자.

이전 예제 같은 구성을 사용한다는 것은 애플리케이션이 더 이상 포트 `8080`에서 일반 HTTP 커넥터를 지원하지 않는다는 것을 의미한다. 스프링 부트는 `application.properties`를 통해 HTTP 커넥터와 HTTPS 커넥터의 구성을 모두 지원하지 않는다. 둘 다 갖고 싶다면 프로그래밍 방식으로 둘 중 하나를 구성해야 한다. HTTP 커넥터가 프로그래밍 방식으로 구성하기가 더 쉽기 때문에 `application.properties`를 사용하여 HTTPS를 구성하는 것이 좋다.


### 18.3.8. HTTP/2 구성(Configure HTTP/2)
`server.http2.enabled` 구성 프로퍼티를 사용하여 스프링 부트 애플리케이션에서 `HTTP/2` 지원을 활성화할 수 있다. `h2(TLS를 통한 HTTP/2)` 및 `h2c(TCP를 통한 HTTP/2)`가 모두 지원된다. `h2`를 사용하려면 SSL도 활성화해야 한다. SSL이 활성화되지 않은 경우 h2c가 사용된다. 예를 들어 애플리케이션이 `TLS` 종료를 수행하는 프록시 서버 뒤에서 실행 중일 때 h2c를 사용하려고 할 수 있다.


#### HTTP/2와 톰캣(HTTP/2 With Tomcat)
스프링 부트는 기본적으로 `h2c` 및 `h2`를 지원하는 톰캣 10.1.x와 함께 제공된다. 또는 라이브러리와 해당 종속 항목이 호스트 운영 체제에 설치된 경우 `h2` 지원을 위해 `libtcnative`를 사용할 수 있다.

라이브러리 디렉토리는 아직 사용 가능하지 않은 경우 JVM 라이브러리 경로에서 사용할 수 있어야 한다. `-Djava.library.path=/usr/local/opt/tomcat-native/lib`와 같은 JVM 아규먼트를 사용하여 이를 수행할 수 있다. 이에 대한 자세한 내용은 [공식 톰캣 문서](https://tomcat.apache.org/tomcat-10.1-doc/apr.html)를 참고하자.


#### HTTP/2와 제티(HTTP/2 With Jetty)
`HTTP/2` 지원을 위해 제티에는 추가 `org.eclipse.jetty.http2:http2-server` 의존성이 필요하다. `h2c`를 사용하려면 다른 의존성이 필요하지 않다. `h2`를 사용하려면 배포에 따라 다음 의존성 중 하나를 선택해야 한다.

- `org.eclipse.jetty:jetty-alpn-java-server` JDK 빌트인 지원 사용
- `org.eclipse.jetty:jetty-alpn-conscrypt-server` 및 `Conscrypt` 라이브러리


#### 리액터 네티와 HTTP/2(HTTP/2 With Reactor Netty)
`spring-boot-webflux-starter`는 기본적으로 리액터 네티를 서버로 사용한다. 리액터 네티는 기본적으로 `h2c` 및 `h2`를 지원한다. 최적의 런타임 성능을 위해 이 서버는 기본 라이브러리가 있는 `h2`도 지원한다. 이를 활성화하려면 애플리케이션에 추가 의존성이 있어야 한다.

스프링 부트는 모든 플랫폼에 대한 기본 라이브러리를 포함하는 `io.netty:netty-tcnative-boringssl-static` "uber jar"의 버전을 관리한다. 개발자는 클래시파이어(classifier)를 사용하여 필요한 의존성만 가져오도록 선택할 수 있습니다([네티 공식 문서](https://netty.io/wiki/forked-tomcat-native.html) 참고).


#### 언더토우와 HTTP/2(HTTP/2 With Undertow)
언더토우는 기본적으로 `h2c`와 `h2`를 지원한다.


### 18.3.9. 웹서버 구성(Configure the Web Server)
일반적으로, 먼저 여러 구성 키 중 하나를 사용하고 `application.properties` 또는 `application.yaml` 파일에 새 항목(entries)을 추가하여 웹 서버를 커스텀해야 한다. "[외부 프로퍼티에 대한 빌트인 옵션 검색](/docs/spring_boot/3.1.1/spring_boot/18.how_to_guides/#1829-%EC%99%B8%EB%B6%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EC%98%B5%EC%85%98-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0discover-built-in-options-for-external-properties)"을 참고하자. `server.*` 네임스페이스는 매우 유용하며, 여기에는 서버별 기능을 위한 `server.tomcat.*`, `server.jetty.*` 등과 같은 네임스페이스가 포함되어 있다. 일반 애플리케이션 프로퍼티스 목록을 참고하자.

이전 절에서는 압축, SSL, HTTP/2 등 이미 많은 일반적인 사례를 다루었다. 그러나 사례에 맞는 구성 키가 없으면 `WebServerFactoryCustomizer`를 살펴봐야 한다. 이러한 컴포넌트를 선언하고 선택한 것과 관련된 서버 팩토리에 접근할 수 있다. 선택한 서버(Tomcat, Jetty, Reactor Netty, Undertow) 및 선택한 웹 스택(서블릿 또는 리액티브)에 대한 변수을 선택해야 한다.

아래 예제는 `spring-boot-starter-web(서블릿 스택)`이 있는 톰캣에 대한 것이다.

`자바`
```java
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.stereotype.Component;

@Component
public class MyTomcatWebServerCustomizer implements WebServerFactoryCustomizer<TomcatServletWebServerFactory> {
  @Override
  public void customize(TomcatServletWebServerFactory factory) {
    // 여기에 커스텀 팩토리를 작성
  }
}
```

`코틀린`
```kotlin
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory
import org.springframework.boot.web.server.WebServerFactoryCustomizer
import org.springframework.stereotype.Component

@Component
class MyTomcatWebServerCustomizer :
WebServerFactoryCustomizer<TomcatServletWebServerFactory?> {
  override fun customize(factory: TomcatServletWebServerFactory?) {
    // 여기에 커스텀 팩토리를 작성
  } 
}
```

{: .note }
스프링 부트는 해당 인프라를 내부적으로 사용하여 서버를 자동 구성한다. 자동 구성된 `WebServerFactoryCustomizer` 빈의 순서는 `0`이며 명시적인 순서가 없는 한 사용자가 정의한 커스텀보다 먼저 처리된다.

커스텀을 사용하여 `WebServerFactory`에 접근하면 이를 사용하여 커넥터, 서버 리소스 또는 서버 자체와 같은 특정 부분을 구성할 수 있다. 모두 서버별 API를 사용한다.

또한 스프링 부트는 다음 내용을 제공한다.

|서버|서블릿 스택|리액티브 스택|
|---|---|---|
|톰캣|`TomcatServletWebServerFactory`|`TomcatReactiveWebServerFactory`|
|제티|`JettyServletWebServerFactory`|`JettyReactiveWebServerFactory`|
|언더토우|`UndertowServletWebServerFactory`|`UndertowReactiveWebServerFactory`|
|리액터|N/A|`NettyReactiveWebServerFactory`|

최후의 수단으로 스프링 부트에서 제공하는 빈을 오버라이드하는 자신만의 `WebServerFactory` 빈을 선언할 수도 있다. 그렇게 하면 자동 구성된 커스텀이 여전히 커스텀 팩토리에 적용되므로 해당 옵션을 주의해서 사용하자.


### 18.3.10. 애플리케이션에 서블릿, 필터 또는 리스너 추가(Add a Servlet, Filter, or Listener to an Application)
`spring-boot-starter-web`을 사용하는 서블릿 스택 애플리케이션에는 `Servlet`, `Filter`, `ServletContextListener` 및 `Servlet` API가 지원하는 기타 리스너를 애플리케이션에 추가하는 두 가지 방법이 있다.

- 스프링 빈을 사용하여 서블릿, 필터 또는 리스너 추가
- 클래스패스 스캐닝하여 서블릿, 필터 및 리스너 추가


#### 스프링 빈을 사용하여 서블릿, 필터 또는 리스너 추가(Add a Servlet, Filter, or Listener by Using a Spring Bean)
스프링 빈을 사용하여 `서블릿(Servlet)`, `필터(Filter)` 또는 서블릿 `*Listener`를 추가하려면 이에 대한 `@Bean` 정의를 제공해야 한다. 이렇게 하면 구성이나 의존성을 주입하려는 경우 매우 유용할 수 있다. 그러나 너무 많은 다른 빈을 즉시 초기화(eager initialization)하지 않도록 매우 주의해야 한다. 왜냐하면 애플리케이션 생명주기 초기에 컨테이너에 구성해야 하기 때문이다. 예를 들어 DataSource 또는 JPA 구성에 의존되게 하는 것은 좋은 생각이 아니다. 초기화 대신 처음 사용할 때 빈을 지연 초기화하여 이러한 제한 사항을 해결할 수 있다.

필터 및 서블릿의 경우 기본 컴포넌트 대신 또는 기본 컴포넌트에 추가로 `FilterRegistrationBean` 또는 `ServletRegistrationBean`을 추가하여 매핑 및 초기화 파라미터를 추가할 수도 있다.

{: .note}
필터 등록에 `DispatcherType`이 지정되지 않은 경우 `REQUEST`가 사용된다. 이는 서블릿 사양의 기본 디스패처 타입과 일치한다.

다른 스프링 빈과 마찬가지로 서블릿 필터 빈의 순서를 정의할 수 있다. “[서블릿, 필터, 리스너를 스프링 비으로 등록](/docs/spring_boot/3.1.1/spring_boot/8.developing_with_spring_boot/#%EC%84%9C%EB%B8%94%EB%A6%BF-%ED%95%84%ED%84%B0-%EB%A6%AC%EC%8A%A4%EB%84%88%EB%A5%BC-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B9%88%EC%9C%BC%EB%A1%9C-%EB%93%B1%EB%A1%9Dregistering-servlets-filters-and-listeners-as-spring-beans)” 절을 확인하자.


#### 서블릿 또는 필터 등록 비활성화
앞에서 설명한 대로 모든 서블릿 또는 필터 빈은 서블릿 컨테이너에 자동으로 등록된다. 특정 필터 또는 서블릿 빈의 등록을 비활성화하려면 다음 예제와 같이 해당 등록 빈을 생성하고 비활성화된 것으로 표시한다.

`자바`
```java
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
public class MyFilterConfiguration {
    @Bean
    public FilterRegistrationBean<MyFilter> registration(MyFilter filter) {
      FilterRegistrationBean<MyFilter> registration = new FilterRegistrationBean<>(filter);
      registration.setEnabled(false);
      return registration;
    }
}
```

`코틀린`
```kotlin
import org.springframework.boot.web.servlet.FilterRegistrationBean
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration(proxyBeanMethods = false)
class MyFilterConfiguration {
  @Bean
  fun registration(filter: MyFilter): FilterRegistrationBean<MyFilter> {
    val registration = FilterRegistrationBean(filter)
    registration.isEnabled = false
    return registration
  } 
}
```


#### 클래스패스 스캐닝으로 서블릿, 필터 및 리스너 추가(Add Servlets, Filters, and Listeners by Using Classpath Scanning)
`@WebServlet`, `@WebFilter` 및 `@WebListener` 어노테이션이 달린 클래스는 `@ServletComponentScan`으로 `@Configuration` 클래스에 어노테이션을 달고 등록하려는 컴포넌트가 포함된 패키지를 지정하여 임베디드 서블릿 컨테이너에 자동으로 등록될 수 있다. 기본적으로, `@ServletComponentScan`은 어노테이션이 달린 클래스를 패키지에서 스캔한다.


### 18.3.11. 접근 로깅 구성(Configure Access Logging)
각각의 네임스페이스를 통해 톰캣, 언더토우 및 제티에 대한 접근 로그를 구성할 수 있다.

예를 들어, 다음 설정은 커스텀 패턴을 사용하여 톰캣에 대한 접근을 기록한다.

`프로퍼티스(Properties)`
```
server.tomcat.basedir=my-tomcat
server.tomcat.accesslog.enabled=true
server.tomcat.accesslog.pattern=%t %a %r %s (%D ms)
```

`Yaml`
```yaml
server:
  tomcat:
    basedir: "my-tomcat"
    accesslog:
      enabled: true
      pattern: "%t %a %r %s (%D ms)"
```

{: .note}
로그의 기본 위치는 톰캣의 기본 디렉토리에 상대적인 로그 디렉토리입니다. 기본적으로 로그 디렉토리는 임시 디렉토리이므로 톰캣의 기본 디렉토리를 수정하거나 로그에 대한 절대 경로를 사용할 수 있다. 앞의 예제에서 로그는 애플리케이션의 작업 디렉토리를 기준으로 `my-tomcat/logs`에서 사용할 수 있다.

언더토우에 대한 접근 로깅은 다음 예제와 같은 방식으로 구성할 수 있다.

`프로퍼티스(Properties)`
```
server.undertow.accesslog.enabled=true
server.undertow.accesslog.pattern=%t %a %r %s (%D ms)
server.undertow.options.server.record-request-start-time=true
```

`Yaml`
```yaml
server:
  undertow:
    accesslog:
      enabled: true
      pattern: "%t %a %r %s (%D ms)"
    options:
      server:
        record-request-start-time: true
```

접근 로깅을 활성화하고 패턴을 구성하는 것 외에도 레코딩 시작 시간도 활성화됐다. 이는 접근 로그 패턴에 응답 시간(`%D`)을 포함할 때 필요하다. 로그는 애플리케이션의 작업 디렉토리에 상대적인 경로의 `logs` 디렉토리에 저장된다. `server.undertow.accesslog.dir` 프로퍼티를 설정하여 이 위치를 커스텀할 수 있다.

마지막으로 제티에 대한 접근 로깅을 다음과 같이 구성할 수도 있다.

`프로퍼티스(Properties)`
```
server.jetty.accesslog.enabled=true
server.jetty.accesslog.filename=/var/log/jetty-access.log
```

`Yaml`
```yaml
server:
  jetty:
    accesslog:
      enabled: true
      filename: "/var/log/jetty-access.log"
```

기본적으로, 로그는 `System.err`로 리다이렉션된다. 자세한 내용은 제티 문서를 참고하자.


### 18.3.12. 프론트엔드 프록시 서버 뒤에서 실행(Running Behind a Front-end Proxy Server)
애플리케이션이 프록시, 로드 밸런서 또는 클라우드 뒤에서 실행되는 경우 요청 정보(호스트, 포트, 체계 등)가 도중에 변경될 수 있다. 애플리케이션이 `10.10.10.10:8080`에서 실행 중일 수 있지만 HTTP 클라이언트에는 `example.org`만 표시되어야 한다.

[RFC7239 "전달된 헤더"](https://datatracker.ietf.org/doc/html/rfc7239)는 전달된 HTTP 헤더를 정의한다. 프록시는 이 헤더를 사용하여 원래 요청에 대한 정보를 제공할 수 있다. 해당 헤더를 읽고 링크를 생성하여 `HTTP 302` 응답, JSON 문서 또는 HTML 페이지로 클라이언트에 보낼 때 해당 정보를 자동으로 사용하도록 애플리케이션을 구성할 수 있다. `X-Forwarded-Host`, `X-Forwarded-Port`, `X-Forwarded-Proto`, `X-Forwarded-Ssl` 및 `X-Forwarded-Prefix`와 같은 비표준 헤더도 있다.

프록시가 일반적으로 사용되는 `X-Forwarded-For` 및 `X-Forwarded-Proto` 헤더를 추가하는 경우 `server.forward-headers-strategy`를 `NATIVE`로 설정하면 이를 지원한다. 이 옵션을 사용하면 웹 서버 자체가 이 기능을 지원한다. 특정 문서를 확인하여 특정 동작에 대해 알아볼 수 있다.

이것이 충분하지 않은 경우 스프링 프레임워크는 [`ForwardedHeaderFilter`](https://docs.spring.io/spring-framework/reference/web/webmvc/filters.html#filters-forwarded-headers)를 제공한다. `server.forward-headers-strategy`를 `FRAMEWORK`로 설정하여 애플리케이션에서 서블릿 필터로 등록할 수 있다.

{: .note}
톰캣을 사용하고 프록시에서 SSL을 종료하는 경우 `server.tomcat.redirect-context-root`를 `false`로 설정해야 한다. 이를 통해 리다이렉션이 수행되기 전에 `X-Forwarded-Proto` 헤더를 적용할 수 있다.

{: .note}
애플리케이션이 클라우드 파운드리 또는 헤로쿠(Heroku)에서 실행되는 경우 `server.forward-headers-strategy` 프로퍼티는 기본적으로 `NATIVE`로 설정된다. 다른 모든 경우에는 기본값이 `NONE`이다.


#### 톰캣의 프록시 구성 커스텀(Customize Tomcat’s Proxy Configuration)
톰캣을 사용하는 경우 다음 예제와 같이 "포워드"된 정보를 전달하는 데 사용되는 헤더 이름을 추가로 구성할 수 있다.

`프로퍼티스(Properties)`
```
server.tomcat.remoteip.remote-ip-header=x-your-remote-ip-header
server.tomcat.remoteip.protocol-header=x-your-protocol-header
```

`Yaml`
```yaml
server:
  tomcat:
    remoteip:
      remote-ip-header: "x-your-remote-ip-header"
      protocol-header: "x-your-protocol-header"
```

또한 톰캣은 신뢰할 수 있는 내부 프록시와 일치하는 정규식으로 구성된다. 기본값은 부록의 `server.tomcat.remoteip.internal-proxies` 항목을 참고하자. 다음 예제와 같이 `application.properties`에 항목을 추가하여 밸브 구성을 커스텀할 수 있다.

`프로퍼티스(Properties)`
```
server.tomcat.remoteip.internal-proxies=192\\.168\\.\\d{1,3}\\.\\d{1,3}
```

`Yaml`
```yaml
server:
  tomcat:
    remoteip:
      internal-proxies: "192\\.168\\.\\d{1,3}\\.\\d{1,3}"
```

{: .note}
내부 프록시를 공백으로 설정하면 모든 프록시를 신뢰할 수 있다. 그러나 프로덕션에서는 사용하지 말자.

자동을 끄고(`server.forward-headers-strategy=NONE` 설정) `WebServerFactoryCustomizer` 빈을 사용하여 새 `valve` 인스턴스를 추가하여 톰캣의 `RemoteIpValve` 구성을 완전히 제어할 수 있다.


### 18.3.13. 톰캣으로 다중 커넥터 활성화(Enable Multiple Connectors with Tomcat)
다음 예제와 같이 HTTP 및 HTTPS 커넥터를 포함한 여러 커넥터를 허용할 수 있는 `org.apache.catalina.connector.Connector`를 `TomcatServletWebServerFactory`에 추가할 수 있다.

`자바`
```java
import org.apache.catalina.connector.Connector;
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
public class MyTomcatConfiguration {
  @Bean
  public WebServerFactoryCustomizer<TomcatServletWebServerFactory> connectorCustomizer() {
    return (tomcat) -> tomcat.addAdditionalTomcatConnectors(createConnector());
  }
  
  private Connector createConnector() {
    Connector connector = new Connector("org.apache.coyote.http11.Http11NioProtocol");
    connector.setPort(8081);
    return connector;
  }
}
```

`코틀린`
```kotlin
import org.apache.catalina.connector.Connector
import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory
import org.springframework.boot.web.server.WebServerFactoryCustomizer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration(proxyBeanMethods = false)
class MyTomcatConfiguration {
  @Bean
  fun connectorCustomizer(): WebServerFactoryCustomizer<TomcatServletWebServerFactory> {
    return WebServerFactoryCustomizer { tomcat: TomcatServletWebServerFactory -> 
                tomcat.addAdditionalTomcatConnectors(createConnector())
    } 
  }
  private fun createConnector(): Connector {
    val connector = Connector("org.apache.coyote.http11.Http11NioProtocol")
    connector.port = 8081
    return connector
  } 
}
```


### 18.3.14. 톰캣의 MBean 레지스트리 활성화(Enable Tomcat’s MBean Registry)
내장된 톰캣의 MBean 레지스트리는 기본적으로 비활성화되어 있다. 이는 톰캣의 메모리 사용량을 최소화한다. 예를 들어 톰캣의 MBean을 사용하여 마이크로미터에서 메트릭을 노출하는 데 사용할 수 있도록 하려면 다음 예제에 표시된 대로 `server.tomcat.mbeanregistry.enabled` 프로퍼티를 사용해야 한다.

`프로퍼티스(Properties)`
```
server.tomcat.mbeanregistry.enabled=true
```

`Yaml`
```yaml
server:
  tomcat:
    mbeanregistry:
      enabled: true
```


### 18.3.15. 언더토우로 다중 리스너 활성화(Enable Multiple Listeners with Undertow)
다음 예제와 같이 `UndertowServletWebServerFactory`에 `UndertowBuilderCustomizer`를 추가하고 빌더에 리스너를 추가한다.

`자바`
```java
import io.undertow.Undertow.Builder;
import org.springframework.boot.web.embedded.undertow.UndertowServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false)
public class MyUndertowConfiguration {
  @Bean
  public WebServerFactoryCustomizer<UndertowServletWebServerFactory> undertowListenerCustomizer() {
    return (factory) -> factory.addBuilderCustomizers(this::addHttpListener);
  }
  
  private Builder addHttpListener(Builder builder) {
    return builder.addHttpListener(8080, "0.0.0.0");
  } 
}
```

`코틀린`
```kotlin
import io.undertow.Undertow
import org.springframework.boot.web.embedded.undertow.UndertowBuilderCustomizer
import org.springframework.boot.web.embedded.undertow.UndertowServletWebServerFactory
import org.springframework.boot.web.server.WebServerFactoryCustomizer
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration(proxyBeanMethods = false)
class MyUndertowConfiguration {
  @Bean
  fun undertowListenerCustomizer(): WebServerFactoryCustomizer<UndertowServletWebServerFactory> { 
    return WebServerFactoryCustomizer { factory: UndertowServletWebServerFactory ->
      factory.addBuilderCustomizers(UndertowBuilderCustomizer { builder: Undertow.Builder -> addHttpListener(builder) })
    }
  }

  private fun addHttpListener(builder: Undertow.Builder): Undertow.Builder {
    return builder.addHttpListener(8080, "0.0.0.0")
  } 
}
```


### 18.3.16. @ServerEndpoint를 사용하여 웹소켓 엔드포인트 생성(Create WebSocket Endpoints Using @ServerEndpoint)
임베디드 컨테이너를 사용한 스프링 부트 애플리케이션에서 `@ServerEndpoint`를 사용하려면 다음 예제와 같이 단일 `ServerEndpointExporter` `@Bean`을 선언해야 한다.

`자바`
```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.socket.server.standard.ServerEndpointExporter;

@Configuration(proxyBeanMethods = false)
public class MyWebSocketConfiguration {
  @Bean
  public ServerEndpointExporter serverEndpointExporter() {
    return new ServerEndpointExporter();
  }
}
```

`코틀린`
```kotlin
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.socket.server.standard.ServerEndpointExporter

@Configuration(proxyBeanMethods = false)
class MyWebSocketConfiguration {
  @Bean
  fun serverEndpointExporter(): ServerEndpointExporter {
    return ServerEndpointExporter()
  }
}
```

이전 예제에 표시된 빈은 `@ServerEndpoint` 어노테이션이 달린 빈을 기본 `WebSocket` 컨테이너에 등록한다. 독립형 서블릿 컨테이너에 배포되면 이 역할은 서블릿 컨테이너 이니셜라이저에 의해 수행되며 `ServerEndpointExporter` 빈은 필요하지 않습니다.


## 18.4. 스프링 MVC(Spring MVC)
스프링 부트에는 스프링 MVC를 포함하는 다양한 스타터가 있다. 일부 스타터에는 스프링 MVC를 직접 포함하지 않고 의존성을 포함한다는 점에 유의하자. 이 절에서는 스프링 MVC 및 스프링 부트에 대한 일반적인 질문에 답변한다.


### 18.4.1. JSON REST 서비스 작성(Write a JSON REST Service)
스프링 부트 애플리케이션의 모든 스프링 `@RestController`는 다음 예제와 같이 `Jackson2`가 클래스패스에 있는 한 기본적으로 JSON 응답을 렌더링한다.

`자바`
```java
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MyController {
  @RequestMapping("/thing")
  public MyThing thing() {
    return new MyThing();
  }
}
```

`코틀린`
```kotlin
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class MyController {
  @RequestMapping("/thing")
  fun thing(): MyThing {
    return MyThing()
  }
}
```

`MyThing`이 `Jackson2`에 의해 직렬화될 수 있으면(일반 `POJO` 또는 `Groovy` 객체의 경우 해당) `localhost:8080/thing`은 기본적으로 이에 대한 JSON 표현을 제공한다. 브라우저는 XML을 선호하는 승인 헤더를 보내는 경향이 있기 때문에 브라우저에서 때때로 XML 응답을 볼 수 있다.


### 18.4.2. XML REST 서비스 작성(Write an XML REST Service)
클래스패스에 잭슨(Jackson) XML 확장(jackson-dataformat-xml)이 있는 경우 이를 사용하여 XML 응답을 렌더링할 수 있다. JSON에 사용한 이전 예제가 작동한다. Jackson XML 렌더러를 사용하려면 프로젝트에 다음 의존성을 추가하자.

```xml
<dependency>
  <groupId>com.fasterxml.jackson.dataformat</groupId>
  <artifactId>jackson-dataformat-xml</artifactId>
</dependency>
```

잭슨(Jackson)의 XML 확장을 사용할 수 없고 JAXB를 사용할 수 있는 경우 다음 예제와 같이 `MyThing`에 `@XmlRootElement` 어노테이션을 추가하여 XML을 렌더링할 수 있다.

`자바`
```java
import jakarta.xml.bind.annotation.XmlRootElement;

@XmlRootElement
public class MyThing {
  private String name;
  public String getName() {
      return this.name;
  }
  public void setName(String name) {
    this.name = name;
  } 
}
```

`코틀린`
```kotlin
import jakarta.xml.bind.annotation.XmlRootElement

@XmlRootElement
class MyThing {
  var name: String? = null
}
```

예를 들어 다음을 추가하여 JAXB 라이브러리가 프로젝트의 일부인지 확인해야 한다.

```xml
<dependency>
  <groupId>org.glassfish.jaxb</groupId>
  <artifactId>jaxb-runtime</artifactId>
</dependency>
```

{: .note}
서버가 JSON 대신 XML을 렌더링하도록 하려면 `Accept: text/xml` 헤더를 보내야 할 수도 있다(또는 브라우저를 사용해야 할 수도 있다).
