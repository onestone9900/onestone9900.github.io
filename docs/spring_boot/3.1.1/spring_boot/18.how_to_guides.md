---
layout: default
title: 18. "사용" 가이드("How-to" Guides)
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 18
---

[원문 - How-to Guides](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto)

***

- 18. "사용" 가이드("How-to" Guides)
  - 18.1. 스프링 부트 애플리케이션(Spring Boot Application)
    - 18.1.1. 나만의 FailureAnalyzer 만들기(Create Your Own FailureAnalyzer)
    - 18.1.2. 자동 구성 문제 해결(Troubleshoot Auto-configuration)
    - 18.1.3. 시작하기 전 환경 또는 ApplicationContext 커스텀(Customize the Environment or ApplicationContext Before It Starts)
    - 18.1.4. ApplicationContext 계층 구조 구축(상위 또는 루트 컨텍스트 추가)(Build an ApplicationContext Hierarchy (Adding a Parent or Root Context))
    - 18.1.5. 웹이 아닌 애플리케이션 만들기(Create a Non-web Application)
  - 18.2. 프로퍼티스와 구성(Properties and Configuration)
    - 18.2.1. 빌드 시 자동으로 프로퍼티스 확장(Automatically Expand Properties at Build Time)
      - 메이븐을 사용한 자동 프로퍼티 확장(Automatic Property Expansion Using Maven)
      - 그레이들을 사용한 자동 프로퍼티 확장(Automatic Property Expansion Using Gradle)
    - 18.2.2. SpringApplication 구성 외부화(Externalize the Configuration of SpringApplication)
    - 18.2.3. 애플리케이션의 외부 프로퍼티스 위치 변경(Change the Location of External Properties of an Application)
    - 18.2.4. '짧은' 커맨드라인 아규먼트 사용(Use ‘Short’ Command Line Arguments)
    - 18.2.5. 외부 프로퍼티스에 YAML 사용(Use YAML for External Properties)
    - 18.2.6. 활성 스프링 프로필 설정(Set the Active Spring Profiles)
    - 18.2.7. 기본 프로필명 설정(Set the Default Profile Name)
    - 18.2.8. 환경에 따라 구성 변경(Change Configuration Depending on the Environment)
    - 18.2.9. 외부 프로퍼티스에 대한 빌트인 옵션 살펴보기(Discover Built-in Options for External Properties)
  - 18.3. 임베디드 웹 서버(Embedded Web Servers)
    - 18.3.1. 다른 웹서버 사용(Use Another Web Server)
    - 18.3.2. 웹 서버 비활성화(Disabling the Web Server)
    - 18.3.3. HTTP 포트 변경(Change the HTTP Port)
    - 18.3.4. 할당되지 않은 무작위 HTTP 포트 사용(Use a Random Unassigned HTTP Port)
    - 18.3.5. 런타임 시 HTTP 포트 검색(Discover the HTTP Port at Runtime)
    - 18.3.6. HTTP 응답 압축 활성화(Enable HTTP Response Compression)
    - 18.3.7. SSL 구성(Configure SSL)
    - 18.3.8. HTTP/2 구성(Configure HTTP/2)
      - HTTP/2와 톰캣(HTTP/2 With Tomcat)
      - HTTP/2와 제티(HTTP/2 With Jetty)
      - 리액터 네티와 HTTP/2(HTTP/2 With Reactor Netty)
      - 언더토우와 HTTP/2(HTTP/2 With Undertow)
    - 18.3.9. Configure the Web Server
    - 18.3.10. Add a Servlet, Filter, or Listener to an Application
      - Add a Servlet, Filter, or Listener by Using a Spring Bean
      - Add Servlets, Filters, and Listeners by Using Classpath Scanning
    - 18.3.11. Configure Access Logging
    - 18.3.12. Running Behind a Front-end Proxy Server
      - Customize Tomcat’s Proxy Configuration
    - 18.3.13. Enable Multiple Connectors with Tomcat
    - 18.3.14. Enable Tomcat’s MBean Registry
    - 18.3.15. Enable Multiple Listeners with Undertow
    - 18.3.16. Create WebSocket Endpoints Using @ServerEndpoint
  - 18.4. Spring MVC
    - 18.4.1. Write a JSON REST Service
    - 18.4.2. Write an XML REST Service
    - 18.4.3. Customize the Jackson ObjectMapper
    - 18.4.4. Customize the @ResponseBody Rendering
    - 18.4.5. Handling Multipart File Uploads
    - 18.4.6. Switch Off the Spring MVC DispatcherServlet
    - 18.4.7. Switch off the Default MVC Configuration
    - 18.4.8. Customize ViewResolvers
  - 18.5. Jersey
    - 18.5.1. Secure Jersey endpoints with Spring Security
    - 18.5.2. Use Jersey Alongside Another Web Framework 
  - 18.6. HTTP Clients
    - 18.6.1. Configure RestTemplate to Use a Proxy
    - 18.6.2. Configure the TcpClient used by a Reactor Netty-based WebClient
  - 18.7. Logging
    - 18.7.1. Configure Logback for Logging
      - Configure Logback for File-only Output
    - 18.7.2. Configure Log4j for Logging
      - Use YAML or JSON to Configure Log4j2
      - Use Composite Configuration to Configure Log4j2
  - 18.8. Data Access
    - 18.8.1. Configure a Custom DataSource
    - 18.8.2. Configure Two DataSources
    - 18.8.3. Use Spring Data Repositories
    - 18.8.4. Separate @Entity Definitions from Spring Configuration
    - 18.8.5. Configure JPA Properties
    - 18.8.6. Configure Hibernate Naming Strategy
    - 18.8.7. Configure Hibernate Second-Level Caching
    - 18.8.8. Use Dependency Injection in Hibernate Components
    - 18.8.9. Use a Custom EntityManagerFactory
    - 18.8.10. Using Multiple EntityManagerFactories
    - 18.8.11. Use a Traditional persistence.xml File
    - 18.8.12. Use Spring Data JPA and Mongo Repositories
    - 18.8.13. Customize Spring Data’s Web Support
    - 18.8.14. Expose Spring Data Repositories as REST Endpoint
    - 18.8.15. Configure a Component that is Used by JPA
    - 18.8.16. Configure jOOQ with Two DataSources
  - 18.9. Database Initialization
    - 18.9.1. Initialize a Database Using JPA
    - 18.9.2. Initialize a Database Using Hibernate
    - 18.9.3. Initialize a Database Using Basic SQL Scripts
    - 18.9.4. Initialize a Spring Batch Database
    - 18.9.5. Use a Higher-level Database Migration Tool
      - Execute Flyway Database Migrations on Startup
      - Execute Liquibase Database Migrations on Startup
    - 18.9.6. Depend Upon an Initialized Database
      - Detect a Database Initializer
      - Detect a Bean That Depends On Database Initialization
  - 18.10. NoSQL
    - 18.10.1. Use Jedis Instead of Lettuce
  - 18.11. Messaging
    - 18.11.1. Disable Transacted JMS Session
  - 18.12. Batch Applications
    - 18.12.1. Specifying a Batch Data Source
    - 18.12.2. Running Spring Batch Jobs on Startup
    - 18.12.3. Running From the Command Line
    - 18.12.4. Storing the Job Repository
  - 18.13. Actuator
    - 18.13.1. Change the HTTP Port or Address of the Actuator Endpoints
    - 18.13.2. Customize the ‘whitelabel’ Error Page
    - 18.13.3. Sanitize Sensitive Values
      - Customizing Sanitization
    - 18.13.4. Map Health Indicators to Micrometer Metrics
  - 18.14. Security
    - 18.14.1. Switch off the Spring Boot Security Configuration
    - 18.14.2. Change the UserDetailsService and Add User Accounts
    - 18.14.3. Enable HTTPS When Running behind a Proxy Server
  - 18.15. Hot Swapping
    - 18.15.1. Reload Static Content
    - 18.15.2. Reload Templates without Restarting the Container
      - Thymeleaf Templates
      - FreeMarker Templates
      - Groovy Templates
    - 18.15.3. Fast Application Restarts
    - 18.15.4. Reload Java Classes without Restarting the Container
  - 18.16. Testing
    - 18.16.1. Testing With Spring Security
    - 18.16.2. Structure @Configuration classes for inclusion in slice tests
  - 18.17. Build
    - 18.17.1. Generate Build Information
    - 18.17.2. Generate Git Information
    - 18.17.3. Customize Dependency Versions
    - 18.17.4. Create an Executable JAR with Maven
    - 18.17.5. Use a Spring Boot Application as a Dependency
    - 18.17.6. Extract Specific Libraries When an Executable Jar Runs
    - 18.17.7. Create a Non-executable JAR with Exclusions
    - 18.17.8. Remote Debug a Spring Boot Application Started with Maven
    - 18.17.9. Build an Executable Archive From Ant without Using spring-boot-antlib
  - 18.18. Ahead-of-time processing
    - 18.18.1. Conditions
  - 18.19. Traditional Deployment
    - 18.19.1. Create a Deployable War File
    - 18.19.2. Convert an Existing Application to Spring Boot
    - 18.19.3. Deploying a WAR to WebLogic
  - 18.20. Docker Compose
    - 18.20.1. Customizing the JDBC URL 

***


# 18. "사용" 가이드("How-to" Guides)
이 장에서는 스프링 부트를 사용할 때 자주 발생하는 몇 가지 일반적인 '어떻게 해야 하지...' 질문에 대한 답변을 제공한다. 완전하진 않지만 꽤 많은 부분을 커버하고 있다.

여기서 다루지 않은 특정 문제가 있는 경우 [stackoverflow.com](https://stackoverflow.com/tags/spring-boot)을 확인하여 누군가 이미 답변을 제공했는지 확인할 수 있다. 이곳은 새로운 질문을 하기에도 좋은 곳이다(`spring-boot` 태그를 사용하자).

우리는 또한 이 장을 확장할 수 있게 되어 매우 기쁘다. '사용 방법'을 추가하려면 [풀 리퀘스트](https://github.com/spring-projects/spring-boot/tree/v3.1.1)를 보내보자.


## 18.1. 스프링 부트 애플리케이션(Spring Boot Application)
이 장에는 스프링 부트 애플리케이션과 직접 관련된 토픽이 포함되어 있다.


### 18.1.1. 나만의 FailureAnalyzer 만들기(Create Your Own FailureAnalyzer)
`FailureAnalyzer`는 시작 시 예외를 가로채서 이를 사람이 읽을 수 있는 메시지로 변환하고 `FailureAnalytics`에 래핑하는 훌륭한 방법이다. 스프링 부트는 애플리케이션 컨텍스트 관련 예외, JSR-303 검증 등에 대한 분석기(analyzer)를 제공한다. 자신만의 것을 만들 수도 있다.

`AbstractFailureAnalyzer`는 처리할 예외에 지정된 예외 유형이 있는지 확인하는 `FailureAnalyzer`의 편리한 확장이다. 구현체가 실제로 존재할 때만 예외를 처리할 수 있도록 이를 확장할 수 있다. 어떤 이유로든 예외를 처리할 수 없는 경우 `null`을 반환하여 다른 구현체에서 예외를 처리할 수 있도록 한다.

`FailureAnalyzer` 구현체는 `META-INF/spring.factories`에 등록되어야 한다. 다음 예제에서는 `ProjectConstraintViolationFailureAnalyzer`를 등록한다.

```
org.springframework.boot.diagnostics.FailureAnalyzer=\
com.example.ProjectConstraintViolationFailureAnalyzer
```

{: .note }
`BeanFactory` 또는 `Environment`에 접근해야 하는 경우 FailureAnalyzer는 각각 `BeanFactoryAware` 또는 `EnvironmentAware`를 구현할 수 있다.


### 18.1.2. 자동 구성 문제 해결(Troubleshoot Auto-configuration)
스프링 부트 자동 구성은 "올바른 작업"을 수행하기 위해 최선을 다하지만 때로 작업이 실패하고 이유를 분명하게 확인하기 어려울 수 있다.

모든 스프링 부트 `ApplicationContext`에는 정말 유용한 `ConditionEvaluationReport`가 있다. `DEBUG` 로깅 출력을 활성화하면 이를 볼 수 있다. `spring-boot-actuator`([액추에이터 장 참고](/docs/spring_boot/3.1.1/spring_boot/13.production_ready_features/#13-%ED%94%84%EB%A1%9C%EB%8D%95%EC%85%98-%EC%A4%80%EB%B9%84-%EA%B8%B0%EB%8A%A5production-ready-features))를 사용하는 경우 보고서를 `JSON`으로 렌더링하는 조건 엔드포인트도 있다. 해당 엔드포인트를 사용하여 애플리케이션을 디버깅하고 런타임 시 스프링 부트에 의해 추가된 기능(및 추가되지 않은 기능)을 확인하자.

소스 코드와 자바독을 살펴보면 더 많은 질문에 대한 답을 얻을 수 있다. 코드를 읽을 때 다음 법칙을 기억하자.
- `*AutoConfiguration`이라는 클래스를 찾아 해당 소스를 읽어보자. 어떤 기능을 언제 활성화하는지 알아보려면 `@Conditional*` 어노테이션에 특별한 주의를 기울이자. 커맨드라인에서 `--debug`를 추가하거나 시스템 프로퍼티 `-Ddebug`를 추가하여 앱에서 이루어진 모든 자동 구성 결정에 대한 로그를 콘솔에 가져온다. 액추에이터가 활성화된 실행 중인 애플리케이션에서 동일한 정보를 보려면 `conditions` 엔드포인트(`/actuator/conditions` 또는 이에 상응하는 JMX)를 살펴보자.
- `@ConfigurationProperties`(예: `ServerProperties`)인 클래스를 찾아 거기에서 사용 가능한 외부 구성 옵션을 읽어보자. `@ConfigurationProperties` 어노테이션에는 외부 프로퍼티에 대한 접두사 역할을 하는 이름 애트리뷰트가 있다. 따라서, `ServerProperties`에는 `prefix="server"`가 있고 해당 프로퍼티는 `server.port`, `server.address` 등이다. 액추에이터가 활성화된 실행 중인 애플리케이션에서 `configprops` 엔드포인트를 살펴보자.
- 편리한 방식으로 `Environment`에서 구성 값을 명시적으로 가져오기 위해 `Binder`에서 `bind` 메서드를 사용하는 방법을 찾아보자. 접두사와 함께 사용되는 경우가 많다.
- `Environment`에 직접 바인딩되는 `@Value` 어노테이션을 찾아보자.
- SpEL 표현식에 대한 응답으로 기능을 켜고 끄는 `@ConditionalOnExpression` 어노테이션을 찾아보자. 일반적으로 환경에서 분석된 자리 표시자(placeholder)로 평가한다.


### 18.1.3. 시작하기 전 Environment 또는 ApplicationContext 커스텀(Customize the Environment or ApplicationContext Before It Starts)
`SpringApplication`에는 컨텍스트나 environment에 커스텀을 적용하는 데 사용되는 `ApplicationListener` 및 `ApplicationContextInitializer`가 있다. 스프링 부트는 `META-INF/spring.factories`에서 내부적으로 사용할 수 있도록 이러한 커스텀을 로드한다. 추가 커스텀을 등록하는 방법은 여러 가지가 있다.
- 프로그래밍 방식으로 애플리케이션별 `SpringApplication`을 실행하기 전에 `addListeners` 및 `addInitializers` 메서드를 호출한다.
- 선언적으로, 애플리케이션별 `context.initializer.classes` 또는 `context.listener.classes` 프로퍼티스를 설정한다.
- 선언적으로, 모든 애플리케이션에 대해 `META-INF/spring.factories`를 추가하고 모든 애플리케이션이 라이브러리로 사용하는 jar 파일에 패키징한다.

`SpringApplication`은 몇 가지 특별한 `ApplicationEvent`를 리스너(컨텍스트가 생성되기 전이라도)에 보낸 다음 `ApplicationContext`에 의해 게시된 이벤트에 대한 리스너를 등록한다. 전체 목록은 '스프링 부트 기능' 장의 '[애플리케이션 이벤트 및 리스너](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#717-application-events-and-listeners)'를 참고하자.

`EnvironmentPostProcessor`를 사용하여 애플리케이션 컨텍스트를 새로 고치기 전에 `Environment`을 커스텀하는 것도 가능하다. 다음 예제와 같이 각 구현체는 `META-INF/spring.factories`에 등록되어야 한다.

```
org.springframework.boot.env.EnvironmentPostProcessor=com.example.YourEnvironmentPostProcessor
```

구현 시 임의의 파일을 로드하고 `Environment`에 추가할 수 있다. 다음 예제에서는 클래스패스에서 YAML 구성 파일을 로드한다.

`자바`
```java
import java.io.IOException;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.env.EnvironmentPostProcessor;
import org.springframework.boot.env.YamlPropertySourceLoader;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.util.Assert;

public class MyEnvironmentPostProcessor implements EnvironmentPostProcessor {
  private final YamlPropertySourceLoader loader = new YamlPropertySourceLoader();
  @Override
  public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
    Resource path = new ClassPathResource("com/example/myapp/config.yml");
    PropertySource<?> propertySource = loadYaml(path);
    environment.getPropertySources().addLast(propertySource);
  }

  private PropertySource<?> loadYaml(Resource path) {
    Assert.isTrue(path.exists(), () -> "Resource " + path + " does not exist");
    try {
      return this.loader.load("custom-resource", path).get(0);
    } catch (IOException ex) {
      throw new IllegalStateException("Failed to load yaml configuration from " + path, ex); 
    }
  } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.SpringApplication
import org.springframework.boot.env.EnvironmentPostProcessor
import org.springframework.boot.env.YamlPropertySourceLoader
import org.springframework.core.env.ConfigurableEnvironment
import org.springframework.core.env.PropertySource
import org.springframework.core.io.ClassPathResource
import org.springframework.core.io.Resource
import org.springframework.util.Assert
import java.io.IOException

class MyEnvironmentPostProcessor : EnvironmentPostProcessor {
  private val loader = YamlPropertySourceLoader()

  override fun postProcessEnvironment(environment: ConfigurableEnvironment, application: SpringApplication) {
    val path: Resource = ClassPathResource("com/example/myapp/config.yml")
    val propertySource = loadYaml(path)
    environment.propertySources.addLast(propertySource)
  }

  private fun loadYaml(path: Resource): PropertySource<*> {
    Assert.isTrue(path.exists()) { "Resource $path does not exist" }
    return try {
      loader.load("custom-resource", path)[0]
    } catch (ex: IOException) { 
      throw IllegalStateException("Failed to load yaml configuration from $path", ex) 
    }
  } 
}
```

{: .note }
`Environment`은 스프링 부트가 기본적으로 로드하는 모든 일반적인 프로퍼티 소스로 이미 준비되어 있다. 따라서 `Environment`에서 파일 위치를 얻는 것이 가능하다. 앞의 예제에서는 일반적으로 다른 위치에 정의된 키가 우선순위를 갖도록 리스트의 끝에 커스텀 리소스 프로퍼티 소스를 추가한다. 커스텀 구현체는 다른 순서를 정의할 수 있다.

{: .caution }
`@SpringBootApplication`에서 `@PropertySource`를 사용하는 것이 `Environment`에서 커스텀 리소스를 로드하는 편리한 방법으로 보일 수 있지만 권장하지는 않는다. 이러한 프로퍼티 소스는 애플리케이션 컨텍스트가 새로 고쳐질 때까지 `Environment`에 추가되지 않는다. 새로 고침이 시작되기 전에 읽혀지는 `logging.*` 및 `spring.main.*`과 같은 특정 프로퍼티를 구성하기에는 너무 늦다.


### 18.1.4. ApplicationContext 계층 구조 구축(상위 또는 루트 컨텍스트 추가)(Build an ApplicationContext Hierarchy (Adding a Parent or Root Context))
`ApplicationBuilder` 클래스를 사용하여 상위/하위 `ApplicationContext` 계층을 생성할 수 있다. 자세한 내용은 '스프링 부트 기능' 장의 '[Fluent Builder API](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#715-fluent-builder-api)'를 참고하자.


### 18.1.5. 웹이 아닌 애플리케이션 만들기(Create a Non-web Application)

모든 스프링 애플리케이션이 웹 애플리케이션(또는 웹 서비스)일 필요는 없다. 메인 메서드에서 일부 코드를 실행하고 스프링 애플리케이션을 부트스트랩하여 사용할 인프라를 설정하려는 경우 스프링 부트의 `SpringApplication` 기능을 사용할 수 있다. `SpringApplication`은 웹 애플리케이션 필요 여부에 따라 `ApplicationContext` 클래스를 변경한다. 이를 돕기 위해 가장 먼저 할 수 있는 일은 서버 관련 의존성(예: 서블릿 API)을 클래스패스에서 벗어나게 하는 것이다. 그렇게 할 수 없는 경우(예를 들어 동일한 코드 베이스에서 두 개의 애플리케이션을 실행하는 경우) `SpringApplication` 인스턴스에서 명시적으로 `setWebApplicationType(WebApplicationType.NONE)`을 호출하거나 (자바 API 또는 외부 속성을 통해) `applicationContextClass` 프로퍼티를 설정할 수 있다. 비즈니스 로직으로 실행하려는 애플리케이션 코드는 `CommandLineRunner`로 구현되고 `@Bean` 정의로 컨텍스트에 놓을 수 있다.


## 18.2. 프로퍼티스와 구성(Properties and Configuration)
이 절에는 프로퍼티스와 구성(Configuration)을 설정하고 읽는 방법과 스프링 부트 애플리케이션과의 상호 작용을 다룬다.


### 18.2.1. 빌드 시 자동으로 프로퍼티스 확장(Automatically Expand Properties at Build Time)
프로젝트의 빌드 구성에도 지정된 일부 프로퍼티스를 하드코딩하는 대신 기존 빌드 구성을 사용하여 자동으로 확장할 수 있다. 이는 메이븐과 그레이들 모두 가능하다.


#### 메이븐을 사용한 자동 프로퍼티 확장(Automatic Property Expansion Using Maven)
리소스 필터링을 사용하여 메이븐 프로젝트에서 프로퍼티스를 자동으로 확장할 수 있다. `spring-boot-starter-parent`를 사용하는 경우 다음 예와 같이 `@..@` 자리 표시자(placeholder)를 사용하여 메이븐 '프로젝트 프로퍼티스'를 참고할 수 있다.

`프로퍼티스(Properties)`
```
app.encoding=@project.build.sourceEncoding@
app.java.version=@java.version@
```

`Yaml`
```yaml
app:
  encoding: "@project.build.sourceEncoding@"
  java:
    version: "@java.version@"
```

{: .note}
프로덕션 구성만 해당 방식으로 필터링된다. 즉, `src/test/resources`에는 필터링이 적용되지 않는다.

{: .note}
`addResources` 플래그를 활성화하면 `spring-boot:run` 골(goal)은 핫 리로딩 목적으로 `src/main/resources`를 클래스패스에 직접 추가할 수 있다. 그렇게 하면 리소스 필터링과 이 기능을 우회할 수 있다. 대신 `exec:java` 골(goal)을 사용하거나 플러그인 구성을 커스텀할 수 있다. 자세한 내용은 [플러그인 사용 페이지](https://docs.spring.io/spring-boot/docs/3.1.1/maven-plugin/reference/htmlsingle/#getting-started)를 참고하자.

`starter parent`를 사용하지 않는 경우, `pom.xml`의 `<build/>` 엘리먼트 내에 다음 엘리먼트를 포함해야 한다.

```xml
<resources>
  <resource>
    <directory>src/main/resources</directory>
    <filtering>true</filtering>
  </resource>
</resources>
```

또한 `<plugins/>` 내에 다음 엘리먼트를 포함해야 한다.

```xml
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-resources-plugin</artifactId>
  <version>2.7</version>
  <configuration>
    <delimiters>
      <delimiter>@</delimiter>
    </delimiters>
    <useDefaultDelimiters>false</useDefaultDelimiters>
  </configuration>
</plugin>
```

{: .note}
`useDefaultDelimiters` 프로퍼티는 구성에서 표준 스프링 자리 표시자(예: `${placeholder}`)를 사용하는 경우 중요하다. 해당 프로퍼티가 `false`로 설정되지 않은 경우 빌드에 의해 확장할 수 있다.


#### 그레이들을 사용한 자동 프로퍼티 확장(Automatic Property Expansion Using Gradle)
다음 예와 같이 자바 플러그인의 `processResources` 태스크를 구성하여 그레이들 프로젝트에서 프로퍼티스를 자동으로 확장할 수 있다.

```groovy
tasks.named('processResources') {
  expand(project.properties)
}
```

그런 다음 다음 예제와 같이 자리 표시자를 사용하여 그레이들 프로젝트의 프로퍼티스를 참조할 수 있다.

`프로퍼티스(Properties)`
```
app.name=${name}
app.description=${description}
```

`Yaml`
```yaml
app:
  name: "${name}"
  description: "${description}"
```

{: .note}
그레이들의 `expand` 메소드는 `${..}` 토큰을 변환하는 그루비의 `SimpleTemplateEngine`을 사용한다. `${..}` 스타일은 스프링의 자체 프로퍼티 자리 표시자 메커니즘과 충돌한다. 자동 확장과 함께 스프링 프로퍼티 자리 표시자를 사용하려면 `\${..}`와 같이 스프링 프로퍼티 자리 표시자를 이스케이프 처리하자.


### 18.2.2. SpringApplication 구성 외부화(Externalize the Configuration of SpringApplication)
SpringApplication에는 빈 프로퍼티 세터가 있으므로, 해당 동작을 수정하기 위해 애플리케이션을 생성할 때 자바 API를 사용할 수 있다. 또는 `spring.main.*`에서 프로퍼티스를 설정하여 구성을 외부화할 수 있다. 예를 들어 `application.properties`에는 다음과 같은 설정이 있을 수 있다.

`프로퍼티스(Properties)`
```
spring.main.web-application-type=none
spring.main.banner-mode=off
```

`Yaml`
```yaml
spring:
  main:
    web-application-type: "none"
    banner-mode: "off"
```

그러면 시작 시 스프링 부트 배너가 인쇄되지 않고 애플리케이션이 내장된 웹 서버를 시작하지 않는다.

외부 구성에 정의된 프로퍼티스는 주요 소스를 제외하고 자바 API로 지정된 값을 오버라이드하고 대체한다. 주요(Primary) 소스는 SpringApplication 생성자에 제공되는 소스다.

`자바`
```java
import org.springframework.boot.Banner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyApplication {
  public static void main(String[] args) {
    SpringApplication application = new SpringApplication(MyApplication.class);
    application.setBannerMode(Banner.Mode.OFF);
    application.run(args);
  } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.Banner
import org.springframework.boot.SpringApplication
import org.springframework.boot.autoconfigure.SpringBootApplication

@SpringBootApplication
object MyApplication {
  @JvmStatic
  fun main(args: Array<String>) {
    val application = SpringApplication(MyApplication::class.java)
    application.setBannerMode(Banner.Mode.OFF)
    application.run(*args)
  } 
}
```

또는 `SpringApplicationBuilder`의 `source(...)` 메소드에:

`자바`
```java
import org.springframework.boot.Banner;
import org.springframework.boot.builder.SpringApplicationBuilder;

public class MyApplication {
    public static void main(String[] args) {
        new SpringApplicationBuilder()
            .bannerMode(Banner.Mode.OFF)
            .sources(MyApplication.class)
            .run(args);
  } 
}

```

`코틀린`
```kotlin
import org.springframework.boot.Banner
import org.springframework.boot.builder.SpringApplicationBuilder

object MyApplication {
  @JvmStatic
  fun main(args: Array<String>) {
      SpringApplicationBuilder()
          .bannerMode(Banner.Mode.OFF)
          .sources(MyApplication::class.java)
          .run(*args)
  } 
}
```

위의 예제를 고려하면 다음과 같은 구성이 있다.

`프로퍼티스(Properties)`
```
spring.main.sources=com.example.MyDatabaseConfig,com.example.MyJmsConfig
spring.main.banner-mode=console
```

`Yaml`
```yaml
spring:
  main:
    sources: "com.example.MyDatabaseConfig,com.example.MyJmsConfig"
    banner-mode: "console"
```

실제 애플리케이션은 배너(구성에 의해 오버라이드됨)를 표시하고 `ApplicationContext`에 대해 세 가지 소스를 사용한다. 애플리케이션 소스는 다음과 같다.

1. `MyApplication` (코드로부터)
2. `MyDatabaseConfig` (외부 구성으로부터) 
3. `MyJmsConfig`(외부 구성으로부터)


### 18.2.3. 애플리케이션의 외부 프로퍼티스 위치 변경(Change the Location of External Properties of an Application)
기본적으로, 다양한 소스의 프로퍼티스는 정의된 순서대로 스프링 환경에 추가된다(정확한 순서는 '스프링 부트 기능' 장의 ['외부화된 구성'](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#72-externalized-configuration) 참고).

다음 시스템 프로퍼티스(또는 환경 변수)을 제공하여 동작을 변경할 수도 있다.
- `spring.config.name` (`SPRING_CONFIG_NAME`): 파일 이름의 루트는 'application'으로 기본 설정된다.
- `spring.config.location` (`SPRING_CONFIG_LOCATION`): 로드할 파일(예: 클래스패스 리소스 또는 URL)이다. 이 문서에는 별도의 `Environment` 프로퍼티 소스가 설정되어 있으며 시스템 프로퍼티, 환경 변수 또는 커맨드라인으로 오버라이드될 수 있다.

환경에 무엇을 설정했는지에 관계없이 스프링 부트는 위에서 설명한 대로 항상 `application.properties`를 로드한다. 기본적으로 YAML을 사용하는 경우 '.yaml' 및 '.yml' 확장자를 가진 파일도 목록에 추가된다.

{: .note}
로드되는 파일에 대한 자세한 정보를 원할 경우 `org.springframework.boot.context.config`의 로깅 레벨을 트레이스(trace)로 설정할 수 있다.


### 18.2.4. '짧은' 커맨드라인 아규먼트 사용(Use ‘Short’ Command Line Arguments)
어떤 사람들은 커맨드라인에서 구성 프로퍼티를 설정하기 위해 `--server.port=9000` 대신 `--port=9000`을 사용하는 것을 좋아한다. 다음 예제와 같이 `application.properties`에서 자리 표시자를 사용하여 이 동작을 활성화할 수 있다.

`프로퍼티스(Properties)`
```
server.port=${port:8080}
```

`Yaml`
```yaml
server:
  port: "${port:8080}"
```

`spring-boot-starter-parent` POM에서 상속받은 경우, `maven-resources-plugins`의 기본 필터 토큰이 `${*}`에서 `@`(즉, `${maven.token}`대신 `@maven.token@`)을 사용하여 스프링 스타일 자리 표시자와의 충돌을 방지한다. `application.properties`에 대해 메이븐 필터링을 직접 활성화한 경우 다른 구분 기호를 사용하도록 기본 필터 토큰을 변경할 수도 있다.

{: .note}
이 특정한 경우 포트 바인딩은 헤로쿠(Heroku) 또는 클라우드 파운드리(Cloud Foundry)와 같은 PaaS 환경에서 작동한다. 이 두 플랫폼에서 PORT 환경 변수는 자동으로 설정되며 스프링은 환경 프로퍼티에 대한 대문자 동의어에 바인딩할 수 있다.


### 18.2.5. 외부 프로퍼티스에 YAML 사용(Use YAML for External Properties)
YAML은 JSON의 상위 집합이므로 다음 예제와 같이 외부 프로퍼티를 계층 포맷으로 저장하기 위한 편리한 문법이다.

```yaml
spring:
  application:
    name: "cruncher"
  datasource:
    driver-class-name: "com.mysql.jdbc.Driver"
    url: "jdbc:mysql://localhost/test"
server:
  port: 9000
```

`application.yaml`이라는 파일을 생성하여 클래스패스 루트에 넣는다. 그런 다음 의존성에 `snakeyaml`을 추가한다(메이븐은 `spring-boot-starter`를 사용하는 경우 이미 포함된 `org.yaml:snakeyaml`을 사용한다). YAML 파일은 `Java Map<String,Object>`(예: JSON 객체)로 파싱하고 스프링 부트는 맵을 평면화하여 많은 사람들이 익숙한 프로퍼티 파일처럼 한 레벨 깊이에 마침표로 구분된 키를 갖도록 한다.

이전 예제 YAML은 다음 `application.properties` 파일에 해당한다.

```
spring.application.name=cruncher
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost/test
server.port=9000
```

YAML에 대한 자세한 내용은 '스프링 부트 기능' 장의 ['YAML 작업'](https://onestone9900.github.io/docs/spring_boot/3.1.1/spring_boot/7.core_features/#725-working-with-yaml)을 참고하자.


### 18.2.6. 활성 스프링 프로필 설정(Set the Active Spring Profiles)
스프링 `Environment`에는 이를 위한 API가 있지만 일반적으로 시스템 프로퍼티(`spring.profiles.active`) 또는 OS 환경 변수(`SPRING_PROFILES_ACTIVE`)를 설정한다. 또한 다음과 같이 `-D` 아규먼트를 사용하여 애플리케이션을 시작할 수 있다(메인 클래스 또는 jar 압축파일 앞에 놓는 것을 기억하자).

```
$ java -jar -Dspring.profiles.active=production demo-0.0.1-SNAPSHOT.jar
```

스프링 부트에서는 다음 예제와 같이 `application.properties`에서 활성 프로필을 설정할 수도 있다.

`프로퍼티스(Properties)`
```
spring.profiles.active=production
```

`Yaml`
```yaml
spring:
  profiles:
    active: "production"
```

이 방법으로 설정된 값은 시스템 프로퍼티나 환경 변수 설정으로 대체되지만 `SpringApplicationBuilder.profiles()` 메서드로는 대체되지 않는다. 따라서 후자의 자바 API를 사용하면 기본값을 변경하지 않고 프로필을 보강할 수 있다.

자세한 내용은 "스프링 부트 기능" 장의 ["프로필"](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#73-profiles)을 참고하자.


### 18.2.7. 기본 프로필명 설정(Set the Default Profile Name)
기본 프로필은 활성화된 프로필이 없는 경우 활성화되는 프로필이다. 기본적으로 기본 프로필 이름은 `default`이지만 시스템 프로퍼티(`spring.profiles.default`) 또는 OS 환경 변수(`SPRING_PROFILES_DEFAULT`)를 사용하여 변경할 수 있다.

스프링 부트에서는, 다음 예제와 같이 `application.properties`에서 기본 프로필명을 설정할 수도 있다.

`프로퍼티스(Properties)`
```
spring.profiles.default=dev
```

`Yaml`
```yaml
spring:
  profiles:
    default: "dev"
```

자세한 내용은 "스프링 부트 기능" 장의 ["프로필"](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#73-profiles)을 참고하자.


### 18.2.8. 환경에 따라 구성 변경(Change Configuration Depending on the Environment)
스프링 부트는 활성 프로필을 조건부로 활성화할 수 있는 다중 문서 YAML 및 프로퍼티 파일(자세한 내용은 [다중 문서 파일 작업](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#working-with-multi-document-files) 참고)을 지원한다.

문서에 `spring.config.activate.on-profile` 키가 포함되어 있으면 프로필 값(쉼표로 구분된 프로필 목록 또는 프로필 표현식)이 스프링 `Environment.acceptsProfiles()` 메서드에 제공된다. 다음 예제와 같이 프로필 식이 일치하면 해당 문서가 최종 병합에 포함된다(그렇지 않으면 포함되지 않음).

`프로퍼티스(Properties)`
```
server.port=9000
#---
spring.config.activate.on-profile=development
server.port=9001
#---
spring.config.activate.on-profile=production
server.port=0
```

`Yaml`
```yaml
server:
  port: 9000
--- 
spring:
  config:
    activate:
      on-profile: "development"
server:
  port: 9001
---
spring:
  config:
    activate:
      on-profile: "production"
server:
  port: 0
```

앞의 예제에서 기본 포트는 9000이다. 그러나 'development'라는 스프링 프로필이 활성화된 경우 포트는 9001이다. 'production'이 활성화된 경우 포트는 0이다.

{: .note }
문서는 발견된 순서대로 병합된다. 나중 값은 이전 값을 오버라이드 한다.


### 18.2.9. 외부 프로퍼티스에 대한 빌트인 옵션 살펴보기(Discover Built-in Options for External Properties)
스프링 부트는 런타임 시 `application.properties`(또는 YAML 파일 및 기타 위치)의 외부 프로퍼티를 애플리케이션에 바인딩한다. 클래스패스에 있는 추가 jar 파일에서 기여가 이루어질 수 있기 때문에 단일 위치에 지원되는 모든 프로퍼티의 전체 목록이 없으며 기술적으로 그럴 수도 없다.

액추에이터 기능을 사용하여 실행 중인 애플리케이션에는 `@ConfigurationProperties`를 통해 사용 가능한 모든 바인딩 및 바인딩 가능한 프로퍼티를 표시하는 `configprops` 엔드포인트가 있다.

부록에는 스프링 부트에서 지원하는 가장 일반적인 프로퍼티스 목록과 함께 `application.properties` 예제가 포함되어 있다. 최종 목록은 소스 코드에서 `@ConfigurationProperties` 및 `@Value` 어노테이션을 검색하고 가끔씩 `Binder`를 사용하여 얻은 것이다. 프로퍼티스 로드의 정확한 순서에 대한 자세한 내용은 ["외부화된 구성"](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#72-externalized-configuration)을 참고하자.


## 18.3. 임베디드 웹 서버(Embedded Web Servers)
각 스프링 부트 웹 애플리케이션에는 임베디드 웹 서버가 포함되어 있다. 이 기능은 임베디드 서버를 변경하는 방법과 임베디드 서버를 구성하는 방법을 포함하여 다양한 방법에 대한 질문으로 이어진다. 이 장에서는 이러한 질문에 답변한다.


### 18.3.1. 다른 웹서버 사용(Use Another Web Server)
많은 스프링 부트 스타터에는 기본 임베디드 컨테이너가 포함되어 있다.
- 서블릿 스택 애플리케이션의 경우 `spring-boot-starter-web`에는 `spring-boot-starter-tomcat`을 포함하여 톰캣이 포함되어 있지만, `spring-boot-starter-jetty` 또는 `spring-boot-starter-undertow`을 사용할 수도 있다.
- 리액티브 스택 애플리케이션의 경우 `spring-boot-starter-webflux`에는 `spring-boot-starter-reactor-netty`를 포함하여 리액터 네티가 포함되어 있지만 `spring-boot-starter-tomcat`, `spring-boot-starter-jetty` 또는 `spring-boot-starter-undertow`를 대신 사용할 수도 있다.

다른 HTTP 서버로 전환할 때 필요한 기본 의존성을 대신 교체해야 한다. 이 프로세스를 돕기 위해 스프링 부트는 지원되는 각 HTTP 서버에 대해 별도의 스타터를 제공한다.

다음 메이븐 예제에서는 톰캣을 제외하고 스프링 MVC용 제티(Jetty)를 포함하는 방법을 보여준다.

```xml
<properties>
  <servlet-api.version>3.1.0</servlet-api.version>
</properties>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
  <exclusions>
    <!-- 톰캣 의존성 제외 -->
    <exclusion>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-tomcat</artifactId>
    </exclusion>
  </exclusions>
</dependency>
<!-- 대신 Jetty 사용 -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
```

{: .note }
톰캣 9 및 언더토우 2와 달리 제티 9.4는 서블릿 4.0을 지원하지 않으므로 서블릿 API 버전이 오버라이드 됐다.

서블릿 4.0을 지원하는 제티 10을 사용하려면 다음 예제에 표시된 대로 수행할 수 있다.

```xml
<properties>
  <jetty.version>10.0.8</jetty.version>
</properties>
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
  <exclusions>
    <!-- 톰캣 의존성 제외 -->
    <exclusion>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-tomcat</artifactId>
    </exclusion>
  </exclusions>
</dependency>
<!-- 대신 Jetty 사용 -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-jetty</artifactId>
  <exclusions>
      <!-- 제티-9 일부 의존성 제외 -->
      <exclusion>
        <groupId>org.eclipse.jetty.websocket</groupId>
        <artifactId>websocket-server</artifactId>
      </exclusion>
      <exclusion>
        <groupId>org.eclipse.jetty.websocket</groupId>
        <artifactId>javax-websocket-server-impl</artifactId>
      </exclusion>
  </exclusions>
</dependency>
```

톰캣 스타터를 제외하는 것과 함께 몇 가지 제티9 관련 의존성도 제외해야 한다.

다음 그레이들 예제에서는 스프링 웹플럭스용 리액터 네티 대신 언더토우를 사용하기 위해 필요한 의존성과 모듈 교체를 구성한다.

```groovy
dependencies {
  implementation "org.springframework.boot:spring-boot-starter-undertow"
  implementation "org.springframework.boot:spring-boot-starter-webflux"
  modules {
      module("org.springframework.boot:spring-boot-starter-reactor-netty") {
          replacedBy("org.springframework.boot:spring-boot-starter-undertow", "Use Undertow instead of Reactor Netty")
      }
  } 
}
```

{: .note }
`spring-boot-starter-reactor-netty`는 `웹클라이언트(WebClient)` 클래스를 사용하는 데 필요하므로 다른 서버를 포함해야 하는 경우에도 네티(Netty)에 대한 의존성을 유지해야 할 수도 있다.


### 18.3.2. 웹 서버 비활성화(Disabling the Web Server)
클래스패스에 웹 서버를 시작하는 데 필요한 비트가 포함되어 있으면 스트링 부트가 시작한다. 이 동작을 비활성화하려면 다음 예와 같이 `application.properties`에서 `WebApplicationType`을 구성하면 된다.

`프로퍼티스(Properties)`
```
spring.main.web-application-type=none
```

`Yaml`
```yaml
spring:
  main:
    web-application-type: "none"
```


### 18.3.3. HTTP 포트 변경(Change the HTTP Port)
독립 실행형 애플리케이션에서 기본 HTTP 포트는 기본적으로 8080이지만, `server.port`를 사용하여 설정할 수 있다(예: `application.properties` 또는 시스템 프로퍼티). 환경 값의 느린 바인딩(relaxed binding) 덕분에 `SERVER_PORT`(예: OS 환경 변수)를 사용할 수도 있다.

HTTP 엔드포인트를 완전히 끄되 여전히 `WebApplicationContext`를 생성하려면 `server.port=-1`을 사용하자(그렇게 하면 테스트에 유용할 때도 있음).

자세한 내용은 '스프링 부트 기능' 장의 "[임베디드 서블릿 컨테이너 커스텀](/docs/spring_boot/3.1.1/spring_boot/8.developing_with_spring_boot/#%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C-%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%BB%A4%EC%8A%A4%ED%85%80customizing-embedded-servlet-containers)" 또는 `ServerProperties` 소스 코드를 참고하자.


### 18.3.4. 할당되지 않은 무작위 HTTP 포트 사용(Use a Random Unassigned HTTP Port)
사용 가능한 포트를 검색하려면(충돌을 방지하기 위해 OS 기본 사용) `server.port=0`을 사용하자.


### 18.3.5. 런타임 시 HTTP 포트 검색(Discover the HTTP Port at Runtime)
로그 출력이나 `WebServer`를 통해 `WebServerApplicationContext`에서 서버가 실행 중인 포트에 접근할 수 있다. 이를 가져오고 초기화되었는지 확인하는 가장 좋은 방법은 `ApplicationListener<WebServerInitializedEvent>` 타입의 `@Bean`을 추가하고 게시될 때 이벤트에서 컨테이너를 꺼내는 것이다.

`@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)`를 사용하는 테스트는 다음 예제와 같이 `@LocalServerPort` 어노테이션을 사용하여 필드에 실제 포트를 주입할 수도 있다.

`자바`
```java
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment;
import org.springframework.boot.test.web.server.LocalServerPort;

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class MyWebIntegrationTests {
  @LocalServerPort
  int port;
  // ... 
}

```

`코틀린`
```kotlin
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.test.context.SpringBootTest.WebEnvironment
import org.springframework.boot.test.web.server.LocalServerPort

@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class MyWebIntegrationTests {
  @LocalServerPort
  var port = 0
  // ... 
}
```

{: .note }
`@LocalServerPort`는 `@Value("${local.server.port}")`에 대한 메타 어노테이션이다. 일반 애플리케이션에 포트를 삽입하지 말자. 방금 본 것처럼 값은 컨테이너가 초기화된 후에만 설정된다. 테스트와 달리 애플리케이션 코드 콜백은 초기(값이 실제로 사용 가능해지기 전)에 처리된다.


### 18.3.6. HTTP 응답 압축 활성화(Enable HTTP Response Compression)
HTTP 응답 압축은(response compression) 제티, 톰캣, 리액터 네티 및 언더토우에서 지원된다. 다음과 같이 `application.properties`에서 활성화할 수 있다.

`프로퍼티스(Properties)`
```
server.compression.enabled=true
```

`Yaml`
```yaml
server:
  compression:
    enabled: true
```

기본적으로, 압축을 수행하려면 응답 길이가 2048바이트 이상이어야 한다. `server.compression.min-response-size` 프로퍼티를 설정하여 이 동작을 구성할 수 있다.

기본적으로 응답은 콘텐츠 타입(content type)이 다음 중 하나인 경우에만 압축된다.

- `text/html`
- `text/xml`
- `text/plain`
- `text/css`
- `text/javascript`
- `application/javascript`
- `application/json`
- `application/xml`

`server.compression.mime-types` 프로퍼티를 설정하여 이 동작을 구성할 수 있다.


### 18.3.7. SSL 구성(Configure SSL)
SSL은 일반적으로 `application.properties` 또는 `application.yaml`에서 다양한 `server.ssl.*` 프로퍼티스를 설정하여 선언적으로 구성할 수 있다. 다음 예제에서는 자바 `KeyStore` 파일을 사용하여 SSL 프로퍼티스를 설정하는 방법을 보여준다.

`프로퍼티스(Properties)`
```
server.port=8443
server.ssl.key-store=classpath:keystore.jks
server.ssl.key-store-password=secret
server.ssl.key-password=another-secret
```

`Yaml`
```yaml
server:
  port: 8443
  ssl:
    key-store: "classpath:keystore.jks"
    key-store-password: "secret"
    key-password: "another-secret"
```

다음 예제에서는 `PEM`으로 인코딩된 인증서와 개인 키 파일을 사용하여 SSL 프로퍼티스를 설정하는 방법을 보여준다.

`프로퍼티스(Properties)`
```
server.port=8443
server.ssl.certificate=classpath:my-cert.crt
server.ssl.certificate-private-key=classpath:my-cert.key
server.ssl.trust-certificate=classpath:ca-cert.crt
```

`Yaml`
```yaml
server:
  port: 8443
  ssl:
    certificate: "classpath:my-cert.crt"
    certificate-private-key: "classpath:my-cert.key"
    trust-certificate: "classpath:ca-cert.crt"
```

또는, 다음 예제와 같이 SSL 신뢰 자료(trust material)를 SSL 번들로 구성하고 웹 서버에 적용할 수 있다.

`프로퍼티스(Properties)`
```
server.port=8443
server.ssl.bundle=example
```

`Yaml`
```yaml
server:
  port: 8443
  ssl:
    bundle: "example"
```

지원되는 모든 프로퍼티스에 대한 자세한 내용은 [Ssl](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#712-ssl)을 참고하자.

이전 예제 같은 구성을 사용한다는 것은 애플리케이션이 더 이상 포트 `8080`에서 일반 HTTP 커넥터를 지원하지 않는다는 것을 의미한다. 스프링 부트는 `application.properties`를 통해 HTTP 커넥터와 HTTPS 커넥터의 구성을 모두 지원하지 않는다. 둘 다 갖고 싶다면 프로그래밍 방식으로 둘 중 하나를 구성해야 한다. HTTP 커넥터가 프로그래밍 방식으로 구성하기가 더 쉽기 때문에 `application.properties`를 사용하여 HTTPS를 구성하는 것이 좋다.


### 18.3.8. HTTP/2 구성(Configure HTTP/2)
`server.http2.enabled` 구성 프로퍼티를 사용하여 스프링 부트 애플리케이션에서 `HTTP/2` 지원을 활성화할 수 있다. `h2(TLS를 통한 HTTP/2)` 및 `h2c(TCP를 통한 HTTP/2)`가 모두 지원된다. `h2`를 사용하려면 SSL도 활성화해야 한다. SSL이 활성화되지 않은 경우 h2c가 사용된다. 예를 들어 애플리케이션이 `TLS` 종료를 수행하는 프록시 서버 뒤에서 실행 중일 때 h2c를 사용하려고 할 수 있다.


#### HTTP/2와 톰캣(HTTP/2 With Tomcat)
스프링 부트는 기본적으로 `h2c` 및 `h2`를 지원하는 톰캣 10.1.x와 함께 제공된다. 또는 라이브러리와 해당 종속 항목이 호스트 운영 체제에 설치된 경우 `h2` 지원을 위해 `libtcnative`를 사용할 수 있다.

라이브러리 디렉토리는 아직 사용 가능하지 않은 경우 JVM 라이브러리 경로에서 사용할 수 있어야 한다. `-Djava.library.path=/usr/local/opt/tomcat-native/lib`와 같은 JVM 아규먼트를 사용하여 이를 수행할 수 있다. 이에 대한 자세한 내용은 [공식 톰캣 문서](https://tomcat.apache.org/tomcat-10.1-doc/apr.html)를 참고하자.


#### HTTP/2와 제티(HTTP/2 With Jetty)
`HTTP/2` 지원을 위해 제티에는 추가 `org.eclipse.jetty.http2:http2-server` 의존성이 필요하다. `h2c`를 사용하려면 다른 의존성이 필요하지 않다. `h2`를 사용하려면 배포에 따라 다음 의존성 중 하나를 선택해야 한다.

- `org.eclipse.jetty:jetty-alpn-java-server` JDK 빌트인 지원 사용
- `org.eclipse.jetty:jetty-alpn-conscrypt-server` 및 `Conscrypt` 라이브러리


#### 리액터 네티와 HTTP/2(HTTP/2 With Reactor Netty)
`spring-boot-webflux-starter`는 기본적으로 리액터 네티를 서버로 사용한다. 리액터 네티는 기본적으로 `h2c` 및 `h2`를 지원한다. 최적의 런타임 성능을 위해 이 서버는 기본 라이브러리가 있는 `h2`도 지원한다. 이를 활성화하려면 애플리케이션에 추가 의존성이 있어야 한다.

스프링 부트는 모든 플랫폼에 대한 기본 라이브러리를 포함하는 `io.netty:netty-tcnative-boringssl-static` "uber jar"의 버전을 관리한다. 개발자는 클래시파이어(classifier)를 사용하여 필요한 의존성만 가져오도록 선택할 수 있습니다([네티 공식 문서](https://netty.io/wiki/forked-tomcat-native.html) 참고).


#### 언더토우와 HTTP/2(HTTP/2 With Undertow)
언더토우는 기본적으로 `h2c`와 `h2`를 지원한다.
