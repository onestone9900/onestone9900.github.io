---
layout: default
title: 18. "사용" 가이드("How-to" Guides)
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 18
---

[원문 - How-to Guides](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto)

***

- 18. "사용" 가이드("How-to" Guides)
  - 18.1. 스프링 부트 애플리케이션(Spring Boot Application)
    - 18.1.1. 나만의 FailureAnalyzer 만들기(Create Your Own FailureAnalyzer)
    - 18.1.2. 자동 구성 문제 해결(Troubleshoot Auto-configuration)
    - 18.1.3. 시작하기 전 환경 또는 ApplicationContext 커스텀(Customize the Environment or ApplicationContext Before It Starts)
    - 18.1.4. ApplicationContext 계층 구조 구축(상위 또는 루트 컨텍스트 추가)(Build an ApplicationContext Hierarchy (Adding a Parent or Root Context))
    - 18.1.5. 웹이 아닌 애플리케이션 만들기(Create a Non-web Application)
  - 18.2. Properties and Configuration
    - 18.2.1. Automatically Expand Properties at Build Time
      - Automatic Property Expansion Using Maven
      - Automatic Property Expansion Using Gradle
    - 18.2.2. Externalize the Configuration of SpringApplication
    - 18.2.3. Change the Location of External Properties of an Application
    - 18.2.4. Use ‘Short’ Command Line Arguments
    - 18.2.5. Use YAML for External Properties
    - 18.2.6. Set the Active Spring Profiles
    - 18.2.7. Set the Default Profile Name
    - 18.2.8. Change Configuration Depending on the Environment
    - 18.2.9. Discover Built-in Options for External Properties
  - 18.3. Embedded Web Servers
    - 18.3.1. Use Another Web Server
    - 18.3.2. Disabling the Web Server
    - 18.3.3. Change the HTTP Port
    - 18.3.4. Use a Random Unassigned HTTP Port
    - 18.3.5. Discover the HTTP Port at Runtime
    - 18.3.6. Enable HTTP Response Compression
    - 18.3.7. Configure SSL
    - 18.3.8. Configure HTTP/2
      - HTTP/2 With Tomcat
      - HTTP/2 With Jetty
      - HTTP/2 With Reactor Netty
      - HTTP/2 With Undertow
    - 18.3.9. Configure the Web Server
    - 18.3.10. Add a Servlet, Filter, or Listener to an Application
      - Add a Servlet, Filter, or Listener by Using a Spring Bean
      - Add Servlets, Filters, and Listeners by Using Classpath Scanning
    - 18.3.11. Configure Access Logging
    - 18.3.12. Running Behind a Front-end Proxy Server
      - Customize Tomcat’s Proxy Configuration
    - 18.3.13. Enable Multiple Connectors with Tomcat
    - 18.3.14. Enable Tomcat’s MBean Registry
    - 18.3.15. Enable Multiple Listeners with Undertow
    - 18.3.16. Create WebSocket Endpoints Using @ServerEndpoint
  - 18.4. Spring MVC
    - 18.4.1. Write a JSON REST Service
    - 18.4.2. Write an XML REST Service
    - 18.4.3. Customize the Jackson ObjectMapper
    - 18.4.4. Customize the @ResponseBody Rendering
    - 18.4.5. Handling Multipart File Uploads
    - 18.4.6. Switch Off the Spring MVC DispatcherServlet
    - 18.4.7. Switch off the Default MVC Configuration
    - 18.4.8. Customize ViewResolvers
  - 18.5. Jersey
    - 18.5.1. Secure Jersey endpoints with Spring Security
    - 18.5.2. Use Jersey Alongside Another Web Framework 
  - 18.6. HTTP Clients
    - 18.6.1. Configure RestTemplate to Use a Proxy
    - 18.6.2. Configure the TcpClient used by a Reactor Netty-based WebClient
  - 18.7. Logging
    - 18.7.1. Configure Logback for Logging
      - Configure Logback for File-only Output
    - 18.7.2. Configure Log4j for Logging
      - Use YAML or JSON to Configure Log4j2
      - Use Composite Configuration to Configure Log4j2
  - 18.8. Data Access
    - 18.8.1. Configure a Custom DataSource
    - 18.8.2. Configure Two DataSources
    - 18.8.3. Use Spring Data Repositories
    - 18.8.4. Separate @Entity Definitions from Spring Configuration
    - 18.8.5. Configure JPA Properties
    - 18.8.6. Configure Hibernate Naming Strategy
    - 18.8.7. Configure Hibernate Second-Level Caching
    - 18.8.8. Use Dependency Injection in Hibernate Components
    - 18.8.9. Use a Custom EntityManagerFactory
    - 18.8.10. Using Multiple EntityManagerFactories
    - 18.8.11. Use a Traditional persistence.xml File
    - 18.8.12. Use Spring Data JPA and Mongo Repositories
    - 18.8.13. Customize Spring Data’s Web Support
    - 18.8.14. Expose Spring Data Repositories as REST Endpoint
    - 18.8.15. Configure a Component that is Used by JPA
    - 18.8.16. Configure jOOQ with Two DataSources
  - 18.9. Database Initialization
    - 18.9.1. Initialize a Database Using JPA
    - 18.9.2. Initialize a Database Using Hibernate
    - 18.9.3. Initialize a Database Using Basic SQL Scripts
    - 18.9.4. Initialize a Spring Batch Database
    - 18.9.5. Use a Higher-level Database Migration Tool
      - Execute Flyway Database Migrations on Startup
      - Execute Liquibase Database Migrations on Startup
    - 18.9.6. Depend Upon an Initialized Database
      - Detect a Database Initializer
      - Detect a Bean That Depends On Database Initialization
  - 18.10. NoSQL
    - 18.10.1. Use Jedis Instead of Lettuce
  - 18.11. Messaging
    - 18.11.1. Disable Transacted JMS Session
  - 18.12. Batch Applications
    - 18.12.1. Specifying a Batch Data Source
    - 18.12.2. Running Spring Batch Jobs on Startup
    - 18.12.3. Running From the Command Line
    - 18.12.4. Storing the Job Repository
  - 18.13. Actuator
    - 18.13.1. Change the HTTP Port or Address of the Actuator Endpoints
    - 18.13.2. Customize the ‘whitelabel’ Error Page
    - 18.13.3. Sanitize Sensitive Values
      - Customizing Sanitization
    - 18.13.4. Map Health Indicators to Micrometer Metrics
  - 18.14. Security
    - 18.14.1. Switch off the Spring Boot Security Configuration
    - 18.14.2. Change the UserDetailsService and Add User Accounts
    - 18.14.3. Enable HTTPS When Running behind a Proxy Server
  - 18.15. Hot Swapping
    - 18.15.1. Reload Static Content
    - 18.15.2. Reload Templates without Restarting the Container
      - Thymeleaf Templates
      - FreeMarker Templates
      - Groovy Templates
    - 18.15.3. Fast Application Restarts
    - 18.15.4. Reload Java Classes without Restarting the Container
  - 18.16. Testing
    - 18.16.1. Testing With Spring Security
    - 18.16.2. Structure @Configuration classes for inclusion in slice tests
  - 18.17. Build
    - 18.17.1. Generate Build Information
    - 18.17.2. Generate Git Information
    - 18.17.3. Customize Dependency Versions
    - 18.17.4. Create an Executable JAR with Maven
    - 18.17.5. Use a Spring Boot Application as a Dependency
    - 18.17.6. Extract Specific Libraries When an Executable Jar Runs
    - 18.17.7. Create a Non-executable JAR with Exclusions
    - 18.17.8. Remote Debug a Spring Boot Application Started with Maven
    - 18.17.9. Build an Executable Archive From Ant without Using spring-boot-antlib
  - 18.18. Ahead-of-time processing
    - 18.18.1. Conditions
  - 18.19. Traditional Deployment
    - 18.19.1. Create a Deployable War File
    - 18.19.2. Convert an Existing Application to Spring Boot
    - 18.19.3. Deploying a WAR to WebLogic
  - 18.20. Docker Compose
    - 18.20.1. Customizing the JDBC URL 

***


# 18. "사용" 가이드("How-to" Guides)
이 장에서는 스프링 부트를 사용할 때 자주 발생하는 몇 가지 일반적인 '어떻게 해야 하지...' 질문에 대한 답변을 제공한다. 완전하진 않지만 꽤 많은 부분을 커버하고 있다.

여기서 다루지 않은 특정 문제가 있는 경우 [stackoverflow.com](https://stackoverflow.com/tags/spring-boot)을 확인하여 누군가 이미 답변을 제공했는지 확인할 수 있다. 이곳은 새로운 질문을 하기에도 좋은 곳이다(`spring-boot` 태그를 사용하자).

우리는 또한 이 장을 확장할 수 있게 되어 매우 기쁘다. '사용 방법'을 추가하려면 [풀 리퀘스트](https://github.com/spring-projects/spring-boot/tree/v3.1.1)를 보내보자.


## 18.1. 스프링 부트 애플리케이션(Spring Boot Application)
이 장에는 스프링 부트 애플리케이션과 직접 관련된 토픽이 포함되어 있다.


### 18.1.1. 나만의 FailureAnalyzer 만들기(Create Your Own FailureAnalyzer)
`FailureAnalyzer`는 시작 시 예외를 가로채서 이를 사람이 읽을 수 있는 메시지로 변환하고 `FailureAnalytics`에 래핑하는 훌륭한 방법이다. 스프링 부트는 애플리케이션 컨텍스트 관련 예외, JSR-303 검증 등에 대한 분석기(analyzer)를 제공한다. 자신만의 것을 만들 수도 있다.

`AbstractFailureAnalyzer`는 처리할 예외에 지정된 예외 유형이 있는지 확인하는 `FailureAnalyzer`의 편리한 확장이다. 구현체가 실제로 존재할 때만 예외를 처리할 수 있도록 이를 확장할 수 있다. 어떤 이유로든 예외를 처리할 수 없는 경우 `null`을 반환하여 다른 구현체에서 예외를 처리할 수 있도록 한다.

`FailureAnalyzer` 구현체는 `META-INF/spring.factories`에 등록되어야 한다. 다음 예제에서는 `ProjectConstraintViolationFailureAnalyzer`를 등록한다.

```
org.springframework.boot.diagnostics.FailureAnalyzer=\
com.example.ProjectConstraintViolationFailureAnalyzer
```

{: .note }
`BeanFactory` 또는 `Environment`에 접근해야 하는 경우 FailureAnalyzer는 각각 `BeanFactoryAware` 또는 `EnvironmentAware`를 구현할 수 있다.


### 18.1.2. 자동 구성 문제 해결(Troubleshoot Auto-configuration)
스프링 부트 자동 구성은 "올바른 작업"을 수행하기 위해 최선을 다하지만 때로 작업이 실패하고 이유를 분명하게 확인하기 어려울 수 있다.

모든 스프링 부트 `ApplicationContext`에는 정말 유용한 `ConditionEvaluationReport`가 있다. `DEBUG` 로깅 출력을 활성화하면 이를 볼 수 있다. `spring-boot-actuator`([액추에이터 장 참고](/docs/spring_boot/3.1.1/spring_boot/13.production_ready_features/#13-%ED%94%84%EB%A1%9C%EB%8D%95%EC%85%98-%EC%A4%80%EB%B9%84-%EA%B8%B0%EB%8A%A5production-ready-features))를 사용하는 경우 보고서를 `JSON`으로 렌더링하는 조건 엔드포인트도 있다. 해당 엔드포인트를 사용하여 애플리케이션을 디버깅하고 런타임 시 스프링 부트에 의해 추가된 기능(및 추가되지 않은 기능)을 확인하자.

소스 코드와 자바독을 살펴보면 더 많은 질문에 대한 답을 얻을 수 있다. 코드를 읽을 때 다음 법칙을 기억하자.
- `*AutoConfiguration`이라는 클래스를 찾아 해당 소스를 읽어보자. 어떤 기능을 언제 활성화하는지 알아보려면 `@Conditional*` 어노테이션에 특별한 주의를 기울이자. 커맨드라인에서 `--debug`를 추가하거나 시스템 프로퍼티 `-Ddebug`를 추가하여 앱에서 이루어진 모든 자동 구성 결정에 대한 로그를 콘솔에 가져온다. 액추에이터가 활성화된 실행 중인 애플리케이션에서 동일한 정보를 보려면 `conditions` 엔드포인트(`/actuator/conditions` 또는 이에 상응하는 JMX)를 살펴보자.
- `@ConfigurationProperties`(예: `ServerProperties`)인 클래스를 찾아 거기에서 사용 가능한 외부 구성 옵션을 읽어보자. `@ConfigurationProperties` 어노테이션에는 외부 프로퍼티에 대한 접두사 역할을 하는 이름 애트리뷰트가 있다. 따라서, `ServerProperties`에는 `prefix="server"`가 있고 해당 프로퍼티는 `server.port`, `server.address` 등이다. 액추에이터가 활성화된 실행 중인 애플리케이션에서 `configprops` 엔드포인트를 살펴보자.
- 편리한 방식으로 `Environment`에서 구성 값을 명시적으로 가져오기 위해 `Binder`에서 `bind` 메서드를 사용하는 방법을 찾아보자. 접두사와 함께 사용되는 경우가 많다.
- `Environment`에 직접 바인딩되는 `@Value` 어노테이션을 찾아보자.
- SpEL 표현식에 대한 응답으로 기능을 켜고 끄는 `@ConditionalOnExpression` 어노테이션을 찾아보자. 일반적으로 환경에서 분석된 자리 표시자(placeholder)로 평가한다.


### 18.1.3. 시작하기 전 Environment 또는 ApplicationContext 커스텀(Customize the Environment or ApplicationContext Before It Starts)
`SpringApplication`에는 컨텍스트나 environment에 커스텀을 적용하는 데 사용되는 `ApplicationListener` 및 `ApplicationContextInitializer`가 있다. 스프링 부트는 `META-INF/spring.factories`에서 내부적으로 사용할 수 있도록 이러한 커스텀을 로드한다. 추가 커스텀을 등록하는 방법은 여러 가지가 있다.
- 프로그래밍 방식으로 애플리케이션별 `SpringApplication`을 실행하기 전에 `addListeners` 및 `addInitializers` 메서드를 호출한다.
- 선언적으로, 애플리케이션별 `context.initializer.classes` 또는 `context.listener.classes` 프로퍼티스를 설정한다.
- 선언적으로, 모든 애플리케이션에 대해 `META-INF/spring.factories`를 추가하고 모든 애플리케이션이 라이브러리로 사용하는 jar 파일에 패키징한다.

`SpringApplication`은 몇 가지 특별한 `ApplicationEvent`를 리스너(컨텍스트가 생성되기 전이라도)에 보낸 다음 `ApplicationContext`에 의해 게시된 이벤트에 대한 리스너를 등록한다. 전체 목록은 '스프링 부트 기능' 장의 '[애플리케이션 이벤트 및 리스너](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#717-application-events-and-listeners)'를 참고하자.

`EnvironmentPostProcessor`를 사용하여 애플리케이션 컨텍스트를 새로 고치기 전에 `Environment`을 커스텀하는 것도 가능하다. 다음 예제와 같이 각 구현체는 `META-INF/spring.factories`에 등록되어야 한다.

```
org.springframework.boot.env.EnvironmentPostProcessor=com.example.YourEnvironmentPostProcessor
```

구현 시 임의의 파일을 로드하고 `Environment`에 추가할 수 있다. 다음 예제에서는 클래스패스에서 YAML 구성 파일을 로드한다.

`자바`
```java
import java.io.IOException;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.env.EnvironmentPostProcessor;
import org.springframework.boot.env.YamlPropertySourceLoader;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.util.Assert;

public class MyEnvironmentPostProcessor implements EnvironmentPostProcessor {
  private final YamlPropertySourceLoader loader = new YamlPropertySourceLoader();
  @Override
  public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
    Resource path = new ClassPathResource("com/example/myapp/config.yml");
    PropertySource<?> propertySource = loadYaml(path);
    environment.getPropertySources().addLast(propertySource);
  }

  private PropertySource<?> loadYaml(Resource path) {
    Assert.isTrue(path.exists(), () -> "Resource " + path + " does not exist");
    try {
      return this.loader.load("custom-resource", path).get(0);
    } catch (IOException ex) {
      throw new IllegalStateException("Failed to load yaml configuration from " + path, ex); 
    }
  } 
}
```

`코틀린`
```kotlin
import org.springframework.boot.SpringApplication
import org.springframework.boot.env.EnvironmentPostProcessor
import org.springframework.boot.env.YamlPropertySourceLoader
import org.springframework.core.env.ConfigurableEnvironment
import org.springframework.core.env.PropertySource
import org.springframework.core.io.ClassPathResource
import org.springframework.core.io.Resource
import org.springframework.util.Assert
import java.io.IOException

class MyEnvironmentPostProcessor : EnvironmentPostProcessor {
  private val loader = YamlPropertySourceLoader()

  override fun postProcessEnvironment(environment: ConfigurableEnvironment, application: SpringApplication) {
    val path: Resource = ClassPathResource("com/example/myapp/config.yml")
    val propertySource = loadYaml(path)
    environment.propertySources.addLast(propertySource)
  }

  private fun loadYaml(path: Resource): PropertySource<*> {
    Assert.isTrue(path.exists()) { "Resource $path does not exist" }
    return try {
      loader.load("custom-resource", path)[0]
    } catch (ex: IOException) { 
      throw IllegalStateException("Failed to load yaml configuration from $path", ex) 
    }
  } 
}
```

{: .note }
`Environment`은 스프링 부트가 기본적으로 로드하는 모든 일반적인 프로퍼티 소스로 이미 준비되어 있다. 따라서 `Environment`에서 파일 위치를 얻는 것이 가능하다. 앞의 예제에서는 일반적으로 다른 위치에 정의된 키가 우선순위를 갖도록 리스트의 끝에 커스텀 리소스 프로퍼티 소스를 추가한다. 커스텀 구현체는 다른 순서를 정의할 수 있다.

{: .caution }
`@SpringBootApplication`에서 `@PropertySource`를 사용하는 것이 `Environment`에서 커스텀 리소스를 로드하는 편리한 방법으로 보일 수 있지만 권장하지는 않는다. 이러한 프로퍼티 소스는 애플리케이션 컨텍스트가 새로 고쳐질 때까지 `Environment`에 추가되지 않는다. 새로 고침이 시작되기 전에 읽혀지는 `logging.*` 및 `spring.main.*`과 같은 특정 프로퍼티를 구성하기에는 너무 늦다.


### 18.1.4. ApplicationContext 계층 구조 구축(상위 또는 루트 컨텍스트 추가)(Build an ApplicationContext Hierarchy (Adding a Parent or Root Context))
`ApplicationBuilder` 클래스를 사용하여 상위/하위 `ApplicationContext` 계층을 생성할 수 있다. 자세한 내용은 '스프링 부트 기능' 장의 '[Fluent Builder API](/docs/spring_boot/3.1.1/spring_boot/7.core_features/#715-fluent-builder-api)'를 참고하자.


### 18.1.5. 웹이 아닌 애플리케이션 만들기(Create a Non-web Application)

모든 스프링 애플리케이션이 웹 애플리케이션(또는 웹 서비스)일 필요는 없다. 메인 메서드에서 일부 코드를 실행하고 스프링 애플리케이션을 부트스트랩하여 사용할 인프라를 설정하려는 경우 스프링 부트의 `SpringApplication` 기능을 사용할 수 있다. `SpringApplication`은 웹 애플리케이션 필요 여부에 따라 `ApplicationContext` 클래스를 변경한다. 이를 돕기 위해 가장 먼저 할 수 있는 일은 서버 관련 의존성(예: 서블릿 API)을 클래스패스에서 벗어나게 하는 것이다. 그렇게 할 수 없는 경우(예를 들어 동일한 코드 베이스에서 두 개의 애플리케이션을 실행하는 경우) `SpringApplication` 인스턴스에서 명시적으로 `setWebApplicationType(WebApplicationType.NONE)`을 호출하거나 (자바 API 또는 외부 속성을 통해) `applicationContextClass` 프로퍼티를 설정할 수 있다. 비즈니스 로직으로 실행하려는 애플리케이션 코드는 `CommandLineRunner`로 구현되고 `@Bean` 정의로 컨텍스트에 놓을 수 있다.