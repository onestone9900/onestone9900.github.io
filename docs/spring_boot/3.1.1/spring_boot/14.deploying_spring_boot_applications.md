---
layout: default
title: 14. 스프링 부트 애플리케이션 배포(Deploying Spring Boot Applications)
parent: SpringBootReference
grand_parent: 3.1.1
nav_order: 14
---

[원문 - Deploying Spring Boot Applications](https://docs.spring.io/spring-boot/docs/3.1.1/reference/html/deployment.html#deployment)

***

- 14 스프링 부트 애플리케이션 배포(Deploying Spring Boot Applications)
    - 14.1. 클라우드에 배포(Deploying to the Cloud)
      - 14.1.1. 클라우드 파운드리(Cloud Foundry)
        - 서비스에 바인딩(Binding to Services)
      - 14.1.2. 쿠버네티스(Kubernetes)
        - 쿠버네티스 컨테이너 생명주기(Kubernetes Container Lifecycle)
      - 14.1.3. 헤로쿠(Heroku)
      - 14.1.4. 오픈시프트(OpenShift)
      - 14.1.5. 아마존 웹 서비스(Amazon Web Services (AWS))
        - AWS 엘라스틱 빈스토크(AWS Elastic Beanstalk)
        - 요약(Summary)
      - 14.1.6. 클라우드캡틴과 아마존 웹 서비스(CloudCaptain and Amazon Web Services)
      - 14.1.7. 애저(Azure)
      - 14.1.8. 구글 클라우드(Google Cloud)
    - 14.2. Installing Spring Boot Applications
      - 14.2.1. Supported Operating Systems
      - 14.2.2. Unix/Linux Services
        - Installation as an init.d Service (System V)
        - Installation as a systemd Service
        - Customizing the Startup Script
      - 14.2.3. Microsoft Windows Services
    - 14.3. Efficient deployments
      - 14.3.1. Unpacking the Executable JAR
      - 14.3.2. Using Ahead-of-time Processing With the JVM
    - 14.4. What to Read Next
***


# 14. 스프링 부트 애플리케이션 배포(Deploying Spring Boot Applications)
스프링 부트의 유연한 패키징 옵션은 애플리케이션 배포 시 다양한 선택사항을 제공한다. 스프링 부트 애플리케이션을 다양한 클라우드 플랫폼, 가상/실제 머신에 배포하거나 유닉스 시스템에서 완전히 실행 가능하도록 만들 수 있다.

이 섹션에서는 보다 일반적인 배포 시나리오 중 일부를 다룬다.


## 14.1. 클라우드에 배포(Deploying to the Cloud)
스프링 부트의 실행 가능한(executable) jar는 가장 널리 사용되는 클라우드 PaaS(Platform-as-a-Service) 제공업체를 위해 미리 만들어졌다. 이러한 공급자(provider)는 "컨테이너를를 가져오라"고 요구하는 경향이 있다. 애플리케이션 프로세스(특히 자바 애플리케이션 아닌)를 관리하므로 애플리케이션을 실행 중인 프로세스에 대한 클라우드의 개념에 맞게 조정하는 중간 계층이 필요하다.

인기 있는 두 클라우드 제공업체인 헤로쿠(Heroku)와 클라우드 파운드리(Cloud Foundry)는 "빌드팩" 접근 방식을 사용한다. 빌드팩은 애플리케이션을 시작하는 데 필요한 모든 항목에 배포된 코드를 래핑한다. 이는 JDK 및 자바 호출, 임베디드 웹 서버 또는 완전한 애플리케이션 서버일 수 있다. 빌드팩은 플러그인화가 가능하지만, 이상적으로 가능한 한 적은 수의 커스텀만으로 사용할 수 있어야 한다. 이렇게 하면 사용자가 제어할 수 없는 기능의 공간이 줄어듭니다. 개발 환경과 프로덕션 환경 간의 차이를 최소화한다.

이상적으로는, 스프링 부트의 실행 가능 jar과 같은 애플리케이션에 실행하는 데 필요한 모든 것이 패키지로 포함되어 있다.

이 장에서는 "시작하기" 장에서 개발한 애플리케이션을 클라우드에서 실행하는 데 필요한 사항을 살펴보자.


### 14.1.1. 클라우드 파운드리(Cloud Foundry)
클라우드 파운드리(Cloud Foundry)는 다른 빌드팩이 지정되지 않은 경우 작동하는 기본 빌드팩을 제공한다. 클라우드 파운드리 [자바 빌드팩](https://github.com/cloudfoundry/java-buildpack)은 스프링 부트를 포함하여 스프링 애플리케이션을 훌륭하게 지원한다. 독립형 실행 가능 jar 애플리케이션은 물론 기존 .war 패키지 애플리케이션도 배포할 수 있다.

애플리케이션을 빌드하고(예: mvn clean 패키지 사용) cf 명령줄 도구를 설치한 후 `cf push` 명령을 사용하여 애플리케이션을 배포하고 경로를 컴파일된 `.jar`로 대체한다. 애플리케이션을 푸시하기 전에 `cf` 명령줄 클라이언트로 로그인했는지 확인하자. 다음 줄은 `cf push` 명령을 사용하여 애플리케이션을 배포하는 방법을 보여준다.

```shell
$ cf push acloudyspringtime -p target/demo-0.0.1-SNAPSHOT.jar
```

{: .note}
앞의 예제에서, 애플리케이션명으로 `cf`에 지정한 값을 `acloudyspringtime`으로 대체한다.

더 많은 옵션을 보려면 cf push 문서를 참고하자. 동일한 디렉터리에 클라우드 파운드리 manifest.yml 파일이 있으면 이를 고려하자.

이 시점에서, cf는 애플리케이션 업로드를 시작하고 다음 예와 유사한 출력을 생성한다.

```
Uploading acloudyspringtime... OK
Preparing to start acloudyspringtime... OK
-----> Downloaded app package (8.9M)
-----> Java Buildpack Version: v3.12 (offline) | https://github.com/cloudfoundry/java- buildpack.git#6f25b7e
-----> Downloading Open Jdk JRE
         Expanding Open Jdk JRE to .java-buildpack/open_jdk_jre (1.6s)
  -----> Downloading Open JDK Like Memory Calculator 2.0.2_RELEASE from https://java-
  buildpack.cloudfoundry.org/memory-calculator/trusty/x86_64/memory-calculator-
  2.0.2_RELEASE.tar.gz (found in cache)
         Memory Settings: -Xss349K -Xmx681574K -XX:MaxMetaspaceSize=104857K -Xms681574K
  -XX:MetaspaceSize=104857K
  -----> Downloading Container Certificate Trust Store 1.0.0_RELEASE from https://java-
  buildpack.cloudfoundry.org/container-certificate-trust-store/container-certificate-
  trust-store-1.0.0_RELEASE.jar (found in cache)
         Adding certificates to .java-
  buildpack/container_certificate_trust_store/truststore.jks (0.6s)
  -----> Downloading Spring Auto Reconfiguration 1.10.0_RELEASE from https://java-
  buildpack.cloudfoundry.org/auto-reconfiguration/auto-reconfiguration-
  1.10.0_RELEASE.jar (found in cache)
  Checking status of app 'acloudyspringtime'...
    0 of 1 instances running (1 starting)
    ...
    0 of 1 instances running (1 starting)
    ...
    0 of 1 instances running (1 starting)
    ...
    1 of 1 instances running (1 running)
App started
```

축하한다! 이제 애플리케이션이 활성화됐다!

애플리케이션이 활성화되면 다음 예와 같이 `cf apps` 명령을 사용하여 배포된 애플리케이션의 상태를 확인할 수 있다.

```
$ cf apps
Getting applications in ...
OK

name                        requested state instances memory  disk urls
...
acloudyspringtime           started         1/1       512M    1G
acloudyspringtime.cfapps.io
...
```

클라우드 파운드리(Cloud Foundry)가 애플리케이션이 배포되었음을 확인하면 지정된 URI에서 애플리케이션을 찾을 수 있다. 앞의 예제에서 `https://acloudyspringtime.cfapps.io/`에서 찾을 수 있다.


#### 서비스에 바인딩(Binding to Services)
기본적으로 실행 중인 애플리케이션에 대한 메타데이터와 서비스 연결 정보는 애플리케이션에 환경 변수(예: $VCAP_SERVICES)로 노출된다. 이 아키텍처 결정은 클라우드 파운드리(Cloud Foundry)의 다중 언어(모든 언어 및 플랫폼이 빌드팩으로 지원될 수 있음) 특성 때문이다. 프로세스 범위 환경 변수는 언어에 구애받지 않는다.

환경 변수가 항상 가장 쉬운 API를 제공하는 것은 아니므로 스프링 부트는 다음 예제와 같이 자동으로 이를 추출하고 스프링의 환경 추상화를 통해 접근할 수 있는 프로퍼티스로 데이터를 평면화한다.

`자바`
```java
import org.springframework.context.EnvironmentAware;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;

@Component
public class MyBean implements EnvironmentAware {
    
    private String instanceId;
    
    @Override
    public void setEnvironment(Environment environment) {
      this.instanceId = environment.getProperty("vcap.application.instance_id");
    }

    // ... 
}
```

`코틀린`
```kotlin
import org.springframework.context.EnvironmentAware
import org.springframework.core.env.Environment
import org.springframework.stereotype.Component

@Component
class MyBean : EnvironmentAware {
    
  private var instanceId: String? = null

  override fun setEnvironment(environment: Environment) {
    instanceId = environment.getProperty("vcap.application.instance_id")
  }
  // ... 
}
```

모든 클라우드 파운드리(Cloud Foundry) 프로퍼티에는 `vcap` 접두사가 붙는다. `vcap` 프로퍼티들을 사용하여 애플리케이션 정보(예: 애플리케이션의 공개 URL) 및 서비스 정보(예: 데이터베이스 자격 증명)에 접근할 수 있다. 자세한 내용은 `CloudFoundryVcapEnvironmentPostProcessor` 자바독(Javadoc)을 참고하자.

{: .note}
자바 `CFEnv` 프로젝트는 `DataSource` 구성과 같은 작업에 더 적합하다.


### 14.1.2. 쿠버네티스
스프링 부트는 "`*_SERVICE_HOST`" 및 "`*_SERVICE_PORT`" 변수에 대한 환경을 확인하여 쿠버네티스 배포 환경을 자동 감지한다. `spring.main.cloud-platform` 구성 프로퍼티를 사용하여 이 감지를 오바리이드할 수 있다.

스프링 부트를 사용하면 애플리케이션 상태를 관리하고 액추에이터를 사용하여 HTTP 쿠버네티스 프로브로 내보낼 수 있다.


#### 쿠버네티스 컨테이너 생명주기(Kubernetes Container Lifecycle)
쿠버네티스가 애플리케이션 인스턴스를 삭제할 때, 종료 프로세스에는 종료 후크, 서비스 등록 취소, 로드 밸런서에서 인스턴스 제거 등 여러 하위 시스템이 동시에 포함된다. 왜냐하면 분산 시스템의 특성으로 인해 이 종료 처리는 병렬로 발생하기 때문이다. 종료 처리를 시작한 파드로 트래픽을 라우팅할 수 있는 기간이 있다.

이미 종료가 시작된 파드로 요청이 라우팅되는 것을 방지하기 위해 `preStop` 핸들러에서 절전(sleep)을 구성할 수 있다. 이 절전 모드는 새 요청이 파드로 라우팅되는 것을 중지할 만큼 충분히 길어야 하며 해당 기간은 배포마다 다르다. `preStop` 핸들러는 다음과 같이 파드 구성 파일의 `PodSpec`을 사용하여 구성할 수 있다.

```
spec:
  containers:
  - name: "example-container"
    image: "example-image"
    lifecycle:
      preStop:
        exec:
          command: ["sh", "-c", "sleep 10"]
```

사전 중지(pre-stop) 후크가 완료되면 `SIGTERM`이 컨테이너로 전송되고 정상적인 종료가 시작되어 나머지 진행 중인 요청이 완료될 수 있다.

{: .note}
쿠버네티스가 `SIGTERM` 신호를 파드에 보내면 종료 유예 기간(기본값은 30초)이라는 지정된 시간 동안 기다린다. 유예 기간 후에도 컨테이너가 계속 실행 중인 경우 `SIGKILL` 신호가 전송되고 강제로 제거된다. `spring.lifecycle.timeout-per-shutdown-phase`를 늘렸기 때문에 파드를 종료하는 데 30초 이상 걸리는 경우 파드 YAML에서 `shutdownGracePeriodSeconds` 옵션을 설정하여 종료 유예 기간을 늘려야 한다.


### 14.1.3. 헤로쿠(Heroku)
헤로쿠는 또 다른 인기 있는 PaaS 플랫폼이다. 헤로쿠(Heroku) 빌드를 커스텀하려면 애플리케이션을 배포하는 데 필요한 명령을 제공하는 `Procfile`을 제공한다. 헤로쿠(Heroku)는 자바 애플리케이션이 사용할 포트를 할당한 다음 외부 URI로의 라우팅이 작동하는지 확인한다.

올바른 포트에서 수신하도록 애플리케이션을 구성해야 한다. 다음 예제는 스타터 REST 애플리케이션에 대한 `Procfile`을 보여준다.

```
web: java -Dserver.port=$PORT -jar target/demo-0.0.1-SNAPSHOT.jar
```

스프링 부트에서는 `-D` 아규먼트를 스프링 환경 인스턴스에서 접근할 수 있는 프로퍼티로 사용할 수 있다. `server.port` 프로퍼티는 임베디드 톰캣, 제티 또는 언더토우 인스턴스에 제공되며, 시작 시 해당 포트를 사용한다. `$PORT` 환경 변수는 헤로쿠 PaaS에 의해 우리에게 할당된다.

이것이 필요한 전부다. 헤로쿠 배포의 가장 일반적인 배포 워크플로는 다음 예제와 같이 코드를 프로덕션에 `git push`하는 것이다.

```
$ git push heroku main
```

결과는 다음과 같다.

```
Initializing repository, done.
Counting objects: 95, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (78/78), done.
Writing objects: 100% (95/95), 8.66 MiB | 606.00 KiB/s, done. Total 95 (delta 31), reused 0 (delta 0)
-----> Java app detected
-----> Installing OpenJDK... done
-----> Installing Maven... done
-----> Installing settings.xml... done
-----> Executing: mvn -B -DskipTests=true clean install

         [INFO] Scanning for projects...
         Downloading: https://repo.spring.io/...
         Downloaded: https://repo.spring.io/... (818 B at 1.8 KB/sec)
....
Downloaded: https://s3pository.heroku.com/jvm/... (152 KB at 595.3 KB/sec) [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/target/... [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/pom.xml ... [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------ [INFO] Total time: 59.358s
[INFO] Finished at: Fri Mar 07 07:28:25 UTC 2014
[INFO] Final Memory: 20M/493M
[INFO] ------------------------------------------------------------------------

-----> Discovering process types Procfile declares types -> web

-----> Compressing... done, 70.4MB -----> Launching... done, v6
https://agile-sierra-1405.herokuapp.com/ deployed to Heroku To git@heroku.com:agile-sierra-1405.git

   * [new branch]      main -> main
```

이제 귀하의 애플리케이션이 헤로쿠에서 실행될 것이다. 자세한 내용은 [헤로쿠에 스프링 부트 애플리케이션 배포]를(https://devcenter.heroku.com/articles/deploying-spring-boot-apps-to-heroku) 참고하자.


### 14.1.4. 오픈시프트(OpenShift)
OpenShift has many resources describing how to deploy Spring Boot applications, including:

- [S2I 빌더 사용(Using the S2I builder)](https://cloud.redhat.com/blog/using-openshift-enterprise-grade-spring-boot-deployments)
- [아키텍처 가이드(Architecture guide)](https://access.redhat.com/documentation/en-us/reference_architectures/2017/html-single/spring_boot_microservices_on_red_hat_openshift_container_platform_3/)
- [와일드플라이에서 기존 웹 애플리케이션으로 실행(Running as a traditional web application on Wildfly)](https://cloud.redhat.com/blog/using-spring-boot-on-openshift)
- [오픈시프트 커먼 브리핑(OpenShift Commons Briefing)](https://cloud.redhat.com/blog/openshift-commons-briefing-96-cloud-native-applications-spring-rhoar)


### 14.1.5. 아마존 웹 서비스(Amazon Web Services (AWS))
아마존 웹 서비스는 기존 웹 애플리케이션(war) 또는 임베디드 웹 서버가 있는 실행 가능한 jar 파일 등 스프링 부트 기반 애플리케이션을 설치하는 다양한 방법을 제공한다. 옵션은 다음과 같다.

- AWS 엘라스틱 빈스토크(AWS Elastic Beanstalk)
- AWS 코드 디플로이(AWS Code Deploy)
- AWS OPS 워크(AWS OPS Works)
- AWS 클라우드 포메이션(AWS Cloud Formation)
- AWS 컨테이너 레지스트리(AWS Container Registry)

각각은 서로 다른 기능과 가격 모델을 가지고 있다. 이 문서에서는 AWS 엘라스틱 빈스토크를 사용하여 접근하는 방법을 설명한다.


#### AWS 엘라스틱 빈스토크(AWS Elastic Beanstalk)
공식 [엘라스틱 빈스토크 자바 가이드](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_Java.html)에 설명된 대로 자바 애플리케이션을 배포하는 데는 두 가지 주요 옵션이 있다. "톰캣 플랫폼" 또는 "자바 SE 플랫폼"을 사용할 수 있다.


##### 톰캣 플랫폼 사용
이 옵션은 `war` 파일을 생성하는 스프링 부트 프로젝트에 적용된다. 특별한 구성이 필요하지 않다. 공식 가이드를 따르기만 하면 된다.


##### 자바 SE 플랫폼 사용
이 옵션은 `jar` 파일을 생성하고 내장된 웹 컨테이너를 실행하는 스프링 부트 프로젝트에 적용된다. 엘라스틱 빈스토크 환경은 포트 5000에서 실행되는 실제 애플리케이션을 프록시하기 위해 포트 80에서 엔진엑스(nginx) 인스턴스를 실행한다. 이를 구성하려면 `application.properties` 파일에 다음 줄을 추가한다.

```
server.port=5000
```

---

<B>팁</B>

소스 대신 바이너리 업로드를 기본으로 사용하며, 엘라스틱 빈스토크에 소스를 업로드하면 AWS에서 컴파일한다. 그러나 바이너리를 업로드하는 것이 가장 좋다. 이렇게 하려면 `.elasticbeanstalk/config.yml` 파일에 다음내용을 추가하자.

```
deploy:
  artifact: target/demo-0.0.1-SNAPSHOT.jar
```

환경 타입 설정을 통한 비용 절감


기본적으로 엘라스틱 빈스토크 환경은 로드 밸런싱된다. 로드 밸런서는 상당한 비용이 든다. 이러한 비용을 피하려면 [아마존 문서](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-create-wizard.html#environments-create-wizard-capacity)에 설명된 대로 환경 타입을 "단일 인스턴스"로 설정하자. CLI와 다음 명령을 사용하여 단일 인스턴스 환경을 생성할 수도 있다.

```
eb create -s
```

---


#### 요약(Summary)
이는 AWS에 접근하는 가장 쉬운 방법 중 하나이지만 엘라스틱 빈스토크를 CI/CD 도구에 통합하는 방법, CLI 대신 엘라스틱 빈스토크 메이븐 플러그인을 사용하는 방법 등 다루어야 할 사항이 더 많다. 이러한 주제를 더 자세히 다루는 [블로그 게시물](https://exampledriven.wordpress.com/2017/01/09/spring-boot-aws-elastic-beanstalk-example/)이 있다.


### 14.1.6. 클라우드캡틴과 아마존 웹 서비스(CloudCaptain and Amazon Web Services)
[클라우드캡틴(CloudCaptain)](https://cloudcaptain.sh/)은 스프링 부트 실행 가능 jar 또는 war를 버추얼박스 또는 AWS에서 변경 없이 배포할 수 있는 최소 VM 이미지로 전환하여 작동한다. 클라우드캡틴(CloudCaptain)은 스프링 부트와 긴밀하게 통합되어 제공되며 스프링 부트 구성 파일의 정보를 사용하여 포트 및 상태 확인 URL을 자동 구성한다. 클라우드캡틴은 생성하는 이미지는 물론 프로비저닝하는 모든 리소스(인스턴스, 보안 그룹, 탄력적 로드 밸런서 등)에 대해 이 정보를 활용한다.

[클라우드캡틴 계정](https://console.cloudcaptain.sh/)을 생성하고, 이를 AWS 계정에 연결하고, 최신 버전의 클라우드캡틴 클라이언트를 설치하고, 애플리케이션이 메이븐 또는 그레이들에서 빌드되었는지 확인했다면(예: mvn clean 패키지 사용) 다음 내용을 수행할 수 있다. 다음과 유사한 명령을 사용하여 스프링 부트 애플리케이션을 AWS에 배포한다.

```
$ boxfuse run myapp-1.0.jar -env=prod
```

더 많은 옵션을 보려면 `boxfuse run` [문서](https://cloudcaptain.sh/docs/commandline/run.html)를 참고하자. 현재 디렉터리에 `boxfuse.conf` 파일이 있으면 이를 고려한다.

{: .note}
기본적으로, 클라우드캡틴(CloudCaptain)은 시작 시 `boxfuse`라는 스프링 프로필을 활성화한다. 실행 가능한 jar 또는 war에 `application-boxfuse.properties` 파일이 포함된 경우 클라우드캡틴은 포함된 프로퍼티를 기반으로 구성한다.

이 시점에서 클라우드캡틴은 애플리케이션용 이미지를 생성하여 업로드하고 AWS에서 필요한 리소스를 구성 및 시작하여 다음 예제와 유사한 출력을 생성한다.

```
Fusing Image for myapp-1.0.jar ...
Image fused in 00:06.838s (53937 K) -> axelfontaine/myapp:1.0
Creating axelfontaine/myapp ...
Pushing axelfontaine/myapp:1.0 ...
Verifying axelfontaine/myapp:1.0 ...
Creating Elastic IP ...
Mapping myapp-axelfontaine.boxfuse.io to 52.28.233.167 ...
Waiting for AWS to create an AMI for axelfontaine/myapp:1.0 in eu-central-1 (this may
take up to 50 seconds) ...
AMI created in 00:23.557s -> ami-d23f38cf
Creating security group boxfuse-sg_axelfontaine/myapp:1.0 ...
Launching t2.micro instance of axelfontaine/myapp:1.0 (ami-d23f38cf) in eu-central-1
...
Instance launched in 00:30.306s -> i-92ef9f53
Waiting for AWS to boot Instance i-92ef9f53 and Payload to start at
https://52.28.235.61/ ...
Payload started in 00:29.266s -> https://52.28.235.61/
Remapping Elastic IP 52.28.233.167 to i-92ef9f53 ...
Waiting 15s for AWS to complete Elastic IP Zero Downtime transition ...
Deployment completed successfully. axelfontaine/myapp:1.0 is up and running at
https://myapp-axelfontaine.boxfuse.io/
```

이제 애플리케이션이 AWS에서 실행될 것이다.

앱을 실행하기 위해 메이븐 빌드를 시작하려면 [EC2에 스프링 부트 앱 배포](https://cloudcaptain.sh/blog/spring-boot-ec2.html)에 대한 블로그 게시물과 [클라우드캡틴 스프링 부트 인테그레이션](https://cloudcaptain.sh/docs/payloads/springboot.html)에 대한 설명서를 참고하자.


### 14.1.7. 애저(Azure)
이 [시작 가이드](https://spring.io/guides/gs/spring-boot-for-azure/)에서는 스프링 부트 애플리케이션을 에저 [스프링 클라우드](https://azure.microsoft.com/en-us/products/spring-apps/) 또는 [애저 앱 서비스](https://learn.microsoft.com/en-us/azure/app-service/overview)에 배포하는 과정을 안내한다.


### 14.1.8. 구글 클라우드(Google Cloud)
GCP에는 스프링 부트 애플리케이션을 시작하는 데 사용할 수 있는 여러 옵션이 있다. 시작하기 가장 쉬운 방법은 아마도 앱 엔진(App Engine)일 것이다. 그러나 컨테이너 엔진이 있는 컨테이너나 컴퓨트 엔진이 있는 가상 머신에서 스프링 부트를 실행하는 방법을 찾을 수도 있다.

앱 엔진에서 실행하려면 먼저 UI에서 프로젝트를 생성하면 된다. 그러면 고유 식별자가 설정되고 HTTP 경로도 설정된다. 프로젝트에 자바 앱을 추가하고 비워 둔 다음 [구글 클라우드 SDK](https://cloud.google.com/sdk/install)를 사용하여 커맨드라인 또는 CI 빌드에서 해당 슬롯에 스프링 부트 앱을 푸시한다.

앱 엔진 표준에서는 WAR 패키징을 사용해야 한다. 앱 엔진 표준 애플리케이션을 구글 클라우드에 배포하려면 [다음 단계](https://github.com/GoogleCloudPlatform/java-docs-samples/tree/master/appengine-java8/springboot-helloworld/README.md)를 따르자.

또는, 앱 엔진 플럭스(App Engine Flex)를 사용하려면 앱에 필요한 리소스를 설명하는 `app.yaml` 파일을 만들어야 한다. 일반적으로 이 파일은 `src/main/appengine`에 저장되며 다음 파일과 유사해야 한다.

```
service: "default"

runtime: "java"
env: "flex"

runtime_config:
  jdk: "openjdk8"

handlers:
- url: "/.*"
  script: "this field is required, but ignored"

manual_scaling:
  instances: 1

health_check:
  enable_health_check: false

env_variables:
  ENCRYPT_KEY: "your_encryption_key_here"
```

다음 예제와 같이 빌드 구성에 프로젝트 ID를 추가하여 앱을 배포할 수 있다(예: 메이븐 플러그인 사용).

```
<plugin>
  <groupId>com.google.cloud.tools</groupId>
  <artifactId>appengine-maven-plugin</artifactId>
  <version>1.3.0</version>
  <configuration>
      <project>myproject</project>
  </configuration>
</plugin>
```

그런 다음 `mvn appengine:deploy`를 사용하여 배포한다(먼저 인증해야 합니다. 그렇지 않으면 빌드가 실패한다).
