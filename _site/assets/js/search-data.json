{"0": {
    "doc": "GradlePlugin",
    "title": "Spring Boot Gradle Plugin Reference Guide",
    "content": "Andy Wilkinson, Scott Frederick Version 2.7.12 . 원문 . ",
    "url": "/docs/2.7.12/gradle_plugin/0.%20gradle_plugin/#spring-boot-gradle-plugin-reference-guide",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/0.%20gradle_plugin/#spring-boot-gradle-plugin-reference-guide"
  },"1": {
    "doc": "GradlePlugin",
    "title": "GradlePlugin",
    "content": " ",
    "url": "/docs/2.7.12/gradle_plugin/0.%20gradle_plugin/",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/0.%20gradle_plugin/"
  },"2": {
    "doc": "SpringBoot",
    "title": "Spring Boot Reference Documentation",
    "content": "Phillip Webb, Dave Syer, Josh Long, Stéphane Nicoll, Rob Winch, Andy Wilkinson, Marcel Overdijk, Christian Dupuis, Sébastien Deleuze, Michael Simons, Vedran Pavić, Jay Bryant, Madhura Bhave, Eddú Meléndez, Scott Frederick, Moritz Halbritter Version 2.7.12 . ",
    "url": "/docs/2.7.12/spring_boot/0.%20spring_boot/#spring-boot-reference-documentation",
    
    "relUrl": "/docs/2.7.12/spring_boot/0.%20spring_boot/#spring-boot-reference-documentation"
  },"3": {
    "doc": "SpringBoot",
    "title": "SpringBoot",
    "content": " ",
    "url": "/docs/2.7.12/spring_boot/0.%20spring_boot/",
    
    "relUrl": "/docs/2.7.12/spring_boot/0.%20spring_boot/"
  },"4": {
    "doc": "1. Introduction",
    "title": "1. Introduction",
    "content": "그레이들(Gradle)은 스프링 부트 지원을 위해 스프링 부트 그레이들 플러그인을 제공한다. 이를 통해 실행 가능한 jar 또는 war 압축파일을 패키징하고, 스프링 부트 애플리케이션을 실행하며,spring-boot-dependencies가 제공하는 의존성 관리를 사용할 수 있다. 스프링 부트의 그레이들 플러그인에는 그레이들 6.8, 6.9, 7.x 또는 8.x가 필요하며 그레이들 구성 캐시를 사용할 수 있다. 이 사용 설명서 외에, API 문서도 제공한다. ",
    "url": "/docs/2.7.12/gradle_plugin/1.%20introduction/",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/1.%20introduction/"
  },"5": {
    "doc": "1. Legal",
    "title": "Legal",
    "content": "Copyright © 2012-2023 . Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically. ",
    "url": "/docs/2.7.12/spring_boot/1.%20legal/#legal",
    
    "relUrl": "/docs/2.7.12/spring_boot/1.%20legal/#legal"
  },"6": {
    "doc": "1. Legal",
    "title": "1. Legal",
    "content": " ",
    "url": "/docs/2.7.12/spring_boot/1.%20legal/",
    
    "relUrl": "/docs/2.7.12/spring_boot/1.%20legal/"
  },"7": {
    "doc": "2. Getting Help",
    "title": "Getting Help",
    "content": "If you have trouble with Spring Boot, we would like to help. Try the How-to documents. They provide solutions to the most common questions. Learn the Spring basics. Spring Boot builds on many other Spring projects. Check the spring.io web-site for a wealth of reference documentation. If you are starting out with Spring, try one of the guides. Ask a question. We monitor stackoverflow.com for questions tagged with spring-boot. Report bugs with Spring Boot at github.com/spring-projects/spring-boot/issues. All of Spring Boot is open source, including the documentation. If you find problems with the docs or if you want to improve them, please get involved. ",
    "url": "/docs/2.7.12/spring_boot/2.%20getting-help/#getting-help",
    
    "relUrl": "/docs/2.7.12/spring_boot/2.%20getting-help/#getting-help"
  },"8": {
    "doc": "2. Getting Help",
    "title": "2. Getting Help",
    "content": " ",
    "url": "/docs/2.7.12/spring_boot/2.%20getting-help/",
    
    "relUrl": "/docs/2.7.12/spring_boot/2.%20getting-help/"
  },"9": {
    "doc": "2. Getting Started",
    "title": "2. Getting Started",
    "content": "프로젝트에 플러그인을 적용해보자. 플러그인은 그레이들 플러그인 포털에 게시되며 plugins 블록을 사용하여 적용할 수 있다: . Groovy . plugins { id 'org.springframework.boot' version '2.7.12' } . Kotlin . plugins { id(\"org.springframework.boot\") version \"2.7.12\" } . 별도 플러그인은 프로젝트를 거의 변경하지 않는다. 그러나, 특정 플러그인이 적용될 때는 감지하고 반응한다. 예를 들어, java 플러그인이 적용되면 실행 가능한 jar(executable jar)를 빌드(build)하는 작업이 자동으로 구성된다. 일반적인 스프링 부트 프로젝트는 groovy, java 또는 org.jetbrains.kotlin.jvm 플러그인을 최소한으로 적용하고 의존성 관리를 위해 io.spring.dependency-management 플러그인 또는 그레이들의 기본 bom 지원도 사용한다. 코드 예시: . Groovy . plugins { id 'java' id 'org.springframework.boot' version '2.7.12' } apply plugin: 'io.spring.dependency-management' . Kotlin . plugins { java id(\"org.springframework.boot\") version \"2.7.12\" } apply(plugin = \"io.spring.dependency-management\") . 다른 플러그인이 적용될 때 스프링 부트 플러그인이 어떻게 작동하는지 자세히 알아보려면 Reacting to Other Plugins섹션 을 참고해보자. ",
    "url": "/docs/2.7.12/gradle_plugin/2.%20getting_started/",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/2.%20getting_started/"
  },"10": {
    "doc": "3. Managing Dependencies",
    "title": "3. Managing Dependencies",
    "content": "스프링 부트 애플리케이션에서 의존성을 관리하려면, io.spring.dependency-management 플러그인을 적용하거나 그레이들의 기본 bom 지원을 사용할 수 있다. 전자의 주요 이점은 프로퍼티 기반의 맞춤 관리 버전을 제공하는 반면, 후자를 사용하면 빌드 속도가 빨라질 가능성이 높다. ",
    "url": "/docs/2.7.12/gradle_plugin/3.%20managing_dependencies/",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/3.%20managing_dependencies/"
  },"11": {
    "doc": "3. Managing Dependencies",
    "title": "3.1. Managing Dependencies with the Dependency Management Plugin",
    "content": "io.spring.dependency-management 플러그인을 적용하면 스프링 부트 플러그인이 자동으로 사용 중인 스프링 부트 버전에서 spring-boot-dependencies bom을 가져온다. 이는 메이븐(Maven) 사용자가 즐겨 사용하는 방식과 유사한 의존성 관리 경험을 제공한다. 예를 들어, bom에서 관리되는 의존성을 선언할 때 버전을 생략할 수 있다. 이 기능을 사용하려면, 의존성을 선언하고 버전은 생략하면 된다: . Groovy . dependencies { implementation('org.springframework.boot:spring-boot-starter-web') implementation('org.springframework.boot:spring-boot-starter-data-jpa') } . Kotlin . dependencies { implementation(\"org.springframework.boot:spring-boot-starter-web\") implementation(\"org.springframework.boot:spring-boot-starter-data-jpa\") } . 3.1.1. Customizing Managed Versions . 의존성 관리 플러그인 적용 시 자동으로 가져오는 spring-boot-dependencies bom은 프로퍼티를 사용하여 관리하는 의존성 버전을 제어한다. 이런 프로퍼티의 전체 목록을 보려면 스프링 부트 레퍼런스에서 의존성 버전 부록을 참고하자. 관리되는 버전을 사용자 정의하려면 해당 프로퍼티를 설정한다. 예를 들어, slf4j.version 프로퍼티에 의해 제어되는 SLF4J의 버전을 사용자 정의할 수 있다: . Groovy . ext['slf4j.version'] = '1.7.20' . Kotlin . extra[\"slf4j.version\"] = \"1.7.20\" . 각 스프링 부트 릴리스는 서드-파티 라이브러리 의존성에 대한 설계 및 테스트를 했다. 버전을 재정의하면 호환성 문제가 발생할 수 있으므로 주의해야 한다. 3.1.2. Using Spring Boot’s Dependency Management in Isolation . 스프링 부트 플러그인을 해당 프로젝트에 적용하지 않고 해당 프로젝트에서 스프링 부트 의존성 관리를 사용할 수 있다. SpringBootPlugin 클래스는 그룹 ID, 아티팩트 ID 또는 버전을 몰라도 bom을 가져오는 데 사용할 수 있는 BOM_COORDINATES 상수를 제공한다. 먼저, 스프링 부트 플러그인에 의존하도록 프로젝트를 구성하되 적용(apply)하지는 말자: . Groovy . plugins { id 'org.springframework.boot' version '2.7.12' apply false } . Kotlin . plugins { id(\"org.springframework.boot\") version \"2.7.12\" apply false } . 스프링 부트 플러그인의 의존성이란 의존성 관리 플러그인을 선언하지 않고 사용할 수 있음을 의미한다. 이는 스프링 부트가 사용하는 것과 동일한 버전의 의존성 관리 플러그인을 자동으로 사용함을 의미한다. 의존성 관리 플러그인을 적용한(apply) 다음 스프링 부트의 bom을 가져오도록 구성해보자: . Groovy . apply plugin: 'io.spring.dependency-management' dependencyManagement { imports { mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES) } } . Kotlin . apply(plugin = \"io.spring.dependency-management\") the&lt;DependencyManagementExtension&gt;().apply { imports { mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES) } } . 위 코틀린 코드는 약간 어색하다. 이는 의존성 관리 플러그인을 적용할 때 명령형 방식을 사용하고 있기 때문이다. 루트 상위 프로젝트에서 플러그인을 적용하거나, 스프링 부트 플러그인에 대해 수행하는 것처럼 plugins 블록을 사용하여 코드를 덜 어색하게 만들 수 있다. 이 방식의 단점은 의존성 관리 플러그인의 버전을 지정해야 한다는 것이다. plugins { java id(\"org.springframework.boot\") version \"2.7.12\" apply false id(\"io.spring.dependency-management\") version \"1.0.15.RELEASE\" } dependencyManagement { imports { mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES) } } . 3.1.3. Learning More . 의존성 관리 플러그인의 기능에 대해 자세히 알아보려면 해당 문서를 참조해보자. ",
    "url": "/docs/2.7.12/gradle_plugin/3.%20managing_dependencies/#31-managing-dependencies-with-the-dependency-management-plugin",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/3.%20managing_dependencies/#31-managing-dependencies-with-the-dependency-management-plugin"
  },"12": {
    "doc": "3. Managing Dependencies",
    "title": "3.2. Managing Dependencies with Gradle’s Bom Support",
    "content": "그레이들을 사용하면 bom을 플랫폼(platform) 또는 인포스트플랫폼(enforcedPlatform) 의존성으로 선언하여 프로젝트 버전을 관리하는 데 사용할 수 있다. 플랫폼 의존성은 bom의 버전을 권장 사항으로 취급하고 의존성 그래프의 다른 버전 및 제약 조건으로 인해 bom에서 선언된 것과 다른 의존성 버전이 사용될 수 있다. 인포스트플랫폼 의존성은 bom의 버전을 요구 사항으로 취급하며 의존성 그래프에 있는 다른 버전을 재정의한다. SpringBootPlugin 클래스는 다음 예제와 같이 그룹 ID, 아티팩트 ID 또는 버전을 알 필요 없이 스프링 부트의 bom 의존성을 선언하는 데 사용할 수 있는 BOM_COORDINATES 상수를 제공한다: . Groovy . dependencies { implementation platform(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES) } . Kotlin . dependencies { implementation(platform(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES)) } . 플랫폼 또는 인포스플랫폼은 선언된 구성 또는 선언된 구성에서 확장되는 구성의 버전만 제한한다. 결과적으로, 둘 이상의 구성에서 동일한 의존성을 선언하는 것이 필요할 수 있다. 3.2.1. Customizing Managed Versions . 그레이들 bom을 사용하면 spring-boot-dependencies의 프로퍼티로 관리하는 의존성 버전을 제어할 수 없다. 대신 그레이들이 제공하는 메커니즘 중 하나를 사용해야 한다. 그 메커니즘 중 하나는 해결 전략(resolution strategy)이다. SLF4J 모듈은 모두 org.slf4j 그룹에 있으므로 다음 예와 같이 해당 그룹의 모든 의존성을 특정 버전을 사용하도록 구성하여 해당 버전을 제어할 수 있다: . Groovy . configurations.all { resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt; if (details.requested.group == 'org.slf4j') { details.useVersion '1.7.20' } } } . Kotlin . configurations.all { resolutionStrategy.eachDependency { if (requested.group == \"org.slf4j\") { useVersion(\"1.7.20\") } } } . 각 스프링 부트 릴리스는 서드-파티 라이브러리 의존성에 대한 설계 및 테스트를 했다. 버전을 재정의하면 호환성 문제가 발생할 수 있으므로 주의해야 한다. ",
    "url": "/docs/2.7.12/gradle_plugin/3.%20managing_dependencies/#32-managing-dependencies-with-gradles-bom-support",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/3.%20managing_dependencies/#32-managing-dependencies-with-gradles-bom-support"
  },"13": {
    "doc": "4. Packaging Executable Archives",
    "title": "Chapter 4. Packaging Executable Archives",
    "content": "플러그인은 애플리케이션의 모든 의존성을 포함하고 java -jar로 실행할 수 있는 실행 가능한 압축파일(jar 파일 및 war 파일)를 생성할 수 있다. ",
    "url": "/docs/2.7.12/gradle_plugin/4.%20packaging_executable_archives/#chapter-4-packaging-executable-archives",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/4.%20packaging_executable_archives/#chapter-4-packaging-executable-archives"
  },"14": {
    "doc": "4. Packaging Executable Archives",
    "title": "4.1. Packaging Executable Jars",
    "content": "실행 가능한 jar는 bootJar 태스크(Task)를 사용하여 빌드할 수 있다. 태스크는 java 플러그인이 적용될 때 자동 생성되며 BootJar의 인스턴스이다. assemble 태스크는 bootJar 태스크에 따라 자동 구성되므로 assemble(또는 build)을 실행하면 bootJar 작업도 실행된다. ",
    "url": "/docs/2.7.12/gradle_plugin/4.%20packaging_executable_archives/#41-packaging-executable-jars",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/4.%20packaging_executable_archives/#41-packaging-executable-jars"
  },"15": {
    "doc": "4. Packaging Executable Archives",
    "title": "4.2. Packaging Executable Wars",
    "content": "실행 가능한 war는 bootWar 태스크를 사용하여 구축할 수 있다. 태스크는 war 플러그인 적용 시 자동으로 생성되며 BootWar의 인스턴스이다. assemble 태스크는 bootWar 태스크에 따라 자동으로 구성되므로 assemble(또는 build)을 실행하면 bootWar 태스크도 실행된다. 4.2.1. Packaging Executable and Deployable Wars . war 파일은 java -jar를 사용하여 실행하고 외부 컨테이너에 배포하도록 패키징할 수 있다. 그렇게 하려면, 내장된 서블릿 컨테이너 의존성을 providedRuntime 구성에 추가해야 한다. 예를 들어: . Groovy . dependencies { implementation('org.springframework.boot:spring-boot-starter-web') providedRuntime('org.springframework.boot:spring-boot-starter-tomcat') } . Kotlin . dependencies { implementation(\"org.springframework.boot:spring-boot-starter-web\") providedRuntime(\"org.springframework.boot:spring-boot-starter-tomcat\") } . 이렇게 하면 외부 컨테이너의 자체 클래스와 충돌하지 않는 war 파일의 WEB-INF/lib-provided 디렉터리에 패키징된다. 그레이들은 compileOnly 구성보다 providedRuntime이 선호되며, 무엇보다 compileOnly 의존성은 테스트 클래스패스에 없기 때문에 모든 웹 기반 통합 테스트가 실패한다. ",
    "url": "/docs/2.7.12/gradle_plugin/4.%20packaging_executable_archives/#42-packaging-executable-wars",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/4.%20packaging_executable_archives/#42-packaging-executable-wars"
  },"16": {
    "doc": "4. Packaging Executable Archives",
    "title": "4.3. Packaging Executable and Plain Archives",
    "content": "기본적으로, bootJar 또는 bootWar 태스크가 구성됐을 때, jar 또는 war 태스크는 압축파일 구분자(archive Classifier) 규약으로 plain이 추가로 구성된다. 이렇게 하면 bootJar와 jar 또는 bootWar와 war가 서로 다른 출력 위치를 갖게 되어 실행 가능한 압축파일과 일반 압축파일을 동시에 빌드할 수 있다. 만약 일반 압축파일이 아닌 실행 가능한 압축파일에 구분자를 사용하는 것을 선호하는 경우, jar 및 bootJar 태스크에 대해 다음 예제에 표시된 대로 구분자를 구성한다: . Groovy . tasks.named(\"bootJar\") { archiveClassifier = 'boot' } tasks.named(\"jar\") { archiveClassifier = '' } . Kotlin . tasks.named&lt;BootJar&gt;(\"bootJar\") { archiveClassifier.set(\"boot\") } tasks.named&lt;Jar&gt;(\"jar\") { archiveClassifier.set(\"\") } . 또는, 일반 압축파일이 빌드 되지 않게 하려면, jar 태스크에 대한 다음 예와 같이 해당 태스크를 비활성화해야 한다. Groovy . tasks.named(\"jar\") { enabled = false } . Kotlin . tasks.named&lt;Jar&gt;(\"jar\") { enabled = false } . ",
    "url": "/docs/2.7.12/gradle_plugin/4.%20packaging_executable_archives/#43-packaging-executable-and-plain-archives",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/4.%20packaging_executable_archives/#43-packaging-executable-and-plain-archives"
  },"17": {
    "doc": "4. Packaging Executable Archives",
    "title": "4.4. Configuring Executable Archive Packaging",
    "content": "BootJar 및 BootWar 태스크는 각각 그레이들의 Jar 및 War 태스크의 하위 클래스이다. 결과적으로, 모든 표준 구성 옵션은 jar 또는 war를 패키징할 때 사용할 수 있고, 실행 가능한 jar 또는 war를 패키징할 때도 사용할 수 있다. 실행 가능한 jar 및 war에 특정한 여러 구성 옵션도 제공된다. 4.4.1. Configuring the Main Class . 기본적으로, 실행 가능한 압축파일의 메인(main) 클래스는 태스크의 클래스 패스(class path) 내의 디렉토리에서 public static void main(String[]) 메서드가 있는 클래스를 찾아 자동으로 구성된다. 메인(main) 클래스는 태스크의 mainClass 프로퍼티를 사용하여 명시적으로 구성할 수도 있다: . Groovy . tasks.named(\"bootJar\") { mainClass = 'com.example.ExampleApplication' } . Kotlin . tasks.named&lt;BootJar&gt;(\"bootJar\") { mainClass.set(\"com.example.ExampleApplication\") } . 또는, 메인(main) 클래스 이름은 스프링 부터 DSL의 mainClass 프로퍼티를 사용하여 프로젝트 전체에 구성할 수 있다: . Groovy . springBoot { mainClass = 'com.example.ExampleApplication' } . Kotlin . springBoot { mainClass.set(\"com.example.ExampleApplication\") } . 만약 application 플러그인이 적용된 경우 해당 mainClass 프로퍼티를 반드시 구성해야 하며 동일한 용도로 사용할 수 있다: . Groovy . application { mainClass = 'com.example.ExampleApplication' } . Kotlin . application { mainClass.set(\"com.example.ExampleApplication\") } . 마지막으로, 태스크의 매니페스트에서 Start-Class attribute을 구성할 수 있다. Groovy . tasks.named(\"bootJar\") { manifest { attributes 'Start-Class': 'com.example.ExampleApplication' } } . Kotlin . tasks.named&lt;BootJar&gt;(\"bootJar\") { manifest { attributes(\"Start-Class\" to \"com.example.ExampleApplication\") } } . 만약, 메인 클래스가 코틀린으로 작성된 경우, 생성된 자바 클래스의 이름을 사용해야 한다. 기본적으로, Kt 접미사가 추가된 코트린 클래스의 이름이다. 예를 들어,ExampleApplication은 ExampleApplicationKt가 된다. @JvmName을 사용하여 다른 이름이 정의된 경우 해당 이름을 사용해야 한다. 4.4.2. Including Development-only Dependencies . 기본적으로 developmentOnly 구성에 선언된 모든 의존성은 실행 가능한 jar 또는 war에서 제외된다. 압축파일의 developmentOnly 구성에 선언된 의존성을 포함하려면, bootWar 태스크에 대한 다음 예제처럼, 구성을 포함하도록 태스크의 클래스패스를 구성한다: . Groovy . tasks.named(\"bootWar\") { classpath configurations.developmentOnly } . Kotlin . tasks.named&lt;BootWar&gt;(\"bootWar\") { classpath(configurations[\"developmentOnly\"]) } . 4.4.3. Configuring Libraries that Require Unpacking . 대부분의 라이브러리는 실행 가능한 압축파일에 중첩될 때 직접 사용할 수 있지만, 특정 라이브러리에는 문제가 있을 수 있다. 예를 들어 JRuby에는 jruby-complete.jar을 항상 파일 시스템에서 직접 사용 가능하다고 가정하는 자체 중첩된 jar 지원이 포함되어 있다. 문제가 있는 라이브러리를 처리하기 위해, 실행 가능한 압축파일이 실행될 때 특정 중첩된 jar의 압축을 임시 디렉토리에 풀도록 실행 가능한 압축파일을 구성할 수 있다. 라이브러리는 소스 jar 파일의 절대 경로와 일치하는 앤트-스타일(Ant-style)패턴을 사용하여 압축 해제가 필요한 것으로 식별할 수 있다: . Groovy . tasks.named(\"bootJar\") { requiresUnpack '**/jruby-complete-*.jar' } . Kotlin . tasks.named&lt;BootJar&gt;(\"bootJar\") { requiresUnpack(\"**/jruby-complete-*.jar\") } . 더 많은 제어를 위해 클로저(closure)를 사용할 수도 있다. 클로저는 FileTreeElement로 전달되며 압축 해제가 필요한지 여부를 나타내는 boolean을 반환해야 한다. 4.4.4. Making an Archive Fully Executable . Spring Boot는 완전히 실행 가능한 압축파일을 지원한다. 애플리케이션 실행 방법을 알고 있는 셸 스크립트를 추가하여 압축파일을 실행 가능하게 만든다. 유닉스와 같은 플랫폼에서, 시작 스크립트를 사용하여 압축파일을 다른 실행 파일처럼 직접 실행하거나 서비스로 설치할 수 있다. 현재 일부 도구는 이 형식을 허용하지 않으므로 항상 이 기술을 사용하지 못할 수도 있다. 예를 들어 jar -xf는 완전히 실행 가능한 jar 또는 war를 자동으로 추출하지 못할 수 있다. java -jar로 실행하거나 서블릿 컨테이너(servlet container)에 배포하는 것 보단, 직접 실행하려는 경우 이 옵션을 활성화하는 것이 좋다. 이 기능을 사용하려면, 실행 스크립트 포함을 활성화해야 한다: . Groovy . tasks.named(\"bootJar\") { launchScript() } . Kotlin . tasks.named&lt;BootJar&gt;(\"bootJar\") { launchScript() } . 이렇게 하면 스프링 부트의 기본 실행 스크립트가 압축파일에 추가된다. 기본 시작 스크립트에는 적절한 기본값이 있는 여러 속성이 포함되어 있다.properties 프로퍼티를 사용하여 값을 사용자 지정할 수 있다: . Groovy . tasks.named(\"bootJar\") { launchScript { properties 'logFilename': 'example-app.log' } } . Kotlin . tasks.named&lt;BootJar&gt;(\"bootJar\") { launchScript { properties(mapOf(\"logFilename\" to \"example-app.log\")) } } . 기본 시작 스크립트가 요구 사항을 충족하지 않는 경우, 스크립트 프로퍼티를 사용하여 사용자 지정 시작 스크립트를 제공할 수 있다: . Groovy . tasks.named(\"bootJar\") { launchScript { script = file('src/custom.script') } } . Kotlin . tasks.named&lt;BootJar&gt;(\"bootJar\") { launchScript { script = file(\"src/custom.script\") } } . 4.4.5. Using the PropertiesLauncher . PropertiesLauncher를 사용하여 실행 가능한 jar 또는 war를 실행하려면, 작업의 매니페스트를 구성하여 Main-Class 속성을 설정하십시오. Groovy . tasks.named(\"bootWar\") { manifest { attributes 'Main-Class': 'org.springframework.boot.loader.PropertiesLauncher' } } . Kotlin . tasks.named&lt;BootWar&gt;(\"bootWar\") { manifest { attributes(\"Main-C lass\" to \"org.springframework.boot loader.PropertiesLauncher\") } } . 4.4.6. Packaging Layered Jar or War . 기본적으로, bootJar 태스크는 BOOT-INF/classes 및 BOOT-INF/lib 각각에 애플리케이션 클래스와 의존성을 포함한 압축파일을 빌드한다. 마찬가지로, bootWar는 WEB-INF/classes에 애플리케이션 클래스를 포함하고 WEB-INF/lib 및 WEB-INF/lib-provided에 의존성을 포함하는 압축파일을 빌드한다. jar 콘텐츠에 도커 이미지를 빌드해야 하는 경우, 이러한 디렉토리를 더 분리하여 각 계층에 쓸 수 있도록 하는 것이 유용하다. 계층화된 jar는 일반 부트 패키지 jar와 동일한 레이아웃을 사용하지만, 각 계층을 설명하는 추가 메타-데이터(meta-data) 파일을 포함한다. 기본적으로, 다음 계층이 정의된다: . • 버전에 SNAPSHOT이 포함되지 않은 비-프로젝트 의존성에 대한 dependencies. • jar 로더 클래스를 위한 spring-boot-loader . • 버전에 SNAPSHOT이 포함된 비 프로젝트 의존성에 대한 snapshot-dependencies. • 프로젝트 의존성, 애플리케이션 클래스 및 리소스에 대한 application. 계층 순서는 애플리케이션의 일부가 변경될 때 이전 계층이 캐시될 수 있는 가능성을 결정하므로 중요하다. 기본 순서는 dependencies, spring-boot-loader, snapshot-dependencies, application이다. 변경 가능성이 가장 적은 콘텐츠을 먼저 추가한 다음, 변경 가능성이 높은 계층을 추가해야 한다. 이 기능을 비활성화하려면, 다음과 같은 방법으로 수행할 수 있다: . Groovy . tasks.named(\"bootJar\") { layered { enabled = false } } . Kotlin . tasks.named&lt;BootJar&gt;(\"bootJar\") { layered { isEnabled = false } } . 계층화된 jar 또는 war가 생성되면, spring-boot-jarmode-layertools jar가 압축파일에 대한 의존성으로 추가된다. 클래스 경로에 있는 이 jar 파일을 사용하면, 부트스트랩(bootstrap) 코드가 애플리케이션과 완전히 다른 것(예를들어, 계층을 추출하는 것)을 실행할 수 있는 특수 모드에서 애플리케이션을 시작할 수 있다. 이 의존성을 제외하려면 다음과 같은 방법으로 수행할 수 있다: . Groovy . tasks.named(\"bootJar\") { layered { includeLayerTools = false } } . Kotlin . tasks.named&lt;BootJar&gt;(\"bootJar\") { layered { isIncludeLayerTools = false } } . Custom Layers Configuration . 애플리케이션에 따라, 계층 생성 방법을 조정하고 새 계층를 추가할 수 있다. jar 또는 war를 계층으로 분리하는 방법과, 해당 계층의 순서를 설명하는 구성을 사용할 수 있다. 다음 예는 위에서 설명한 기본 순서를 명시적으로 정의하는 방법을 보여준다: . Groovy . tasks.named(\"bootJar\") { layered { application { intoLayer(\"spring-boot-loader\") { include \"org/springframework/boot/loader/**\" } intoLayer(\"application\") } dependencies { intoLayer(\"application\") { includeProjectDependencies() } intoLayer(\"snapshot-dependencies\") { include \"*:*:*SNAPSHOT\" } intoLayer(\"dependencies\") } layerOrder = [\"dependencies\", \"spring-boot-loader\", \"snapshot-dependencies\", \"application\"] } } . Kotlin . tasks.named&lt;BootJar&gt;(\"bootJar\") { layered { application { intoLayer(\"spring-boot-loader\") { include(\"org/springframework/boot/loader/**\") } intoLayer(\"application\") } dependencies { intoLayer(\"application\") { includeProjectDependencies() } intoLayer(\"snapshot-dependencies\") { include(\"*:*:*SNAPSHOT\") } intoLayer(\"dependencies\") } layerOrder = listOf(\"dependencies\", \"spring-boot-loader\", \"snapshot-dependencies\", \"application\") } } . layered DSL은 세 부분으로 정의된다. • application 클로저(closure)는 애플리케이션 클래스와 리소스가 계층화되는 방식을 정의한다. • dependencies 클로저는 의존성이 계층화되는 방법을 정의한다. • layerOrder 메서드는 계층이 작성되어야 하는 순서를 정의한다. 중첩된 intoLayer 클로저는 application 및 dependencies 섹션 내에서 계층에 대한 콘텐츠를 요청하는 데 사용된다. 이러한 클로저는 정의된 것처럼 위아래 순서대로 수행된다. 이전 intoLayer 클로저에 의해 소유권이 선점되지 않은 모든 콘텐츠는 후속 콘텐츠에서 사용할 수 있다. 또한 프로젝트 의존성을 포함하거나 제외하는 데 사용할 수 있는 ncludeProjectDependencies() 및 excludeProjectDependencies() 메서드를 제공한다. intoLayer 클로저는 중첩된 include 및 exclude 호출하여 콘텐츠를 선점한다. application 클로저는 include/exclude 파라미터에 앤트-스타일(Ant-style) 경로 일치를 사용한다. dependencies 섹션은 group:artifact[:version] 패턴을 사용한다. include 호출이 수행되지 않으면, 모든 콘텐츠(이전 클로저에서 소유권을 선점하지 않은 콘텐츠)가 고려된다. exclude 호출이 수행되지 않으면, 제외가 적용되지 않는다. 위의 예에서 dependencies 클로저를 보면, 첫 번째 intoLayer가 application 계층에 대한 모든 프로젝트 의존성을 요구한다는 것을 알 수 있다. 다음 intoLayer는 snapshot-dependencies 계층에 대한 모든 SNAPSHOT 의존성을 요구한다. 세 번째이자 마지막 intoLayer는 dependencies 계층에 대해 남아 있는 모든 항목(이 경우 프로젝트 의존성 또는 SNAPSHOT이 아닌 모든 의존성)을 요구한다. application 클로저에도 비슷한 규칙이 있다. spring-boot-loader 계층에 대한 org/springframework/boot/loader/** 콘텐츠를 처음 선점하는 것이다. 그런 다음 application 계층에 대한 나머지 클래스 및 리소스를 요청한다. intoLayer 클로저가 추가되는 순서는 종종 계층이 작성되는 순서와 다르다. 이러한 이유로 layerOrder 메소드는 항상 호출되어야 하며 intoLayer 호출이 참조하는 모든 계층을 커버해야 한다. ",
    "url": "/docs/2.7.12/gradle_plugin/4.%20packaging_executable_archives/#44-configuring-executable-archive-packaging",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/4.%20packaging_executable_archives/#44-configuring-executable-archive-packaging"
  },"18": {
    "doc": "4. Packaging Executable Archives",
    "title": "4. Packaging Executable Archives",
    "content": " ",
    "url": "/docs/2.7.12/gradle_plugin/4.%20packaging_executable_archives/",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/4.%20packaging_executable_archives/"
  },"19": {
    "doc": "5. Packaging OCI Images",
    "title": "Chapter 5. Packaging OCI Images",
    "content": "플러그인은 Cloud Native Buildpacks(CNB)를 사용하여 jar 또는 war 파일에서 OCI 이미지를 생성할 수 있다. bootBuildImage 태스크를 사용하여 이미지를 빌드할 수 있다. 보안상의 이유로 이미지는 루트가 아닌 사용자로 빌드 및 실행된다. 자세한 내용은 CNB 사양을 참조해보자. 태스크는 java 또는 war 플러그인이 적용될 때 자동으로 생성되며 BootBuildImage의 인스턴스이다. ",
    "url": "/docs/2.7.12/gradle_plugin/5.%20packaging_OCI_Images/#chapter-5-packaging-oci-images",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/5.%20packaging_OCI_Images/#chapter-5-packaging-oci-images"
  },"20": {
    "doc": "5. Packaging OCI Images",
    "title": "5.1. Docker Daemon",
    "content": "bootBuildImage 태스크에는 도커 데몬에 대한 액세스 권한이 필요하다. 기본적으로, 로컬 연결을 통해 도커 데몬과 통신한다. 이는 구성 없이 지원되는 모든 플랫폼에서 도커 엔진과 함께 작동한다. 환경 변수를 설정하여 bootBuildImage 태스크를 대체 로컬(alternative local) 또는 원격 연결을 사용하도록 구성할 수 있다. 다음 표는 환경 변수와 해당 값을 보여준다: . | Environment variable | Description | . | DOCKER_HOST | 도커 데몬의 호스트 및 포트를 포함하는 URL - 예를들어 tcp://192.168.99.100:2376 | . | DOCKER_TLS_VERIFY | 1로 설정된 경우 보안 HTTPS 프로토콜 활성화(선택 사항) | . | DOCKER_CERT_PATH | HTTPS용 인증서 및 키 파일의 경로(DOCKER_TLS_VERIFY=1인 경우 필수, 그렇지 않은 경우 무시됨) | . 플러그인 구성에서 도커 프로퍼티를 사용하여 도커 데몬 연결 정보를 제공할 수도 있다. 다음 표에는 사용 가능한 프로퍼티가 요약되어 있다: . | Property | Description | . | host | 도커 데몬의 호스트 및 포트를 포함하는 URL - 예를들어 tcp://192.168.99.100:2376 | . | tlsVerify | true로 설정된 경우 보안 HTTPS 프로토콜 활성화(선택 사항) | . | certPath | HTTPS용 인증서 및 키 파일의 경로(tlsVerify가 true인 경우 필요, 그렇지 않은 경우 무시됨) | . | bindHostToBuilder | When true, the value of the host property will be provided to the container that is created for the CNB builder (optional) | . 자세한 내용은 예제를 참조해보자. ",
    "url": "/docs/2.7.12/gradle_plugin/5.%20packaging_OCI_Images/#51-docker-daemon",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/5.%20packaging_OCI_Images/#51-docker-daemon"
  },"21": {
    "doc": "5. Packaging OCI Images",
    "title": "5. Packaging OCI Images",
    "content": " ",
    "url": "/docs/2.7.12/gradle_plugin/5.%20packaging_OCI_Images/",
    
    "relUrl": "/docs/2.7.12/gradle_plugin/5.%20packaging_OCI_Images/"
  },"22": {
    "doc": "2.7.12",
    "title": "2.7.12",
    "content": ". | spring-boot-reference | spring-boot-gradle-plugin-reference | . ",
    "url": "/docs/2.7.12/",
    
    "relUrl": "/docs/2.7.12/"
  },"23": {
    "doc": "용어사전 및 규칙",
    "title": "용어사전 및 규칙",
    "content": ". | 제목, 부제목과 내용 사이 줄 바꿈을 넣지 않는다. | 제목과 내용 이후 줄 바꿈을 2번 넣는다. | 코드와 코드예시 사이에는 줄 바꿈을 넣지 않는다. | 코드 예시와 다음 코드 예시 사이 줄 바꿈을 넣지 않는다. | . | 플러그인 명칭은 영문 그대로 표기한다. | Spring Boot 스프링 부트 | Gradle 그레이들 | Plugin 플러그인 | Archives 압축파일 | Package 패키지 | Applications 애플리케이션 | Executable jar 실행 가능한 jar | Build 빌드 | Dependency 의존성 | Property 프로퍼티 | Maven 메이븐 | Third Party 서드 파티 | Reference 레퍼런스 | Documentation 문서 | Section 섹션 | Task 태스크 | Archive Classifier 압축파일 구분자 | classpath 클래스패스 | Application 애플리케이션 | Closure 클로저 | Parameter 파라미터 | Contents 콘텐츠 | Docker 도커 | Daemon 데몬 | . ",
    "url": "/docs/grossary/",
    
    "relUrl": "/docs/grossary/"
  },"24": {
    "doc": "onestone",
    "title": "onestone",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  }
}
